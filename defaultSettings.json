{
  // 이 설정이 false이면 새 설정 값에 관계없이 원격 분석이 전송되지 않습니다. `telemetry.telemetryLevel` 설정에 결합되어 더 이상 사용되지 않습니다.
  // 크래시 보고서를 수집할 수 있습니다. 이는 안정성을 개선하는 데 도움이 됩니다.
  // 이 옵션을 적용하려면 다시 시작해야 합니다.
  "telemetry.enableCrashReporter": true,

  // 이 설정이 false이면 새 설정 값에 관계없이 원격 분석이 전송되지 않습니다. `telemetry.telemetryLevel` 설정으로 인해 더 이상 사용되지 않습니다.
  // 수집할 진단 데이터를 사용하도록 설정합니다. 이는 Visual Studio Code의 수행 방식과 당사의 수집 항목 및 개인 정보 보호 정책에 대해 개선이 필요한 부분[자세히 알아보기](https://go.microsoft.com/fwlink/?LinkId=521839)을 더 잘 이해하는 데 도움이 됩니다.
  "telemetry.enableTelemetry": true,

  // Copilot Chat과 같은 기능에서 문제 보고자, 설문 조사, 피드백 옵션과 같은 피드백 메커니즘을 활성화합니다.
  "telemetry.feedback.enabled": true,

  //
  // Visual Studio Code 원격 분석, 자사 확장 원격 분석 및 참여 타사 확장 원격 분석을 제어합니다. 일부 타사 확장은 이 설정을 따르지 않을 수 있습니다. 확인하려면 특정 확장의 설명서를 참조하세요. 원격 분석은 Visual Studio Code의 성능, 개선이 필요한 부분 및 기능이 사용되는 방식을 더 잘 이해하는 데 도움이 됩니다. [Microsoft가 수집하는 데이터](https://aka.ms/vscode-telemetry) 및 [개인정보처리방침](https://go.microsoft.com/fwlink/?LinkId=521839)에 대해 자세히 알아보세요. 크래시 보고 변경 사항을 적용하려면 응용 프로그램을 완전히 다시 시작해야 합니다.
  //
  // &nbsp;
  //
  // 다음 표에는 각 설정과 함께 전송되는 데이터가 요약되어 있습니다.
  //
  // |       | 크래시 보고서 | 오류 원격 분석 | 사용 데이터 |
  // |:------|:-------------:|:---------------:|:----------:|
  // | all   |       ✓       |        ✓        |     ✓      |
  // | error |       ✓       |        ✓        |     -      |
  // | crash |       ✓       |        -        |     -      |
  // | off   |       -       |        -        |     -      |
  //
  //
  // &nbsp;
  //
  // ****참고:*** 이 설정이 '꺼짐'이면 다른 원격 분석 설정에 관계없이 원격 분석이 전송되지 않습니다. 이 설정이 '해제'를 제외한 다른 것으로 설정되고 더 이상 사용되지 않는 설정으로 원격 분석이 비활성화된 경우 원격 분석이 전송되지 않습니다.*
  //
  //  - all: 사용 데이터, 오류 및 크래시 보고서를 보냅니다.
  //  - error: 일반 오류 원격 분석 및 크래시 보고서를 보냅니다.
  //  - crash: OS 수준 크래시 보고서를 보냅니다.
  //  - off: 모든 제품 원격 분석을 사용하지 않도록 설정합니다.
  "telemetry.telemetryLevel": "all",

  // 소스 제어 뷰에 인라인 작업을 항상 표시할지 여부를 제어합니다.
  "scm.alwaysShowActions": false,

  // 소스 제어 뷰에서 리포지토리를 항상 표시할지 여부를 제어합니다.
  "scm.alwaysShowRepositories": false,

  // 소스 제어 뷰에서 파일을 열 때 자동으로 표시하고 선택해야 하는지 여부를 제어합니다.
  "scm.autoReveal": true,

  // 소스 제어 뷰에서 폴더를 압축 형식으로 렌더링할지 여부를 제어합니다. 이러한 양식에서 단일 하위 폴더는 결합된 트리 요소로 압축됩니다.
  "scm.compactFolders": true,

  // 작업 막대에서 소스 제어 아이콘의 개수 배지를 제어합니다.
  //  - all: 모든 소스 제어 공급자 개수 배지의 합계를 표시합니다.
  //  - focused: 포커스가 있는 소스 제어 공급자의 개수 배지를 표시합니다.
  //  - off: 소스 제어 개수 배지를 사용하지 않도록 설정합니다.
  "scm.countBadge": "all",

  // 기본 소스 제어 리포지토리 보기 모드를 제어합니다.
  //  - tree: 리포지토리 변경 내용을 트리로 표시합니다.
  //  - list: 리포지토리 변경 내용을 목록으로 표시합니다.
  "scm.defaultViewMode": "list",

  // 목록으로 볼 때 기본 소스 제어 리포지토리 변경 정렬 순서를 제어합니다.
  //  - name: 파일 이름별로 리포지토리 변경 사항을 정렬합니다.
  //  - path: 경로별로 리포지토리 변경 사항을 정렬합니다.
  //  - status: 소스 제어 상태별로 리포지토리 변경 내용을 정렬합니다.
  "scm.defaultViewSortKey": "path",

  // 편집기에서 차이점 장식을 제어합니다.
  //  - all: 사용 가능한 모든 위치에서 diff 장식을 표시합니다.
  //  - gutter: 편집기 여백에만 diff 장식을 표시합니다.
  //  - overview: 개요 눈금자에만 diff 장식을 표시합니다.
  //  - minimap: 미니맵에서만 diff 장식을 표시합니다.
  //  - none: diff 장식을 표시하지 마세요.
  "scm.diffDecorations": "all",

  // 소스 제어 Diff 여백 장식의 동작을 제어합니다.
  //  - diff: 클릭 시 인라인 Diff Peek 보기를 표시합니다.
  //  - none: 아무 작업도 하지 않습니다.
  "scm.diffDecorationsGutterAction": "diff",

  // 여백의 diff 장식에 패턴이 사용되는지 여부를 제어합니다.
  "scm.diffDecorationsGutterPattern": {
    "added": false,
    "modified": true
  },

  // 여백에서 소스 제어 diff 데코레이터의 가시성을 제어합니다.
  //  - always: 항상 여백에 diff 데코레이터를 표시합니다.
  //  - hover: 호버에서만 여백의 다른 데코레이터를 표시합니다.
  "scm.diffDecorationsGutterVisibility": "always",

  // 여백에서 diff 장식의 너비(px)를 제어합니다(추가 및 수정됨).
  "scm.diffDecorationsGutterWidth": 3,

  // Source Control diff gutter 장식에서 선행 및 후행 공백을 무시할지 여부를 제어합니다.
  //  - true: 선행 및 후행 공백을 무시합니다.
  //  - false: 선행 및 후행 공백을 무시하지 마세요.
  //  - inherit: `diffEditor.ignoreTrimWhitespace`에서 상속합니다.
  "scm.diffDecorationsIgnoreTrimWhitespace": "false",

  // 소스 제어 그래프 보기에 표시되는 배지를 제어합니다. 기록 항목 그룹의 이름을 나타내는 그래프 오른쪽에 배지가 표시됩니다.
  //  - all: 소스 제어 그래프 보기에 모든 기록 항목 그룹의 배지를 표시합니다.
  //  - filter: 소스 제어 그래프 보기에서 필터로 사용되는 기록 항목 그룹의 배지만 표시합니다.
  "scm.graph.badges": "filter",

  // 목록의 끝까지 스크롤할 때 소스 제어 그래프 보기에서 항목의 다음 페이지를 로드할지 여부를 제어합니다.
  "scm.graph.pageOnScroll": true,

  // 기본적으로 더 많은 항목을 로드할 때 소스 제어 그래프 보기에 표시할 항목 수입니다.
  "scm.graph.pageSize": 50,

  // 입력 메시지의 글꼴을 제어합니다. 워크벤치 사용자 인터페이스 글꼴 패밀리의 경우 '기본값'을 사용하고, `editor.fontFamily` 값의 경우 `editor` 또는 사용자 지정 글꼴 패밀리를 사용합니다.
  "scm.inputFontFamily": "default",

  // 입력 메시지의 글꼴 크기를 픽셀 단위로 제어합니다.
  "scm.inputFontSize": 13,

  // 입력이 자동으로 증가할 최대 줄 수를 제어합니다.
  "scm.inputMaxLineCount": 10,

  // 입력이 자동으로 증가하는 최소 줄 수를 제어합니다.
  "scm.inputMinLineCount": 1,

  // 소스 제어 공급자 헤더의 개수 배지를 제어합니다. 이러한 헤더는 둘 이상의 공급자가 있거나 `scm.alwaysShowRepositories` 설정이 사용하도록 설정된 경우 소스 제어 뷰 및 소스 제어 리포지토리 뷰에 표시됩니다.
  //  - hidden: 소스 제어 공급자 개수 배지를 숨깁니다.
  //  - auto: 소스 제어 공급자 개수가 0이 아닌 경우에만 소스 제어 공급자 개수 배지를 표시합니다.
  //  - visible: 소스 제어 공급자 개수 배지를 표시합니다.
  "scm.providerCountBadge": "hidden",

  // 소스 제어 리포지토리 뷰에서 리포지토리의 정렬 순서를 제어합니다.
  //  - discovery time: 소스 제어 리포지토리 보기의 리포지토리는 검색 시간별로 정렬됩니다. 소스 제어 보기의 리포지토리는 선택한 순서대로 정렬됩니다.
  //  - name: 소스 제어 리포지토리 및 소스 제어 뷰의 리포지토리는 리포지토리 이름을 기준으로 정렬됩니다.
  //  - path: 소스 제어 리포지토리 및 소스 제어 뷰의 리포지토리는 리포지토리 경로별로 정렬됩니다.
  "scm.repositories.sortOrder": "discovery time",

  // 소스 제어 리포지토리 섹션에 표시되는 리포지토리 수를 제어합니다. 보기 크기를 수동으로 조정하려면 0으로 설정합니다.
  "scm.repositories.visible": 10,

  // 소스 제어 뷰에 작업 단추를 표시할 수 있는지 여부를 제어합니다.
  "scm.showActionButton": true,

  // 소스 제어 입력에 작업 단추를 표시할 수 있는지 여부를 제어합니다.
  "scm.showInputActionButton": true,

  // 작업 집합이 없는 소스 제어 기록 항목 그룹으로 전환할 때 사용할 기본 작업 집합을 제어합니다.
  //  - empty: 작업 집합이 없는 소스 제어 기록 항목 그룹으로 전환할 때 빈 작업 집합을 사용합니다.
  //  - current: 작업 집합이 없는 소스 제어 기록 항목 그룹으로 전환할 때 현재 작업 집합을 사용합니다.
  "scm.workingSets.default": "current",

  // 소스 제어 기록 항목 그룹 간에 전환할 때 편집기 작업 집합을 저장할지 여부를 제어합니다.
  "scm.workingSets.enabled": false,

  // 편집기에서 CodeLens를 표시할 것인지 여부를 제어합니다.
  "diffEditor.codeLens": false,

  //
  //  - legacy: 레거시 비교 알고리즘을 사용합니다.
  //  - advanced: 고급 비교 알고리즘을 사용합니다.
  "diffEditor.diffAlgorithm": "advanced",

  // 문자가 삽입되거나 삭제된 위치를 볼 수 있도록 diff 편집기에 빈 장식적 요소를 표시할지 여부를 제어합니다.
  "diffEditor.experimental.showEmptyDecorations": true,

  // diff 편집기에서 감지된 코드 이동을 표시할지 여부를 제어합니다.
  "diffEditor.experimental.showMoves": false,

  // 사용하도록 설정하고 편집기에서 인라인 보기를 사용하는 경우 단어 변경 내용이 인라인으로 렌더링됩니다.
  "diffEditor.experimental.useTrueInlineView": false,

  // 변경되지 않은 영역을 비교할 때 컨텍스트로 사용되는 줄 수를 제어합니다.
  "diffEditor.hideUnchangedRegions.contextLineCount": 3,

  // diff 편집기에 변경되지 않은 영역이 표시되는지 여부를 제어합니다.
  "diffEditor.hideUnchangedRegions.enabled": false,

  // 변경되지 않은 영역의 최소값으로 사용되는 줄 수를 제어합니다.
  "diffEditor.hideUnchangedRegions.minimumLineCount": 3,

  // 변경되지 않은 영역에 사용되는 줄 수를 제어합니다.
  "diffEditor.hideUnchangedRegions.revealLineCount": 20,

  // 사용하도록 설정하면 Diff 편집기가 선행 또는 후행 공백의 변경 내용을 무시합니다.
  "diffEditor.ignoreTrimWhitespace": true,

  // diff 계산이 취소된 후 밀리초 단위로 시간을 제한합니다. 제한 시간이 없는 경우 0을 사용합니다.
  "diffEditor.maxComputationTime": 5000,

  // 차이를 계산할 최대 파일 크기(MB)입니다. 제한이 없으면 0을 사용합니다.
  "diffEditor.maxFileSize": 50,

  // 사용하도록 설정하면 diff 편집기에 되돌리기 및 단계 작업을 위한 특수 여백이 표시됩니다.
  "diffEditor.renderGutterMenu": true,

  // diff 편집기에서 추가/제거된 변경 내용에 대해 +/- 표시기를 표시하는지 여부를 제어합니다.
  "diffEditor.renderIndicators": true,

  // 활성화되면 diff 편집기는 변경 내용을 되돌리기 위해 글리프 여백에 화살표를 표시합니다.
  "diffEditor.renderMarginRevertIcon": true,

  // diff 편집기에서 diff를 나란히 표시할지 인라인으로 표시할지를 제어합니다.
  "diffEditor.renderSideBySide": true,

  // diff 편집기 너비가 이 값보다 작으면 인라인 뷰가 사용됩니다.
  "diffEditor.renderSideBySideInlineBreakpoint": 900,

  // 사용하도록 설정하고 편집기 너비가 너무 작을 경우 인라인 보기가 사용됩니다.
  "diffEditor.useInlineViewWhenSpaceIsLimited": true,

  //
  //  - off: 줄이 바뀌지 않습니다.
  //  - on: 뷰포트 너비에서 줄이 바뀝니다.
  //  - inherit: 줄은 `editor.wordWrap` 설정에 따라 줄 바꿈됩니다.
  "diffEditor.wordWrap": "inherit",

  // 커밋 문자에 대한 제안을 허용할지를 제어합니다. 예를 들어 JavaScript에서는 세미콜론(';')이 제안을 허용하고 해당 문자를 입력하는 커밋 문자일 수 있습니다.
  "editor.acceptSuggestionOnCommitCharacter": true,

  // 'Tab' 키 외에 'Enter' 키에 대한 제안도 허용할지를 제어합니다. 새 줄을 삽입하는 동작과 제안을 허용하는 동작 간의 모호함을 없앨 수 있습니다.
  //  - on
  //  - smart: 텍스트를 변경할 때 `Enter` 키를 사용한 제안만 허용합니다.
  //  - off
  "editor.acceptSuggestionOnEnter": "on",

  // 화면 읽기 프로그램에서 한 번에 읽을 수 있는 편집기 줄 수를 제어합니다. 화면 읽기 프로그램을 검색하면 기본값이 500으로 자동 설정됩니다. 경고: 기본값보다 큰 수의 경우 성능에 영향을 미칩니다.
  "editor.accessibilityPageSize": 500,

  // 화면 판독기에 최적화된 모드에서 UI를 실행해야 하는지 여부를 제어합니다.
  //  - auto: 플랫폼 API를 사용하여 화면 읽기 프로그램이 연결된 시기를 감지합니다.
  //  - on: 화면 읽기 프로그램을 사용하여 사용을 최적화합니다.
  //  - off: 화면 읽기 프로그램이 연결되어 있지 않다고 가정합니다.
  "editor.accessibilitySupport": "auto",

  // 편집기에서 변수 글꼴 사용을 허용할지 여부를 제어합니다.
  "editor.allowVariableFonts": true,

  // 접근성 모드에서 편집기에서 변수 글꼴 사용을 허용할지 여부를 제어합니다.
  "editor.allowVariableFontsInAccessibilityMode": false,

  // 편집기에서 가변 줄 높이 사용을 허용할지 여부를 제어합니다.
  "editor.allowVariableLineHeights": true,

  // 사용자가 여는 괄호를 추가한 후 편집기에서 괄호를 자동으로 닫을지 여부를 제어합니다.
  //  - always
  //  - languageDefined: 언어 구성을 사용하여 대괄호를 자동으로 닫을 경우를 결정합니다.
  //  - beforeWhitespace: 커서가 공백의 왼쪽에 있는 경우에만 대괄호를 자동으로 닫습니다.
  //  - never
  "editor.autoClosingBrackets": "languageDefined",

  // 사용자가 여는 주석을 추가한 후 편집기에서 주석을 자동으로 닫을지 여부를 제어합니다.
  //  - always
  //  - languageDefined: 언어 구성을 사용하여 주석을 자동으로 닫을 경우를 결정합니다.
  //  - beforeWhitespace: 커서가 공백의 왼쪽에 있는 경우에만 주석을 자동으로 닫습니다.
  //  - never
  "editor.autoClosingComments": "languageDefined",

  // 삭제할 때 편집기에서 인접한 닫는 따옴표 또는 대괄호를 제거해야 할지를 제어합니다.
  //  - always
  //  - auto: 인접한 닫는 따옴표 또는 대괄호가 자동으로 삽입된 경우에만 제거합니다.
  //  - never
  "editor.autoClosingDelete": "auto",

  // 편집자가 닫는 따옴표 또는 대괄호 위에 입력할지 여부를 제어합니다.
  //  - always
  //  - auto: 닫기 따옴표 또는 대괄호가 자동으로 삽입된 경우에만 해당 항목 위에 입력합니다.
  //  - never
  "editor.autoClosingOvertype": "auto",

  // 사용자가 여는 따옴표를 추가한 후 편집기에서 따옴표를 자동으로 닫을지 여부를 제어합니다.
  //  - always
  //  - languageDefined: 언어 구성을 사용하여 따옴표를 자동으로 닫을 경우를 결정합니다.
  //  - beforeWhitespace: 커서가 공백의 왼쪽에 있는 경우에만 따옴표를 자동으로 닫습니다.
  //  - never
  "editor.autoClosingQuotes": "languageDefined",

  // 사용자가 줄을 입력, 붙여넣기, 이동 또는 들여쓰기 할 때 편집기에서 들여쓰기를 자동으로 조정하도록 할지 여부를 제어합니다.
  //  - none: 편집기는 들여쓰기를 자동으로 삽입하지 않습니다.
  //  - keep: 편집기는 현재 줄의 들여쓰기를 유지합니다.
  //  - brackets: 편집기는 현재 줄의 들여쓰기를 유지하고 언어 정의 대괄호를 사용합니다.
  //  - advanced: 편집기는 현재 줄의 들여쓰기를 유지하고 언어 정의 대괄호를 존중하며 언어별로 정의된 특별 EnterRules를 호출합니다.
  //  - full: 편집기는 현재 줄의 들여쓰기를 유지하고, 언어 정의 대괄호를 존중하고, 언어에 의해 정의된 특별 EnterRules를 호출하고, 언어에 의해 정의된 들여쓰기 규칙을 존중합니다.
  "editor.autoIndent": "full",

  // 편집기에서 붙여넣은 콘텐츠를 자동으로 들여쓰기할지 여부를 제어합니다.
  "editor.autoIndentOnPaste": false,

  // 문자열 내에 붙여넣을 때 편집기가 붙여넣은 콘텐츠를 자동으로 들여쓰기할지 여부를 제어합니다. 이는 autoIndentOnPaste가 true인 경우에 적용됩니다.
  "editor.autoIndentOnPasteWithinString": true,

  // 따옴표 또는 대괄호 입력 시 편집기가 자동으로 선택 영역을 둘러쌀지 여부를 제어합니다.
  //  - languageDefined: 언어 구성을 사용하여 선택 항목을 자동으로 둘러쌀 경우를 결정합니다.
  //  - quotes: 대괄호가 아닌 따옴표로 둘러쌉니다.
  //  - brackets: 따옴표가 아닌 대괄호로 둘러쌉니다.
  //  - never
  "editor.autoSurround": "languageDefined",

  // 대괄호 쌍 색 지정을 사용할지 여부를 제어합니다. `workbench.colorCustomizations`을(를) 사용하여 대괄호 강조 색을 재정의합니다.
  "editor.bracketPairColorization.enabled": true,

  // 각 대괄호 형식에 고유한 독립적인 색 풀이 있는지 여부를 제어합니다.
  "editor.bracketPairColorization.independentColorPoolPerBracketType": false,

  // `files.autoSave#`이(가) `afterDelay`(으)로 설정될 때 `#editor.codeActionsOnSave` 트리거 활성화 코드 동작이 창 변경 및 포커스 변경에 대해 트리거되려면 `always`(으)로 설정되어야 합니다.
  "editor.codeActions.triggerOnFocusChange": false,

  // 저장 시 편집기에 대한 코드 작업을 실행합니다. 코드 작업을 지정해야 하며 편집기를 종료하면 안 됩니다. `files.autoSave`이(가) 'afterDelay'로 설정된 경우 코드 작업은 파일이 명시적으로 저장될 때만 실행됩니다. 예: `"source.organizeImports": "explicit" `
  "editor.codeActionsOnSave": {},

  // 현재 진단 중이 아닐 때 줄 내에서 가장 가까운 빠른 수정 표시를 사용/사용 안 함으로 설정합니다.
  "editor.codeActionWidget.includeNearbyQuickFixes": true,

  // 코드 작업 메뉴에 그룹 헤더 표시를 활성화/비활성화합니다.
  "editor.codeActionWidget.showHeaders": true,

  // 편집기에서 CodeLens를 표시할 것인지 여부를 제어합니다.
  "editor.codeLens": true,

  // CodeLens의 글꼴 패밀리를 제어합니다.
  "editor.codeLensFontFamily": "",

  // CodeLens의 글꼴 크기(픽셀)를 제어합니다. 0으로 설정하면 `editor.fontSize`의 90%가 사용됩니다.
  "editor.codeLensFontSize": 0,

  // 편집기에서 인라인 색 데코레이터 및 색 선택을 렌더링할지를 제어합니다.
  "editor.colorDecorators": true,

  // 색 데코레이터에서 색 선택기를 표시할 조건을 제어합니다.
  //  - clickAndHover: 색 데코레이터를 클릭하고 마우스로 가리킬 때 색 선택기를 표시합니다.
  //  - hover: 색 데코레이터를 마우스로 가리키면 색 선택기가 표시되도록 설정
  //  - click: 색 데코레이터를 클릭할 때 색 선택기를 표시합니다.
  "editor.colorDecoratorsActivatedOn": "clickAndHover",

  // 편집기에서 한 번에 렌더링할 수 있는 최대 색 데코레이터 수를 제어합니다.
  "editor.colorDecoratorsLimit": 500,

  // 마우스와 키로 선택한 영역에서 열을 선택하도록 설정합니다.
  "editor.columnSelection": false,

  // 빈 줄을 줄 주석에 대한 토글, 추가 또는 제거 작업으로 무시해야 하는지를 제어합니다.
  "editor.comments.ignoreEmptyLines": true,

  // 주석을 달 때 공백 문자를 삽입할지 여부를 제어합니다.
  "editor.comments.insertSpace": true,

  // 구문 강조 표시를 클립보드로 복사할지 여부를 제어합니다.
  "editor.copyWithSyntaxHighlighting": true,

  // 커서 애니메이션 스타일을 제어합니다.
  "editor.cursorBlinking": "blink",

  // `editor.cursorStyle` 설정이 'line'으로 설정되어 있을 때 커서의 높이를 제어합니다. 커서의 최대 높이는 선 높이에 따라 달라집니다.
  "editor.cursorHeight": 0,

  // 매끄러운 캐럿 애니메이션의 사용 여부를 제어합니다.
  //  - off: 부드러운 캐럿 애니메이션을 사용할 수 없습니다.
  //  - explicit: 부드러운 캐럿 애니메이션은 사용자가 명시적 제스처를 사용하여 커서를 이동할 때만 사용됩니다.
  //  - on: 부드러운 캐럿 애니메이션은 항상 사용됩니다.
  "editor.cursorSmoothCaretAnimation": "off",

  // 삽입 입력 모드에서 커서 스타일을 제어합니다.
  "editor.cursorStyle": "line",

  // 커서 주변에 표시되는 선행 줄(최소 0)과 후행 줄(최소 1)의 최소 수를 제어합니다. 일부 다른 편집기에서는 'scrollOff' 또는 'scrollOffset'으로 알려져 있습니다.
  "editor.cursorSurroundingLines": 0,

  // `editor.cursorSurroundingLines`를 적용해야 하는 경우를 제어합니다.
  //  - default: 'cursorSurroundingLines'는 키보드 나 API를 통해 트리거될 때만 적용됩니다.
  //  - all: `cursorSurroundingLines`는 항상 적용됩니다.
  "editor.cursorSurroundingLinesStyle": "default",

  // `editor.cursorStyle` 설정이 'line'으로 설정되어 있을 때 커서의 넓이를 제어합니다.
  "editor.cursorWidth": 0,

  // 기본 문서 색 공급자를 사용하여 인라인 색 장식을 표시할지 여부를 제어합니다.
  //  - auto: 색 데코레이터를 제공하는 확장이 없는 경우에만 기본 색 데코레이터를 표시합니다.
  //  - always: 항상 기본 색 데코레이터를 표시합니다.
  //  - never: 기본 색 데코레이터를 표시하지 않습니다.
  "editor.defaultColorDecorators": "auto",

  // 다른 모든 접기 범위 공급자보다 우선하는 기본 접기 범위 공급자를 정의합니다. 접기 범위 공급자에 기여하는 확장의 식별자여야 합니다.
  //  - null: 모든 활성 접기 범위 공급자
  //  - formulahendry.code-runner: Run C, C++, Java, JS, PHP, Python, Perl, Ruby, Go, Lua, Groovy, PowerShell, CMD, BASH, F#, C#, VBScript, TypeScript, CoffeeScript, Scala, Swift, Julia, Crystal, OCaml, R, AppleScript, Elixir, VB.NET, Clojure, Haxe, Obj-C, Rust, Racket, Scheme, AutoHotkey, AutoIt, Kotlin, Dart, Pascal, Haskell, Nim, D, Lisp, Kit, V, SCSS, Sass, CUDA, Less, Fortran, Ring, Standard ML, Zig, Mojo, Erlang, SPWN, Pkl, Gleam
  //  - vscode.css-language-features: CSS, LESS 및 SCSS 파일에 대한 다양한 언어 지원을 제공합니다.
  //  - vscode.html-language-features: HTML 및 Handlebar 파일에 대해 다양한 언어 지원을 제공합니다.
  //  - vscode.json-language-features: JSON 파일에 대한 다양한 언어 지원을 제공합니다.
  //  - vscode.markdown-language-features: Markdown에 대한 다양한 언어 지원을 제공합니다.
  //  - vscode.markdown-math: 전자 필기장의 Markdown에 수학 지원을 추가합니다.
  //  - vscode.php-language-features: PHP 파일에 대한 다양한 언어 지원을 제공합니다.
  //  - syler.sass-indented: Indented Sass syntax Highlighting, Autocomplete & Formatter
  //  - vscode.typescript-language-features: JavaScript 및 TypeScript에 대한 다양한 언어 지원을 제공합니다.
  //  - dbaeumer.vscode-eslint: Integrates ESLint JavaScript into VS Code.
  //  - CoenraadS.bracket-pair-colorizer-2: A customizable extension for colorizing matching brackets
  //  - vscode.configuration-editing: 설정, 시작 및 확장 추천 파일과 같은 구성 파일에서 기능(고급 IntelliSense, 자동 수정)을 제공합니다.
  //  - vscode.debug-auto-launch: 노드 디버그 확장이 비활성화될 때 자동 연결 기능을 위한 도우미입니다.
  //  - vscode.debug-server-ready: 디버깅 중인 서버가 준비되면 브라우저에서 URI를 엽니다.
  //  - vscode.emmet: VS Code에 대한 Emmet 지원
  //  - vscode.extension-editing: 확장 제작을 위한 Lint 기능을 제공합니다.
  //  - vscode.git: Git SCM 통합
  //  - vscode.git-base: GIT 고정적 기여 및 선택기입니다.
  //  - donjayamanne.githistory: View git log, file history, compare branches or commits
  //  - vscode.github: VS Code용 GitHub 기능
  //  - vscode.github-authentication: GitHub 인증 공급자
  //  - vscode.grunt: Extension to add Grunt capabilities to VS Code.
  //  - vscode.gulp: VSCode에 Gulp 기능을 추가할 확장입니다.
  //  - vscode.ipynb: Jupyter의 .ipynb 노트북 파일 열기 및 읽기에 대한 기본 지원을 제공합니다
  //  - vscode.jake: VS Code에 Jake 기능을 추가할 확장입니다.
  //  - ms-vscode.js-debug: An extension for debugging Node.js programs and Chrome.
  //  - ms-vscode.js-debug-companion: Companion extension to js-debug that provides capability for remote debugging
  //  - glenn2223.live-sass: Compile Sass or Scss to CSS at realtime.
  //  - ritwickdey.LiveServer: Launch a development local Server with live reload feature for static & dynamic pages
  //  - vscode.media-preview: 이미지, 오디오 및 비디오에 대한 VS Code 기본 제공 미리 보기를 제공합니다.
  //  - vscode.merge-conflict: 인라인 병합 충돌에 대한 강조 표시 및 명령입니다.
  //  - vscode.microsoft-authentication: Microsoft 인증 공급자
  //  - vscode.npm: npm 스크립트에 대한 작업 지원을 추가할 확장입니다.
  //  - techer.open-in-browser: This allows you to open the current file in your default browser or application.
  //  - esbenp.prettier-vscode: Code formatter using prettier
  //  - vscode.references-view: 사이드바에서 검색 결과를 별도의 안정적인 보기로 참조
  //  - vscode.search-result: 탭된 검색 결과에 대한 구문 강조 표시 및 언어 기능을 제공합니다.
  //  - vscode.simple-browser: 웹 콘텐츠를 표시하기 위한 매우 기본적인 기본 제공 웹 보기입니다.
  //  - vscode.terminal-suggest: zsh, bash 및 fish 터미널에 대한 터미널 완성을 추가하는 확장입니다.
  //  - vscode.tunnel-forwarding: 전달 로컬 포트를 인터넷을 통해 액세스할 수 있도록 허용합니다.
  //  - ms-vscode.vscode-js-profile-table: Text visualizer for profiles taken from the JavaScript debugger
  "editor.defaultFoldingRangeProvider": null,

  // 다른 모든 포맷터 설정보다 우선하는 기본 포맷터를 정의합니다. 포맷터를 제공하는 확장 프로그램의 식별자 여야합니다.
  //  - null: None
  //  - formulahendry.code-runner: Run C, C++, Java, JS, PHP, Python, Perl, Ruby, Go, Lua, Groovy, PowerShell, CMD, BASH, F#, C#, VBScript, TypeScript, CoffeeScript, Scala, Swift, Julia, Crystal, OCaml, R, AppleScript, Elixir, VB.NET, Clojure, Haxe, Obj-C, Rust, Racket, Scheme, AutoHotkey, AutoIt, Kotlin, Dart, Pascal, Haskell, Nim, D, Lisp, Kit, V, SCSS, Sass, CUDA, Less, Fortran, Ring, Standard ML, Zig, Mojo, Erlang, SPWN, Pkl, Gleam
  //  - vscode.css-language-features: CSS, LESS 및 SCSS 파일에 대한 다양한 언어 지원을 제공합니다.
  //  - vscode.html-language-features: HTML 및 Handlebar 파일에 대해 다양한 언어 지원을 제공합니다.
  //  - vscode.json-language-features: JSON 파일에 대한 다양한 언어 지원을 제공합니다.
  //  - vscode.markdown-language-features: Markdown에 대한 다양한 언어 지원을 제공합니다.
  //  - vscode.markdown-math: 전자 필기장의 Markdown에 수학 지원을 추가합니다.
  //  - vscode.php-language-features: PHP 파일에 대한 다양한 언어 지원을 제공합니다.
  //  - esbenp.prettier-vscode: Code formatter using prettier
  //  - syler.sass-indented: Indented Sass syntax Highlighting, Autocomplete & Formatter
  //  - vscode.typescript-language-features: JavaScript 및 TypeScript에 대한 다양한 언어 지원을 제공합니다.
  //  - dbaeumer.vscode-eslint: Integrates ESLint JavaScript into VS Code.
  //  - CoenraadS.bracket-pair-colorizer-2: A customizable extension for colorizing matching brackets
  //  - vscode.configuration-editing: 설정, 시작 및 확장 추천 파일과 같은 구성 파일에서 기능(고급 IntelliSense, 자동 수정)을 제공합니다.
  //  - vscode.debug-auto-launch: 노드 디버그 확장이 비활성화될 때 자동 연결 기능을 위한 도우미입니다.
  //  - vscode.debug-server-ready: 디버깅 중인 서버가 준비되면 브라우저에서 URI를 엽니다.
  //  - vscode.emmet: VS Code에 대한 Emmet 지원
  //  - vscode.extension-editing: 확장 제작을 위한 Lint 기능을 제공합니다.
  //  - vscode.git: Git SCM 통합
  //  - vscode.git-base: GIT 고정적 기여 및 선택기입니다.
  //  - donjayamanne.githistory: View git log, file history, compare branches or commits
  //  - vscode.github: VS Code용 GitHub 기능
  //  - vscode.github-authentication: GitHub 인증 공급자
  //  - vscode.grunt: Extension to add Grunt capabilities to VS Code.
  //  - vscode.gulp: VSCode에 Gulp 기능을 추가할 확장입니다.
  //  - vscode.ipynb: Jupyter의 .ipynb 노트북 파일 열기 및 읽기에 대한 기본 지원을 제공합니다
  //  - vscode.jake: VS Code에 Jake 기능을 추가할 확장입니다.
  //  - ms-vscode.js-debug: An extension for debugging Node.js programs and Chrome.
  //  - ms-vscode.js-debug-companion: Companion extension to js-debug that provides capability for remote debugging
  //  - glenn2223.live-sass: Compile Sass or Scss to CSS at realtime.
  //  - ritwickdey.LiveServer: Launch a development local Server with live reload feature for static & dynamic pages
  //  - vscode.media-preview: 이미지, 오디오 및 비디오에 대한 VS Code 기본 제공 미리 보기를 제공합니다.
  //  - vscode.merge-conflict: 인라인 병합 충돌에 대한 강조 표시 및 명령입니다.
  //  - vscode.microsoft-authentication: Microsoft 인증 공급자
  //  - vscode.npm: npm 스크립트에 대한 작업 지원을 추가할 확장입니다.
  //  - techer.open-in-browser: This allows you to open the current file in your default browser or application.
  //  - vscode.references-view: 사이드바에서 검색 결과를 별도의 안정적인 보기로 참조
  //  - vscode.search-result: 탭된 검색 결과에 대한 구문 강조 표시 및 언어 기능을 제공합니다.
  //  - vscode.simple-browser: 웹 콘텐츠를 표시하기 위한 매우 기본적인 기본 제공 웹 보기입니다.
  //  - vscode.terminal-suggest: zsh, bash 및 fish 터미널에 대한 터미널 완성을 추가하는 확장입니다.
  //  - vscode.tunnel-forwarding: 전달 로컬 포트를 인터넷을 통해 액세스할 수 있도록 허용합니다.
  //  - ms-vscode.vscode-js-profile-table: Text visualizer for profiles taken from the JavaScript debugger
  "editor.defaultFormatter": null,

  // 이동 정의 마우스 제스처가 항상 미리 보기 위젯을 열지 여부를 제어합니다.
  "editor.definitionLinkOpensInPeek": false,

  // 파일 내용을 기반으로 파일을 열 때 `editor.tabSize#` 및 `#editor.insertSpaces`을(를) 자동으로 감지할지 여부를 제어합니다.
  "editor.detectIndentation": true,

  // 편집기에서 끌어서 놓기로 선택 영역을 이동할 수 있는지 여부를 제어합니다.
  "editor.dragAndDrop": true,

  // 편집기에서 파일을 여는 대신 `shift`를 누른 채 파일을 텍스트 편집기로 끌어서 놓을 수 있는지 여부를 제어합니다.
  "editor.dropIntoEditor.enabled": true,

  // 콘텐츠를 삭제할 때 사용할 기본 편집 유형을 구성합니다.
  //
  // 정렬된 편집 종류의 목록입니다. 기본 설정 종류의 첫 번째 사용 가능한 편집이 사용됩니다.
  "editor.dropIntoEditor.preferences": [],

  // 편집기에 파일을 끌어 놓을 때 위젯을 표시할지 여부를 제어합니다. 이 위젯을 사용하면 파일을 드롭하는 방법을 제어할 수 있습니다.
  //  - afterDrop: 파일이 편집기에 드롭된 후 드롭 선택기 위젯을 표시합니다.
  //  - never: 드롭 선택기 위젯을 표시하지 않습니다. 대신 기본 드롭 공급자가 항상 사용됩니다.
  "editor.dropIntoEditor.showDropSelector": "afterDrop",

  // 편집기에서 입력을 처리하기 위해 텍스트 영역 대신 EditContext API를 사용할지 여부를 설정합니다.
  "editor.editContext": true,

  // 선택 영역 없이 현재 줄 복사 여부를 제어합니다.
  "editor.emptySelectionClipboard": true,

  // 웹 작업자에서 토큰화가 비동기적으로 수행되어야 하는지 여부를 제어합니다.
  "editor.experimental.asyncTokenization": true,

  // 비동기 토큰화가 기록되어야 하는지 여부를 제어합니다. 디버깅 전용입니다.
  "editor.experimental.asyncTokenizationLogging": false,

  // 레거시 백그라운드 토큰화에 대해 비동기 토큰화를 확인해야 하는지 여부를 제어합니다. 토큰화 속도가 느려질 수 있습니다. 디버깅 전용입니다.
  "editor.experimental.asyncTokenizationVerification": false,

  // css에 대한 트리 시터 구문 분석 설정 여부를 제어합니다. css의 경우 'editor.experimental.treeSitterTelemetry'보다 우선합니다.
  "editor.experimental.preferTreeSitter.css": false,

  // ini에 대한 트리 시터 구문 분석 설정 여부를 제어합니다. ini에 대해 'editor.experimental.treeSitterTelemetry'보다 우선합니다.
  "editor.experimental.preferTreeSitter.ini": false,

  // regex에 트리 시터 구문 분석을 설정해야 하는지 여부를 제어합니다. 이는 regex에 대해 'editor.experimental.treeSitterTelemetry'보다 우선합니다.
  "editor.experimental.preferTreeSitter.regex": false,

  // TypeScript에 대한 트리 시터 구문 분석 설정 여부를 제어합니다. TypeScript에 대해 'editor.experimental.treeSitterTelemetry'보다 우선합니다.
  "editor.experimental.preferTreeSitter.typescript": false,

  // 트리 시터 구문 분석을 설정하고 원격 분석을 수집해야 하는지 여부를 제어합니다. 특정 언어에 대해 'editor.experimental.preferTreeSitter'를 설정하는 것이 우선적으로 적용됩니다.
  "editor.experimental.treeSitterTelemetry": false,

  // 실험적 GPU 가속을 사용하여 편집기를 렌더링할지 여부를 제어합니다.
  //  - off: 일반 DOM 기반 렌더링을 사용합니다.
  //  - on: GPU 가속을 사용합니다.
  "editor.experimentalGpuAcceleration": "off",

  // 공백이 새로운 실험적 메서드로 렌더링되는지 여부를 제어합니다.
  //  - svg: svgs와 함께 새 렌더링 메서드를 사용합니다.
  //  - font: 글꼴 문자와 함께 새 렌더링 방법을 사용합니다.
  //  - off: 안정적인 렌더링 방법을 사용합니다.
  "editor.experimentalWhitespaceRendering": "svg",

  // 'Alt' 키를 누를 때 스크롤 속도 승수입니다.
  "editor.fastScrollSensitivity": 5,

  // 위젯 찾기에서 편집기 맨 위에 줄을 추가해야 하는지 여부를 제어합니다. true인 경우 위젯 찾기가 표시되면 첫 번째 줄 위로 스크롤할 수 있습니다.
  "editor.find.addExtraSpaceOnTop": true,

  // 선택 영역에서 찾기를 자동으로 설정하는 조건을 제어합니다.
  //  - never: 선택 영역에서 찾기를 자동으로 켜지 않습니다(기본값).
  //  - always: 선택 영역에서 찾기를 항상 자동으로 켭니다.
  //  - multiline: 여러 줄의 콘텐츠를 선택하면 선택 항목에서 찾기가 자동으로 켜집니다.
  "editor.find.autoFindInSelection": "never",

  // 입력하는 동안 일치 항목을 찾기 위한 커서 이동 여부를 제어합니다.
  "editor.find.cursorMoveOnType": true,

  // 입력하는 동안 찾기 위젯이 검색할지 여부를 제어합니다.
  "editor.find.findOnType": true,

  // 위젯 찾기 기록을 저장하는 방법을 제어합니다.
  //  - never: 찾기 위젯에서 검색 기록을 저장하지 않습니다.
  //  - workspace: 활성 작업 영역에 검색 기록 저장
  "editor.find.history": "workspace",

  // 더 이상 일치하는 항목이 없을 때 검색을 처음이나 끝에서 자동으로 다시 시작할지 여부를 제어합니다.
  "editor.find.loop": true,

  // 바꾸기 위젯 기록을 저장하는 방법을 제어합니다.
  //  - never: 바꾸기 위젯의 기록을 저장하지 마세요.
  //  - workspace: 활성 작업 영역에서 바꾸기 기록 저장
  "editor.find.replaceHistory": "workspace",

  // 편집기 선택에서 Find Widget의 검색 문자열을 시딩할지 여부를 제어합니다.
  //  - never: 편집기 선택 영역에서 검색 문자열을 시드하지 마세요.
  //  - always: 커서 위치의 단어를 포함하여 항상 편집기 선택 영역에서 검색 문자열을 시드합니다.
  //  - selection: 편집기 선택 영역에서만 검색 문자열을 시드하세요.
  "editor.find.seedSearchStringFromSelection": "always",

  // 편집기에 코드 접기가 사용하도록 설정되는지 여부를 제어합니다.
  "editor.folding": true,

  // 편집기에서 접힌 범위를 강조 표시할지 여부를 제어합니다.
  "editor.foldingHighlight": true,

  // 편집기에서 가져오기 범위를 자동으로 축소할지 여부를 제어합니다.
  "editor.foldingImportsByDefault": false,

  // 폴더블 영역의 최대 수입니다. 현재 원본에 폴더블 영역이 많을 때 이 값을 늘리면 편집기의 반응이 떨어질 수 있습니다.
  "editor.foldingMaximumRegions": 5000,

  // 접기 범위를 계산하기 위한 전략을 제어합니다.
  //  - auto: 사용 가능한 경우 언어별 접기 전략을 사용합니다. 그렇지 않은 경우 들여쓰기 기반 전략을 사용합니다.
  //  - indentation: 들여쓰기 기반 접기 전략을 사용합니다.
  "editor.foldingStrategy": "auto",

  // 글꼴 패밀리를 제어합니다.
  "editor.fontFamily": "Consolas, 'Courier New', monospace",

  // 글꼴 합자 또는 글꼴 기능을 구성합니다. CSS 'font-feature-settings' 속성의 값에 대해 합자 또는 문자열을 사용하거나 사용하지 않도록 설정하기 위한 부울일 수 있습니다.
  "editor.fontLigatures": false,

  // 글꼴 크기(픽셀)를 제어합니다.
  "editor.fontSize": 14,

  // 글꼴 변형을 구성합니다. font-weight에서 font-variation-settings로 변환을 사용/사용하지 않도록 설정하는 부울이거나 CSS 'font-variation-settings' 속성 값에 대한 문자열일 수 있습니다.
  "editor.fontVariations": false,

  // 글꼴 두께를 제어합니다. "표준" 및 "굵게" 키워드 또는 1~1000 사이의 숫자를 허용합니다.
  "editor.fontWeight": "normal",

  // 붙여넣은 콘텐츠의 서식을 편집기에서 자동으로 지정할지 여부를 제어합니다. 포맷터를 사용할 수 있어야 하며 포맷터가 문서에서 범위의 서식을 지정할 수 있어야 합니다.
  "editor.formatOnPaste": false,

  // 저장 시 파일의 형식을 지정합니다. 포맷터를 사용할 수 있어야 하며 편집기를 종료하면 안 됩니다. `files.autoSave`이(가) 'afterDelay'로 설정된 경우 파일은 명시적으로 저장될 때만 형식이 지정됩니다.
  "editor.formatOnSave": false,

  // 저장 시 포맷이 전체 파일을 포맷하는지 또는 수정 내용만 포맷하는지를 제어합니다. '#editor.formatOnSave#'를 사용하도록 설정한 경우에만 적용됩니다.
  //  - file: 전체 파일을 포맷합니다.
  //  - modifications: 수정 사항을 포맷합니다(소스 제어 필요).
  //  - modificationsIfAvailable: 수정 사항만 형식화하려고 시도합니다(원본 제어 필요). 원본 제어를 사용할 수 없으면 전체 파일이 포맷됩니다.
  "editor.formatOnSaveMode": "file",

  // 입력 후 편집기에서 자동으로 줄의 서식을 지정할지 여부를 제어합니다.
  "editor.formatOnType": false,

  // 편집기에서 세로 문자 모양 여백을 렌더링할지 여부를 제어합니다. 문자 모양 여백은 주로 디버깅에 사용됩니다.
  "editor.glyphMargin": true,

  // '선언으로 이동'의 결과가 현재 위치일 때 실행되는 대체 명령 ID입니다.
  "editor.gotoLocation.alternativeDeclarationCommand": "editor.action.goToReferences",

  // '정의로 이동'의 결과가 현재 위치일 때 실행되는 대체 명령 ID입니다.
  "editor.gotoLocation.alternativeDefinitionCommand": "editor.action.goToReferences",

  // '구현으로 이동'의 결과가 현재 위치일 때 실행되는 대체 명령 ID입니다.
  "editor.gotoLocation.alternativeImplementationCommand": "",

  // '참조로 이동'의 결과가 현재 위치일 때 실행되는 대체 명령 ID입니다.
  "editor.gotoLocation.alternativeReferenceCommand": "",

  // '형식 정의로 이동'의 결과가 현재 위치일 때 실행되는 대체 명령 ID입니다.
  "editor.gotoLocation.alternativeTypeDefinitionCommand": "editor.action.goToReferences",

  // 이 설정은 더 이상 사용되지 않습니다. 대신 'editor.editor.gotoLocation.multipleDefinitions' 또는 'editor.editor.gotoLocation.multipleImplementations'와 같은 별도의 설정을 사용하세요.
  //
  "editor.gotoLocation.multiple": null,

  // 여러 대상 위치가 있는 경우 'Go to Declaration' 명령 동작을 제어합니다.
  //  - peek: 결과의 Peek 보기 표시(기본값)
  //  - gotoAndPeek: 기본 결과로 이동하여 Peek 보기를 표시합니다.
  //  - goto: 기본 결과로 이동하여 다른 항목에 대해 Peek 없는 탐색을 사용하도록 설정합니다.
  "editor.gotoLocation.multipleDeclarations": "peek",

  // 여러 대상 위치가 있는 경우 '정의로 이동' 명령 동작을 제어합니다.
  //  - peek: 결과의 Peek 보기 표시(기본값)
  //  - gotoAndPeek: 기본 결과로 이동하여 Peek 보기를 표시합니다.
  //  - goto: 기본 결과로 이동하여 다른 항목에 대해 Peek 없는 탐색을 사용하도록 설정합니다.
  "editor.gotoLocation.multipleDefinitions": "peek",

  // 여러 대상 위치가 있는 경우 '구현으로 이동' 명령 동작을 제어합니다.
  //  - peek: 결과의 Peek 보기 표시(기본값)
  //  - gotoAndPeek: 기본 결과로 이동하여 Peek 보기를 표시합니다.
  //  - goto: 기본 결과로 이동하여 다른 항목에 대해 Peek 없는 탐색을 사용하도록 설정합니다.
  "editor.gotoLocation.multipleImplementations": "peek",

  // 여러 대상 위치가 있는 경우 '참조로 이동' 명령 동작을 제어합니다.
  //  - peek: 결과의 Peek 보기 표시(기본값)
  //  - gotoAndPeek: 기본 결과로 이동하여 Peek 보기를 표시합니다.
  //  - goto: 기본 결과로 이동하여 다른 항목에 대해 Peek 없는 탐색을 사용하도록 설정합니다.
  "editor.gotoLocation.multipleReferences": "peek",

  // 여러 대상 위치가 있는 경우 '유형 정의로 이동' 명령 동작을 제어합니다.
  //  - peek: 결과의 Peek 보기 표시(기본값)
  //  - gotoAndPeek: 기본 결과로 이동하여 Peek 보기를 표시합니다.
  //  - goto: 기본 결과로 이동하여 다른 항목에 대해 Peek 없는 탐색을 사용하도록 설정합니다.
  "editor.gotoLocation.multipleTypeDefinitions": "peek",

  // 대괄호 쌍 안내선의 사용 여부를 제어합니다.
  //  - true: 대괄호 쌍 가이드를 사용하도록 설정합니다.
  //  - active: 활성 대괄호 쌍에 대해서만 대괄호 쌍 가이드를 사용하도록 설정합니다.
  //  - false: 대괄호 쌍 가이드를 비활성화합니다.
  "editor.guides.bracketPairs": false,

  // 가로 대괄호 쌍 안내선의 사용 여부를 제어합니다.
  //  - true: 수직 대괄호 쌍 가이드에 추가하여 수평 가이드를 사용하도록 설정합니다.
  //  - active: 활성 대괄호 쌍에 대해서만 수평 가이드를 사용하도록 설정합니다.
  //  - false: 수평 대괄호 쌍 가이드를 비활성화합니다.
  "editor.guides.bracketPairsHorizontal": "active",

  // 편집기가 활성 브래킷 쌍을 강조 표시해야 하는지 여부를 제어합니다.
  "editor.guides.highlightActiveBracketPair": true,

  // 편집기에서 활성 들여쓰기 가이드를 강조 표시할지 여부를 제어합니다.
  //  - true: 활성 들여쓰기 안내선을 강조 표시합니다.
  //  - always: 브래킷 안내선이 강조 표시된 경우에도 활성 들여쓰기 안내선을 강조 표시합니다.
  //  - false: 활성 들여쓰기 안내선을 강조 표시하지 마세요.
  "editor.guides.highlightActiveIndentation": true,

  // 편집기에서 들여쓰기 가이드를 렌더링할지를 제어합니다.
  "editor.guides.indentation": true,

  // 커서가 개요 눈금자에서 가려져야 하는지 여부를 제어합니다.
  "editor.hideCursorInOverviewRuler": false,

  // 공백이 있는 경우 선 위에 마우스를 가져가는 것을 표시하는 것을 선호합니다.
  "editor.hover.above": true,

  // 호버가 표시되기 전까지의 지연 시간(밀리초)을 제어합니다.
  "editor.hover.delay": 300,

  // 호버 표시 여부를 제어합니다.
  "editor.hover.enabled": true,

  // 호버가 숨겨지기 전까지의 지연 시간(밀리초)을 제어합니다. 'editor.hover.sticky'를 사용하도록 설정해야 합니다.
  "editor.hover.hidingDelay": 300,

  // 마우스를 해당 항목 위로 이동할 때 호버를 계속 표시할지 여부를 제어합니다.
  "editor.hover.sticky": true,

  // 들여쓰기 또는 `"tabSize"에서 '#editor.tabSize#'의 값을 사용하는 데 사용되는 공백 수입니다. 이 설정은 '#editor.detectIndentation#'이 켜져 있는 경우 파일 내용에 따라 재정의됩니다.
  "editor.indentSize": "tabSize",

  // 스크롤 관성 만들기 - Linux의 터치 패드에서 주로 유용합니다.
  "editor.inertialScroll": false,

  // 편집기에서 인레이 힌트를 사용하도록 설정합니다.
  //  - on: 인레이 힌트를 사용할 수 있음
  //  - onUnlessPressed: 인레이 힌트는 기본적으로 표시되고 Ctrl+Alt을(를) 길게 누를 때 숨겨집니다.
  //  - offUnlessPressed: 인레이 힌트는 기본값으로 숨겨져 있으며 Ctrl+Alt을(를) 길게 누르면 표시됩니다.
  //  - off: 인레이 힌트는 사용할 수 없음
  "editor.inlayHints.enabled": "on",

  // 편집기에서 인레이 힌트의 글꼴 패밀리를 제어합니다. 비워 두면 `editor.fontFamily`이(가) 사용됩니다.
  "editor.inlayHints.fontFamily": "",

  // 편집기에서 인레이 힌트의 글꼴 크기를 제어합니다. 기본적으로 `editor.fontSize`은(는) 구성된 값이 `5`보다 작거나 편집기 글꼴 크기보다 큰 경우에 사용됩니다.
  "editor.inlayHints.fontSize": 0,

  // 편집기에 의해 잘리기 전에 한 줄에 대한 인레이 힌트의 최대 전체 길이입니다. 자를 수 없도록 '0'으로 설정
  "editor.inlayHints.maximumLength": 43,

  // 편집기에서 인레이 힌트 주위의 패딩을 사용하도록 설정합니다.
  "editor.inlayHints.padding": false,

  // 인라인 완성이 표시될 때 화면 읽기 프로그램 사용자에게 접근성 힌트를 제공해야 하는지 여부를 제어합니다.
  "editor.inlineCompletionsAccessibilityVerbose": false,

  // 제안을 표시하면 코드가 인라인으로 제안 공간을 만들 수 있는지 여부를 제어합니다.
  "editor.inlineSuggest.edits.allowCodeShifting": "always",

  // 더 큰 제안을 나란히 표시할 수 있는지 여부를 제어합니다.
  //  - auto: 더 큰 제안은 공간이 충분하면 나란히 표시되고, 그렇지 않으면 아래에 표시됩니다.
  //  - never: 더 큰 제안은 나란히 표시되지 않으며 항상 아래에 표시됩니다.
  "editor.inlineSuggest.edits.renderSideBySide": "auto",

  // 제안으로 점프할 때까지 제안을 축소된 것으로 표시할지 여부를 제어합니다.
  "editor.inlineSuggest.edits.showCollapsed": false,

  // 편집기에서 인라인 제안을 자동으로 표시할지 여부를 제어합니다.
  "editor.inlineSuggest.enabled": true,

  // 지정한 확장 ID에 대한 인라인 완성을 억제합니다. 쉼표로 구분됩니다.
  "editor.inlineSuggest.experimental.suppressInlineSuggestions": "",

  // 인라인 제안 공급자가 변경될 때 명령을 트리거할지 여부를 제어합니다.
  "editor.inlineSuggest.experimental.triggerCommandOnProviderChange": true,

  // 인라인 제안의 글꼴 패밀리를 제어합니다.
  "editor.inlineSuggest.fontFamily": "default",

  // 인라인 추천 도구 모음을 표시할 시기를 제어합니다.
  //  - always: 인라인 추천을 표시힐 때마다 인라인 추천 도구 모음을 표시합니다.
  //  - onHover: 인라인 추천을 마우스로 가리키면 인라인 추천 도구 모음을 표시합니다.
  //  - never: 인라인 추천 도구 모음을 표시하지 않습니다.
  "editor.inlineSuggest.showToolbar": "onHover",

  // 인라인 제안이 제안 위젯과 상호 작용하는 방법을 제어합니다. 사용하도록 설정하면 인라인 제안을 사용할 수 있을 때 제안 위젯이 자동으로 표시되지 않습니다.
  "editor.inlineSuggest.suppressSuggestions": false,

  // 편집기에서 인라인 제안에 대한 구문 강조 표시를 표시할지 여부를 제어합니다.
  "editor.inlineSuggest.syntaxHighlightingEnabled": true,

  // `Tab`을 누를 때 공백을 삽입하세요. 이 설정은 `editor.detectIndentation`이(가) 켜져 있을 때 파일 내용을 기반으로 재정의됩니다.
  "editor.insertSpaces": true,

  // 들여쓰기를 늘리거나 줄이는 대괄호 기호를 정의합니다.
  "editor.language.brackets": null,

  // 대괄호 쌍 색 지정을 사용하는 경우 중첩 수준에 따라 색이 지정된 대괄호 쌍을 정의합니다.
  "editor.language.colorizedBracketPairs": null,

  // 큰 파일에 대한 특수 처리로, 메모리를 많이 사용하는 특정 기능을 사용하지 않도록 설정합니다.
  "editor.largeFileOptimizations": true,

  // 문자 간격(픽셀)을 제어합니다.
  "editor.letterSpacing": 0,

  // 편집기에서 코드 동작 전구를 사용하도록 설정합니다.
  //  - off: 코드 작업 메뉴를 사용하지 않도록 설정합니다.
  //  - onCode: 커서가 코드가 있는 줄에 있을 때 코드 동작 메뉴를 표시합니다.
  //  - on: 커서가 코드가 있는 줄 또는 빈 줄에 있는 경우 코드 동작 메뉴를 표시합니다.
  "editor.lightbulb.enabled": "onCode",

  // 선 높이를 제어합니다.
  //  - 0을 사용하여 글꼴 크기에서 줄 높이를 자동으로 계산합니다.
  //  - 0에서 8 사이의 값은 글꼴 크기의 승수로 사용됩니다.
  //  - 8보다 크거나 같은 값이 유효 값으로 사용됩니다.
  "editor.lineHeight": 0,

  // 줄 번호의 표시 여부를 제어합니다.
  //  - off: 줄 번호는 렌더링되지 않습니다.
  //  - on: 줄 번호는 절대값으로 렌더링 됩니다.
  //  - relative: 줄 번호는 커서 위치에서 줄 간격 거리로 렌더링 됩니다.
  //  - interval: 줄 번호는 매 10 줄마다 렌더링이 이루어집니다.
  "editor.lineNumbers": "on",

  // 편집기에서 연결된 편집이 사용하도록 설정되었는지를 제어합니다. 언어에 따라 관련 기호(예: HTML 태그)가 편집 중에 업데이트됩니다.
  "editor.linkedEditing": false,

  // 편집기에서 링크를 감지하고 클릭할 수 있게 만들지 여부를 제어합니다.
  "editor.links": true,

  // 일치하는 대괄호를 강조 표시합니다.
  "editor.matchBrackets": "always",

  // 이 길이를 초과하는 줄은 성능상의 이유로 토큰화되지 않습니다.
  "editor.maxTokenizationLineLength": 20000,

  // 미니맵을 자동으로 숨길지 여부를 제어합니다.
  //  - none: 미니맵은 항상 표시됩니다.
  //  - mouseover: 마우스가 미니맵 위에 있지 않으면 미니맵이 숨겨지고, 마우스가 미니맵 위에 있으면 미니맵이 표시됩니다.
  //  - scroll: 미니맵은 편집기가 스크롤될 때만 표시됩니다.
  "editor.minimap.autohide": "none",

  // 미니맵 표시 여부를 제어합니다.
  "editor.minimap.enabled": true,

  // 주석에서 섹션 헤더를 찾는 데 사용되는 정규식을 정의합니다. regex에는 섹션 헤더를 캡슐화하는 명명된 일치 그룹 'label'('(?<label>.+)'으로 작성됨)이 포함되어야 합니다. 그렇지 않으면 작동하지 않습니다. 필요에 따라 'separator'라는 다른 일치 그룹을 포함할 수 있습니다. 패턴에서 \n 사용하여 여러 줄 머리글을 일치시킬 수 있습니다.
  "editor.minimap.markSectionHeaderRegex": "\\bMARK:\\s*(?<separator>-?)\\s*(?<label>.*)$",

  // 최대 특정 수의 열을 렌더링하도록 미니맵의 너비를 제한합니다.
  "editor.minimap.maxColumn": 120,

  // 줄의 실제 문자(색 블록 아님)를 렌더링합니다.
  "editor.minimap.renderCharacters": true,

  // 미니맵에 그려진 콘텐츠의 배율: 1, 2 또는 3.
  "editor.minimap.scale": 1,

  // 미니맵에서 섹션 머리글의 글꼴 크기를 제어합니다.
  "editor.minimap.sectionHeaderFontSize": 9,

  // 구역 머리글 문자 사이의 간격(픽셀)을 제어합니다. 이렇게 하면 작은 글꼴 크기의 머리글 가독성을 높이는 데 도움이 됩니다.
  "editor.minimap.sectionHeaderLetterSpacing": 1,

  // MARK: 주석이 미니맵에 섹션 머리글로 표시되는지 여부를 제어합니다.
  "editor.minimap.showMarkSectionHeaders": true,

  // 명명된 영역을 미니맵에 섹션 머리글로 표시할지 여부를 제어합니다.
  "editor.minimap.showRegionSectionHeaders": true,

  // 미니맵 슬라이더가 표시되는 시기를 제어합니다.
  "editor.minimap.showSlider": "mouseover",

  // 미니맵을 렌더링할 측면을 제어합니다.
  "editor.minimap.side": "right",

  // 미니맵의 크기를 제어합니다.
  //  - proportional: 미니맵의 크기는 편집기 내용과 동일하며 스크롤할 수 있습니다.
  //  - fill: 편집기의 높이를 맞추기 위해 필요에 따라 미니맵이 확장되거나 축소됩니다(스크롤 없음).
  //  - fit: 미니맵을 편집기보다 작게 유지할 수 있도록 필요에 따라 미니맵이 축소됩니다(스크롤 없음).
  "editor.minimap.size": "proportional",

  // 마우스 휠 스크롤 이벤트의 `deltaX` 및 `deltaY`에서 사용할 승수입니다.
  "editor.mouseWheelScrollSensitivity": 1,

  // 마우스 휠을 사용할 때 'Ctrl' 키를 누르고 있으면 편집기의 글꼴을 확대/축소합니다.
  "editor.mouseWheelZoom": false,

  // 한 번에 활성 편집기에 있을 수 있는 최대 커서 수를 제어합니다.
  "editor.multiCursorLimit": 10000,

  // 여러 커서가 겹치는 경우 커서를 병합합니다.
  "editor.multiCursorMergeOverlapping": true,

  // 마우스로 여러 커서를 추가할 때 사용할 수정자입니다. [정의로 이동] 및 [링크 열기] 마우스 제스처가 [멀티커서 수정자와](https://code.visualstudio.com/docs/editor/codebasics#_multicursor-modifier) 충돌하지 않도록 조정됩니다.
  //  - ctrlCmd: Windows와 Linux의 'Control'을 macOS의 'Command'로 매핑합니다.
  //  - alt: Windows와 Linux의 'Alt'를 macOS의 'Option'으로 매핑합니다.
  "editor.multiCursorModifier": "alt",

  // 붙여넣은 텍스트의 줄 수가 커서 수와 일치하는 경우 붙여넣기를 제어합니다.
  //  - spread: 각 커서는 텍스트 한 줄을 붙여넣습니다.
  //  - full: 각 커서는 전체 텍스트를 붙여넣습니다.
  "editor.multiCursorPaste": "spread",

  // 열린 파일 전체에서 발생 수를 강조 표시할지 여부를 제어합니다.
  //  - off: 발생 항목을 강조 표시하지 않습니다.
  //  - singleFile: 현재 파일의 발생 항목만 강조 표시합니다.
  //  - multiFile: 실험적: 모든 유효한 열린 파일에서 발생 항목을 강조 표시합니다.
  "editor.occurrencesHighlight": "singleFile",

  // 발생이 강조 표시된 후의 지연 시간(밀리초)을 제어합니다.
  "editor.occurrencesHighlightDelay": 0,

  // 오버타입 입력 모드에서 커서 스타일을 제어합니다.
  "editor.overtypeCursorStyle": "block",

  // 붙여넣기를 오버타입해야 하는지 여부를 제어합니다.
  "editor.overtypeOnPaste": true,

  // 개요 눈금자 주위에 테두리를 그릴지 여부를 제어합니다.
  "editor.overviewRulerBorder": true,

  // 편집기의 아래쪽 가장자리와 마지막 줄 사이의 공백을 제어합니다.
  "editor.padding.bottom": 0,

  // 편집기의 위쪽 가장자리와 첫 번째 줄 사이의 공백을 제어합니다.
  "editor.padding.top": 0,

  // 매개변수 힌트 메뉴의 주기 혹은 목록의 끝에 도달하였을때 종료할 것인지 여부를 결정합니다.
  "editor.parameterHints.cycle": true,

  // 입력과 동시에 매개변수 문서와 유형 정보를 표시하는 팝업을 사용하도록 설정합니다.
  "editor.parameterHints.enabled": true,

  // 콘텐츠를 다른 방법으로 붙여넣을 수 있는지 여부를 제어합니다.
  "editor.pasteAs.enabled": true,

  // 콘텐츠를 붙여넣을 때 사용할 기본 편집 유형을 구성합니다.
  //
  // 정렬된 편집 종류의 목록입니다. 기본 설정 종류의 첫 번째 사용 가능한 편집이 사용됩니다.
  "editor.pasteAs.preferences": [],

  // 콘텐츠를 편집기에 붙여넣을 때 위젯을 표시할지 여부를 제어합니다. 이 위젯을 사용하여 파일을 붙여넣는 방법을 제어할 수 있습니다.
  //  - afterPaste: 콘텐츠를 편집기에 붙여넣은 후 붙여넣기 선택기 위젯을 표시합니다.
  //  - never: 붙여넣기 선택기 위젯을 표시하지 않습니다. 대신 기본 붙여넣기 동작이 항상 사용됩니다.
  "editor.pasteAs.showPasteSelector": "afterPaste",

  // 미리 보기 위젯에서 인라인 편집기에 포커스를 둘지 또는 트리에 포커스를 둘지를 제어합니다.
  //  - tree: Peek를 여는 동안 트리에 포커스
  //  - editor: 미리 보기를 열 때 편집기에 포커스
  "editor.peekWidgetDefaultFocus": "tree",

  // 입력하는 동안 제안을 자동으로 표시할지 여부를 제어합니다. 이것은 주석, 문자열 및 기타 코드를 입력하기 위해 제어할 수 있습니다. 빠른 제안은 고스트 텍스트 또는 제안 위젯으로 표시하도록 구성할 수 있습니다. 또한 제안이 특수 문자에 의해 실행되는지 여부를 제어하는 `editor.suggestOnTriggerCharacters`-설정에 유의하세요.
  "editor.quickSuggestions": {
    "other": "on",
    "comments": "off",
    "strings": "off"
  },

  // 빠른 제안을 표시하기 전까지의 지연 시간(밀리초)을 제어합니다.
  "editor.quickSuggestionsDelay": 10,

  // 이름을 바꾸기 전에 변경 내용을 미리 볼 수 있는 기능 사용/사용 안 함
  "editor.rename.enablePreview": true,

  // 사용되지 않습니다. 대신 `editor.linkedEditing`을 사용하세요.
  // 편집기가 유형에 따라 자동으로 이름을 바꿀지 여부를 제어합니다.
  "editor.renameOnType": false,

  // 편집기에서 제어 문자를 렌더링할지를 제어합니다.
  "editor.renderControlCharacters": true,

  // 파일이 줄 바꿈으로 끝나면 마지막 줄 번호를 렌더링합니다.
  "editor.renderFinalNewline": "on",

  // 편집기가 현재 줄 강조 표시를 렌더링하는 방식을 제어합니다.
  //  - none
  //  - gutter
  //  - line
  //  - all: 제본용 여백과 현재 줄을 모두 강조 표시합니다.
  "editor.renderLineHighlight": "line",

  // 편집기에 포커스가 있는 경우에만 편집기에서 현재 줄 강조 표시를 렌더링해야 하는지 제어합니다.
  "editor.renderLineHighlightOnlyWhenFocus": false,

  // 'editor.editContext'를 사용할 때 서식 있는 화면 읽기 프로그램 콘텐츠를 렌더링할지 여부입니다.
  "editor.renderRichScreenReaderContent": false,

  // 편집기에서 공백 문자를 렌더링할 방법을 제어합니다.
  //  - none
  //  - boundary: 단어 사이의 공백 하나를 제외한 공백 문자를 렌더링합니다.
  //  - selection: 선택한 텍스트에서만 공백 문자를 렌더링합니다.
  //  - trailing: 후행 공백 문자만 렌더링합니다.
  //  - all
  "editor.renderWhitespace": "selection",

  // 선택 항목의 모서리를 둥글게 할지 여부를 제어합니다.
  "editor.roundedSelection": true,

  // 특정 수의 고정 폭 문자 뒤에 세로 눈금자를 렌더링합니다. 여러 눈금자의 경우 여러 값을 사용합니다. 배열이 비어 있는 경우 눈금자가 그려지지 않습니다.
  "editor.rulers": [],

  // 화면 읽기 프로그램에서 인라인 제안을 발표하는지 여부를 제어합니다.
  "editor.screenReaderAnnounceInlineSuggestion": true,

  // 가로 스크롤 막대의 표시 유형을 제어합니다.
  //  - auto: 가로 스크롤 막대는 필요한 경우에만 표시됩니다.
  //  - visible: 가로 스크롤 막대가 항상 표시됩니다.
  //  - hidden: 가로 스크롤 막대를 항상 숨깁니다.
  "editor.scrollbar.horizontal": "auto",

  // 가로 스크롤 막대의 높이입니다.
  "editor.scrollbar.horizontalScrollbarSize": 12,

  // 설정하면 가로 스크롤 막대가 편집기 콘텐츠의 크기를 늘리지 않습니다.
  "editor.scrollbar.ignoreHorizontalScrollbarInContentHeight": false,

  // 클릭이 페이지별로 스크롤되는지 또는 클릭 위치로 이동할지 여부를 제어합니다.
  "editor.scrollbar.scrollByPage": false,

  // 세로 스크롤 막대의 표시 유형을 제어합니다.
  //  - auto: 세로 스크롤 막대는 필요한 경우에만 표시됩니다.
  //  - visible: 세로 스크롤 막대가 항상 표시됩니다.
  //  - hidden: 세로 스크롤 막대를 항상 숨깁니다.
  "editor.scrollbar.vertical": "auto",

  // 세로 스크롤 막대의 너비입니다.
  "editor.scrollbar.verticalScrollbarSize": 14,

  // 편집기에서 가로로 스크롤되는 범위를 벗어나는 추가 문자의 수를 제어합니다.
  "editor.scrollBeyondLastColumn": 4,

  // 편집기에서 마지막 줄 이후로 스크롤할지 여부를 제어합니다.
  "editor.scrollBeyondLastLine": true,

  // 가운데 단추를 누를 때 편집기가 스크롤할지 여부를 제어합니다.
  "editor.scrollOnMiddleClick": false,

  // 세로와 가로로 동시에 스크롤할 때에만 주축을 따라서 스크롤합니다. 트랙패드에서 세로로 스크롤할 때 가로 드리프트를 방지합니다.
  "editor.scrollPredominantAxis": true,

  // 편집기가 선택 항목과 유사한 일치 항목을 강조 표시해야하는지 여부를 제어합니다.
  "editor.selectionHighlight": true,

  // 유사한 일치 항목이 강조 표시가 사라지기 전에 선택 영역에 포함될 수 있는 문자의 개수를 제어합니다. 무제한의 경우 0으로 설정합니다.
  "editor.selectionHighlightMaxLength": 200,

  // 편집기에서 여러 줄에 걸쳐 일치된 선택 항목을 강조 표시할지 여부를 제어합니다.
  "editor.selectionHighlightMultiline": false,

  // semanticHighlighting이 지원하는 언어에 대해 표시되는지 여부를 제어합니다.
  //  - true: 모든 색 테마에 대해 의미 체계 강조 표시를 사용합니다.
  //  - false: 모든 색 테마에 대해 의미 체계 강조 표시를 사용하지 않습니다.
  //  - configuredByTheme: 의미 체계 강조 표시는 현재 색 테마의 `semanticHighlighting` 설정에 따라 구성됩니다.
  "editor.semanticHighlighting.enabled": "configuredByTheme",

  // 현재 선택한 색 테마의 편집기 의미 체계 색과 스타일을 재정의합니다.
  "editor.semanticTokenColorCustomizations": {},

  // 취소선 사용되지 않는 변수를 제어합니다.
  "editor.showDeprecated": true,

  // 여백의 접기 컨트롤이 표시되는 시기를 제어합니다.
  //  - always: 접기 컨트롤을 항상 표시합니다.
  //  - never: 접기 컨트롤을 표시하지 않고 여백 크기를 줄이세요.
  //  - mouseover: 마우스가 여백 위에 있을 때에만 접기 컨트롤을 표시합니다.
  "editor.showFoldingControls": "mouseover",

  // 사용하지 않는 코드의 페이드 아웃을 제어합니다.
  "editor.showUnused": true,

  // 선행 및 후행 공백을 항상 선택해야 하는지 여부입니다.
  "editor.smartSelect.selectLeadingAndTrailingWhitespace": true,

  // 하위 단어(예: 'fooBar'의 'foo' 또는 'foo_bar')를 선택해야 하는지 여부입니다.
  "editor.smartSelect.selectSubwords": true,

  // 편집기에서 애니메이션을 사용하여 스크롤할지 여부를 제어합니다.
  "editor.smoothScrolling": false,

  // 코드 조각으로 둘러싸기 또는 파일 템플릿 코드 조각이 코드 작업으로 표시되는지 여부를 제어합니다.
  "editor.snippets.codeActions.enabled": true,

  // 코드 조각이 다른 추천과 함께 표시되는지 여부 및 정렬 방법을 제어합니다.
  //  - top: 다른 제안 위에 조각 제안을 표시합니다.
  //  - bottom: 다른 제안 아래에 조각 제안을 표시합니다.
  //  - inline: 다른 제안과 함께 조각 제안을 표시합니다.
  //  - none: 코드 조각 제안을 표시하지 않습니다.
  "editor.snippetSuggestions": "inline",

  // 해당 콘텐츠를 두 번 클릭하거나 'Esc' 키를 누르더라도 Peek 편집기를 열린 상태로 유지합니다.
  "editor.stablePeek": false,

  // 고정할 줄을 결정하는 데 사용할 모델을 정의합니다. 개요 모델이 없으면 들여쓰기 모델에 해당하는 접기 공급자 모델에서 대체됩니다. 이 순서는 세 가지 경우 모두 적용됩니다.
  "editor.stickyScroll.defaultModel": "outlineModel",

  // 편집기 위쪽에서 스크롤하는 동안 중첩된 현재 범위를 표시합니다.
  "editor.stickyScroll.enabled": true,

  // 표시할 최대 고정 선 수를 정의합니다.
  "editor.stickyScroll.maxLineCount": 5,

  // 편집기의 가로 스크롤 막대를 사용하여 고정 스크롤 스크롤을 사용하도록 설정합니다.
  "editor.stickyScroll.scrollWithEditor": true,

  // 들여쓰기에 공백을 사용할 때 탭 문자의 선택 동작을 에뮬레이트합니다. 선택 영역이 탭 정지에 고정됩니다.
  "editor.stickyTabStops": false,

  // 이 설정은 더 이상 사용되지 않습니다. 대신 'editor.suggest.showKeywords'또는 'editor.suggest.showSnippets'와 같은 별도의 설정을 사용하세요.
  //
  "editor.suggest.filteredTypes": {},

  // 제안 필터링 및 정렬에서 작은 오타를 설명하는지 여부를 제어합니다.
  "editor.suggest.filterGraceful": true,

  // 완료를 수락할 때 단어를 덮어쓸지 여부를 제어합니다. 이것은 이 기능을 선택하는 확장에 따라 다릅니다.
  //  - insert: 커서의 텍스트 오른쪽을 덮어 쓰지않고 제안을 삽입합니다.
  //  - replace: 제안을 삽입하고 커서의 오른쪽 텍스트를 덮어씁니다.
  "editor.suggest.insertMode": "insert",

  // 정렬할 때 커서 근처에 표시되는 단어를 우선할지를 제어합니다.
  "editor.suggest.localityBonus": false,

  // IntelliSense 필터링을 활성화하면 첫 번째 문자가 단어 시작 부분과 일치해야 합니다(예: `c`의 경우 `Console` 또는 `WebContext`가 될 수 있으며 `description`은 _안 됨_). 비활성화하면 IntelliSense가 더 많은 결과를 표시하지만 여전히 일치 품질을 기준으로 정렬합니다.
  "editor.suggest.matchOnWordStartOnly": true,

  // 이 설정은 더 이상 사용되지 않습니다. 이제 제안 위젯의 크기를 조정할 수 있습니다.
  //
  "editor.suggest.maxVisibleSuggestions": 0,

  // 편집기에서 제안 결과를 미리볼지 여부를 제어합니다.
  "editor.suggest.preview": false,

  // 위젯이 표시될 때 제안을 선택할지 여부를 제어합니다. 이는 자동으로 트리거된 제안(`editor.quickSuggestions#` 및 `#editor.suggestOnTriggerCharacters`)에만 적용되며, 제안이 명시적으로 호출될 때 항상 선택됩니다(예: 'Ctrl+Space'를 통해).
  //  - always: IntelliSense를 자동으로 트리거할 때 항상 제안을 선택합니다.
  //  - never: IntelliSense를 자동으로 트리거할 때 제안을 선택하지 마세요.
  //  - whenTriggerCharacter: 트리거 문자에서 IntelliSense를 트리거할 때만 제안을 선택합니다.
  //  - whenQuickSuggestion: 입력할 때 IntelliSense를 트리거할 때만 제안을 선택합니다.
  "editor.suggest.selectionMode": "always",

  // 저장된 제안 사항 선택 항목을 여러 작업 영역 및 창에서 공유할 것인지 여부를 제어합니다(`editor.suggestSelection` 필요).
  "editor.suggest.shareSuggestSelections": false,

  // 사용하도록 설정되면 IntelliSense에 '클래스' 제안이 표시됩니다.
  "editor.suggest.showClasses": true,

  // 사용하도록 설정되면 IntelliSense에 '색' 제안이 표시됩니다.
  "editor.suggest.showColors": true,

  // 사용하도록 설정되면 IntelliSense에 '상수' 제안이 표시됩니다.
  "editor.suggest.showConstants": true,

  // 사용하도록 설정되면 IntelliSense에 '생성자' 제안이 표시됩니다.
  "editor.suggest.showConstructors": true,

  // 사용하도록 설정되면 IntelliSense에 '사용자 지정 색' 제안이 표시됩니다.
  "editor.suggest.showCustomcolors": true,

  // 사용하도록 설정되면 IntelliSense에 '사용되지 않음' 제안이 표시됩니다.
  "editor.suggest.showDeprecated": true,

  // 사용하도록 설정되면 IntelliSense에 `enumMember` 제안이 표시됩니다.
  "editor.suggest.showEnumMembers": true,

  // 사용하도록 설정되면 IntelliSense에 '열거형' 제안이 표시됩니다.
  "editor.suggest.showEnums": true,

  // 사용하도록 설정되면 IntelliSense에 '이벤트' 제안이 표시됩니다.
  "editor.suggest.showEvents": true,

  // 사용하도록 설정되면 IntelliSense에 '필드' 제안이 표시됩니다.
  "editor.suggest.showFields": true,

  // 사용하도록 설정되면 IntelliSense에 `파일` 제안이 표시됩니다.
  "editor.suggest.showFiles": true,

  // 사용하도록 설정되면 IntelliSense에 '폴더' 제안이 표시됩니다.
  "editor.suggest.showFolders": true,

  // 사용하도록 설정되면 IntelliSense에 '함수' 제안이 표시됩니다.
  "editor.suggest.showFunctions": true,

  // 제안의 아이콘을 표시할지 여부를 제어합니다.
  "editor.suggest.showIcons": true,

  // 제안 세부 정보가 레이블과 함께 인라인에 표시되는지 아니면 세부 정보 위젯에만 표시되는지를 제어합니다.
  "editor.suggest.showInlineDetails": true,

  // 사용하도록 설정되면 IntelliSense에 '인터페이스' 제안이 표시됩니다.
  "editor.suggest.showInterfaces": true,

  // IntelliSense를 사용하도록 설정한 경우 `issues`-제안을 표시합니다.
  "editor.suggest.showIssues": true,

  // 사용하도록 설정되면 IntelliSense에 '키워드' 제안이 표시됩니다.
  "editor.suggest.showKeywords": true,

  // 사용하도록 설정되면 IntelliSense에 `메서드` 제안이 표시됩니다.
  "editor.suggest.showMethods": true,

  // 사용하도록 설정되면 IntelliSense에 '모듈' 제안이 표시됩니다.
  "editor.suggest.showModules": true,

  // 사용하도록 설정되면 IntelliSense에 `연산자` 제안이 표시됩니다.
  "editor.suggest.showOperators": true,

  // 사용하도록 설정되면 IntelliSense에 '속성' 제안이 표시됩니다.
  "editor.suggest.showProperties": true,

  // 사용하도록 설정되면 IntelliSense에 '참조' 제안이 표시됩니다.
  "editor.suggest.showReferences": true,

  // 사용하도록 설정되면 IntelliSense에 '코드 조각' 제안이 표시됩니다.
  "editor.suggest.showSnippets": true,

  // 제안 위젯 하단의 상태 표시줄 가시성을 제어합니다.
  "editor.suggest.showStatusBar": false,

  // 사용하도록 설정되면 IntelliSense에 '구조' 제안이 표시됩니다.
  "editor.suggest.showStructs": true,

  // 사용하도록 설정된 경우 IntelliSense에 'typeParameter' 제안이 표시됩니다.
  "editor.suggest.showTypeParameters": true,

  // 사용하도록 설정되면 IntelliSense에 '단위' 제안이 표시됩니다.
  "editor.suggest.showUnits": true,

  // IntelliSense를 사용하도록 설정하면 `user`-제안이 표시됩니다.
  "editor.suggest.showUsers": true,

  // 사용하도록 설정되면 IntelliSense에 '값' 제안이 표시됩니다.
  "editor.suggest.showValues": true,

  // 사용하도록 설정되면 IntelliSense에 '변수' 제안이 표시됩니다.
  "editor.suggest.showVariables": true,

  // 사용하도록 설정되면 IntelliSense에 '텍스트' 제안이 표시됩니다.
  "editor.suggest.showWords": true,

  // 활성 코드 조각이 빠른 제안을 방지하는지 여부를 제어합니다.
  "editor.suggest.snippetsPreventQuickSuggestions": false,

  // 제안 위젯의 글꼴 크기입니다. `0`(으)로 설정하면 `editor.fontSize` 값이 사용됩니다.
  "editor.suggestFontSize": 0,

  // 제안 위젯의 줄 높이입니다. `0`(으)로 설정하면 `editor.lineHeight` 값이 사용됩니다. 최소값은 8입니다.
  "editor.suggestLineHeight": 0,

  // 트리거 문자를 입력할 때 제안을 자동으로 표시할지 여부를 제어합니다.
  "editor.suggestOnTriggerCharacters": true,

  // 제안 목록을 표시할 때 제한이 미리 선택되는 방식을 제어합니다.
  //  - first: 항상 첫 번째 제안을 선택합니다.
  //  - recentlyUsed: `log`가 최근에 완료되었으므로 추가 입력에서 제안을 선택하지 않은 경우 최근 제안을 선택하세요(예: `console.| -> console.log`).
  //  - recentlyUsedByPrefix: 해당 제안을 완료한 이전 접두사에 따라 제안을 선택합니다(예: `co -> console` 및 `con -> const`).
  "editor.suggestSelection": "first",

  // 탭 완성을 사용하도록 설정합니다.
  //  - on: 탭 완료는 탭을 누를 때 가장 일치하는 제안을 삽입합니다.
  //  - off: 탭 완성을 사용하지 않도록 설정합니다.
  //  - onlySnippets: 접두사가 일치하는 경우 코드 조각을 탭 완료합니다. 'quickSuggestions'를 사용하지 않을 때 가장 잘 작동합니다.
  "editor.tabCompletion": "off",

  // 편집기에서 탭을 받을지 또는 탐색을 위해 워크벤치로 미룰지를 제어합니다.
  "editor.tabFocusMode": false,

  // 탭이 같은 공백의 수입니다. 이 설정은 `editor.detectIndentation`이(가) 켜져 있을 때 파일 내용을 기반으로 재정의됩니다.
  "editor.tabSize": 4,

  // 현재 선택한 색 테마의 편집기 구문 색과 글꼴 스타일을 재정의합니다.
  "editor.tokenColorCustomizations": {},

  // 끝에 자동 삽입된 공백을 제거합니다.
  "editor.trimAutoWhitespace": true,

  // 줄 바꿈을 삭제할 때 편집기에서 다음 줄의 들여쓰기 공백도 삭제할지 여부를 제어합니다.
  "editor.trimWhitespaceOnDelete": false,

  // 접힌 줄이 줄을 펼친 후 빈 콘텐츠를 클릭할지 여부를 제어합니다.
  "editor.unfoldOnClickAfterEndOfLine": false,

  // 강조 표시되지 않는 허용된 문자를 정의합니다.
  "editor.unicodeHighlight.allowedCharacters": {},

  // 허용된 로캘에서 공통적인 유니코드 문자는 강조 표시되지 않습니다.
  "editor.unicodeHighlight.allowedLocales": {
    "_os": true,
    "_vscode": true
  },

  // 현재 사용자 로캘에서 공통되는 문자를 제외한 기본 ASCII 문자와 혼동할 수 있는 문자를 강조 표시할지 여부를 제어합니다.
  "editor.unicodeHighlight.ambiguousCharacters": true,

  // 주석의 문자에도 유니코드 강조 표시를 적용해야 하는지 여부를 제어합니다.
  "editor.unicodeHighlight.includeComments": "inUntrustedWorkspace",

  // 문자열의 문자에도 유니코드 강조 표시를 적용해야 하는지 여부를 제어합니다.
  "editor.unicodeHighlight.includeStrings": true,

  // 공백만 예약하거나 너비가 전혀 없는 문자를 강조 표시할지 여부를 제어합니다.
  "editor.unicodeHighlight.invisibleCharacters": true,

  // 기본이 아닌 모든 ASCII 문자를 강조 표시할지 여부를 제어합니다. U+0020과 U+007E 사이의 문자, 탭, 줄 바꿈 및 캐리지 리턴만 기본 ASCII로 간주됩니다.
  "editor.unicodeHighlight.nonBasicASCII": "inUntrustedWorkspace",

  // 문제를 일으킬 수 있는 비정상적인 줄 종결자를 제거합니다.
  //  - auto: 비정상적인 줄 종결자가 자동으로 제거됩니다.
  //  - off: 비정상적인 줄 종결자가 무시됩니다.
  //  - prompt: 제거할 비정상적인 줄 종결자 프롬프트입니다.
  "editor.unusualLineTerminators": "prompt",

  // 탭 정지에 맞춰 공백과 탭이 삽입되고 삭제됩니다.
  "editor.useTabStops": true,

  // 문서의 단어를 기준으로 완성도를 계산해야 하는지 여부 및 완성도가 계산되는 문서를 기준으로 계산되는지 여부를 제어합니다.
  //  - off: 단어 기반 추천을 끕니다.
  //  - currentDocument: 활성 문서에서만 단어를 제안합니다.
  //  - matchingDocuments: 같은 언어의 모든 열린 문서에서 단어를 제안합니다.
  //  - allDocuments: 모든 열린 문서에서 단어를 제안합니다.
  "editor.wordBasedSuggestions": "matchingDocuments",

  // 중국어/일본어/한국어(CJK) 텍스트에 사용되는 단어 분리 규칙을 제어합니다.
  //  - normal: 기본 줄 바꿈 규칙을 사용합니다.
  //  - keepAll: 단어 분리는 중국어/일본어/한국어(CJK) 텍스트에 사용할 수 없습니다. CJK가 아닌 텍스트 동작은 일반 텍스트 동작과 같습니다.
  "editor.wordBreak": "normal",

  // 단어 관련 탐색 또는 작업을 수행할 때 단어 구분에 사용할 로캘입니다. 인식할 단어의 BCP 47 언어 태그를 지정합니다(예: ja, zh-CN, zh-Hant-TW 등).
  "editor.wordSegmenterLocales": [],

  // 단어 관련 탐색 또는 작업을 수행할 때 단어 구분 기호로 사용할 문자입니다.
  "editor.wordSeparators": "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?",

  // 줄 바꿈 여부를 제어합니다.
  //  - off: 줄이 바뀌지 않습니다.
  //  - on: 뷰포트 너비에서 줄이 바뀝니다.
  //  - wordWrapColumn: `editor.wordWrapColumn`에서 줄이 바뀝니다.
  //  - bounded: 뷰포트의 최소값 및 `editor.wordWrapColumn`에서 줄이 바뀝니다.
  "editor.wordWrap": "off",

  // `editor.wordWrap`이 `wordWrapColumn` 또는 'bounded'인 경우 편집기의 열 줄 바꿈을 제어합니다.
  "editor.wordWrapColumn": 80,

  // '#editor.wordWrap#'을 사용할 때 리터럴 '\n'이 wordWrap을 트리거할지 여부를 제어합니다.
  //
  // 예:
  // ```c
  // char* str="hello\nworld"
  // ```
  // 은(는) 다음과 같이 표시됩니다.
  // ```c
  // char* str="hello\n
  //            world"
  // ```
  "editor.wrapOnEscapedLineFeeds": false,

  // 줄 바꿈 행의 들여쓰기를 제어합니다.
  //  - none: 들여쓰기가 없습니다. 줄 바꿈 행이 열 1에서 시작됩니다.
  //  - same: 줄 바꿈 행의 들여쓰기가 부모와 동일합니다.
  //  - indent: 줄 바꿈 행이 부모 쪽으로 +1만큼 들여쓰기됩니다.
  //  - deepIndent: 줄 바꿈 행이 부모 쪽으로 +2만큼 들여쓰기됩니다.
  "editor.wrappingIndent": "same",

  // 래핑 지점을 계산하는 알고리즘을 제어합니다. 접근성 모드에서는 최상의 환경을 위해 고급 기능이 사용됩니다.
  //  - simple: 모든 문자가 동일한 너비라고 가정합니다. 이 알고리즘은 고정 폭 글꼴과 문자 모양의 너비가 같은 특정 스크립트(예: 라틴 문자)에 적절히 작동하는 빠른 알고리즘입니다.
  //  - advanced: 래핑 점 계산을 브라우저에 위임합니다. 이 알고리즘은 매우 느려서 대용량 파일의 경우 중단될 수 있지만 모든 경우에 적절히 작동합니다.
  "editor.wrappingStrategy": "simple",

  // 인라인 채팅에서 변경 내용에 대해 액세스 가능한 차이 뷰어도 렌더링하는지 여부입니다.
  //  - auto: 액세스 가능한 차이 뷰어는 사용 중인 화면 읽기 프로그램 모드를 기반으로 합니다.
  //  - on: 액세스 가능한 diff 뷰어는 항상 사용하도록 설정됩니다.
  //  - off: 액세스 가능한 diff 뷰어는 사용하도록 설정되지 않습니다.
  "inlineChat.accessibleDiffView": "auto",

  // 인라인 채팅의 다음 버전을 사용할지 여부입니다.
  "inlineChat.enableV2": false,

  // 변경된 지역 외부에서 입력할 때 인라인 채팅 세션을 완료할지 여부입니다.
  "inlineChat.finishOnType": false,

  // 요청 후 인라인 채팅 위젯을 숨길지 여부입니다. 활성화하면 요청이 이루어진 후 위젯이 숨겨지고 대신 채팅 오버레이가 표시됩니다. 위젯을 숨기면 인라인 채팅 키 바인딩 또는 채팅 오버레이 위젯에서 언제든지 다시 표시할 수 있습니다. *참고* 이 설정을 사용하려면 '#inlineChat.enableV2#'을 활성화해야 합니다.
  "inlineChat.hideOnRequest": false,

  // 인라인 채팅 키 바인딩을 보유하면 음성 인식이 자동으로 활성화되는지 여부입니다.
  "inlineChat.holdToSpeech": true,

  // 빈 줄에 인라인 채팅을 사용하여 코드를 생성하는 힌트가 표시되는지 여부입니다.
  "inlineChat.lineEmptyHint": false,

  // 자연어 또는 의사 코드가 사용하는 줄에 인라인 채팅을 계속하기 위한 힌트를 표시할지 여부입니다. instance 경우 '이름과 취미가 있는 수업 사람'은 채팅을 계속하기 위한 힌트를 표시합니다.
  "inlineChat.lineNaturalLanguageHint": true,

  // 전자 필기장의 인라인 채팅 위젯에 에이전트와 유사한 동작을 활성화합니다. 사용 중인 '#inlineChat.enableV2#' 설정에 따라 달라집니다.
  "inlineChat.notebookAgent": false,

  // 저장할 때 전자 필기장에 대해 일련의 코드 작업을 실행합니다. 코드 작업을 지정해야 하며 편집기를 종료하면 안 됩니다. `files.autoSave`이(가) 'afterDelay'로 설정된 경우 코드 작업은 파일이 명시적으로 저장될 때만 실행됩니다. 예: `"notebook.source.organizeImports": "explicit"`
  "notebook.codeActionsOnSave": {},

  // 사용자 확인 없이 허용할 UNC 호스트 이름 집합('192.168.0.1' 또는 'my-server'와 같이 백슬래시 앞이나 뒤에 붙지 않음)입니다. 이 설정을 통해 허용되지 않거나 사용자 확인을 통해 승인되지 않은 UNC 호스트에 액세스하는 경우 오류가 발생하며 작업이 중지됩니다. 이 설정을 변경하려면 다시 시작해야 합니다. https://aka.ms/vscode-windows-unc에서 이 설정에 대해 자세히 알아보세요.
  "security.allowedUNCHosts": [],

  // 사용하도록 설정하면 로컬 파일 또는 작업 영역이 프로토콜 처리기를 통해 열려고 할 때마다 대화 상자에서 확인을 요청합니다.
  "security.promptForLocalFileProtocolHandling": true,

  // 사용하도록 설정하면 원격 파일 또는 작업 영역이 프로토콜 처리기를 통해 열려고 할 때마다 대화 상자에서 확인을 요청합니다.
  "security.promptForRemoteFileProtocolHandling": true,

  // 활성화된 경우 `security.allowedUNCHosts` 설정 또는 사용자 확인 후에 허용된 UNC 호스트 이름에 대한 액세스만 허용합니다. https://aka.ms/vscode-windows-unc에서 이 설정에 대해 자세히 알아보세요.
  "security.restrictUNCAccess": true,

  // 제한된 모드 배너가 표시되는 시기를 제어합니다.
  //  - always: 신뢰할 수 없는 작업 영역이 열릴 때마다 배너를 표시합니다.
  //  - untilDismissed: 해제될 때까지 신뢰할 수 없는 작업 영역을 열 때 배너를 표시합니다.
  //  - never: 신뢰할 수 없는 작업 영역이 열려 있는 경우 배너를 표시하지 않습니다.
  "security.workspace.trust.banner": "untilDismissed",

  // 빈 창이 기본적으로 VS Code 내에서 신뢰할 수 있는지 여부를 제어합니다. '#security.workspace.trust.untrustedFiles#’와(과) 함께 사용하는 경우 빈 창에서 메시지를 표시하지 않고 VS Code 전체 기능을 사용하도록 설정할 수 있습니다.
  "security.workspace.trust.emptyWindow": true,

  // VS Code 내에서 작업 영역 신뢰를 사용할지를 제어합니다.
  "security.workspace.trust.enabled": true,

  // 작업 영역을 신뢰하라는 시작 프롬프트가 표시되는 시기를 제어합니다.
  //  - always: 신뢰할 수 없는 작업 영역이 열릴 때마다 신뢰를 요청합니다.
  //  - once: 신뢰할 수 없는 작업 영역을 처음 열 때 신뢰를 요청합니다.
  //  - never: 신뢰할 수 없는 작업 영역이 열릴 때 신뢰를 요청하지 마세요.
  "security.workspace.trust.startupPrompt": "once",

  // 신뢰할 수 있는 작업 영역에서 신뢰할 수 없는 파일 열기를 처리하는 방법을 제어합니다. 이 설정은`security.workspace.trust.emptyWindow`을 통해 신뢰할 수 있는 빈 창에서 파일을 여는 작업에도 적용됩니다.
  //  - prompt: 각 작업 영역에 대해 신뢰할 수 없는 파일을 처리하는 방법을 묻습니다. 신뢰할 수 없는 파일이 신뢰할 수 있는 작업 영역에 도입되면 다시 메시지가 표시되지 않습니다.
  //  - open: 항상 신뢰할 수 없는 파일을 프롬프트 없이 신뢰할 수 있는 작업 영역에 도입할 수 있도록 허용합니다.
  //  - newWindow: 항상 메시지를 표시하지 않고 제한된 모드에서 별도의 창에서 신뢰할 수 없는 파일을 엽니다.
  "security.workspace.trust.untrustedFiles": "prompt",

  // 포커스가 없는 편집기와 터미널을 흐리게 처리하여 입력한 입력이 어디로 이동하는지 더 명확하게 표시할지 여부입니다. 이 기능은 노트북이나 확장 웹뷰 편집기처럼 iframe을 사용하는 편집기를 제외한 대부분의 편집기에서 작동합니다.
  "accessibility.dimUnfocused.enabled": false,

  // 포커스가 없는 편집기와 터미널에 사용할 불투명도 비율(0.2~1.0)입니다. 이는 `accessibility.dimUnfocused.enabled`이(가) 활성화된 경우에만 적용됩니다.
  "accessibility.dimUnfocused.opacity": 0.75,

  // 액세스 가능 보기를 숨길지 여부를 제어합니다.
  "accessibility.hideAccessibleView": false,

  // 편집기 탭의 높이를 제어합니다. `workbench.editor.showTabs`(이)가 `multiple`(으)로 설정되지 않은 경우에도 제목 컨트롤 표시줄에 적용됩니다.
  "window.density.editorTabHeight": "default",

  // Workbench에서 작업 표시줄 아이콘을 클릭하는 동작을 제어합니다. 이 값은 `workbench.activityBar.location`(이)가 `default`(으)로 설정되지 않은 경우 무시됩니다.
  //  - toggle: 클릭한 항목이 이미 표시된 경우 기본 사이드바를 숨깁니다.
  //  - focus: 클릭한 항목이 이미 표시된 경우 기본 사이드바에 초점을 맞춥니다.
  "workbench.activityBar.iconClickBehavior": "toggle",

  // 기본 및 보조 사이드바를 기준으로 작업 표시줄의 위치를 제어합니다.
  //  - default: 기본 사이드바의 측면과 보조 사이드바 위에 작업 막대를 표시합니다.
  //  - top: 기본 및 보조 사이드바 위에 작업 막대를 표시합니다.
  //  - bottom: 기본 및 보조 사이드바 아래쪽에 작업 막대를 표시합니다.
  //  - hidden: 기본 및 보조 사이드바에서 작업 표시줄을 숨깁니다.
  "workbench.activityBar.location": "default",

  // 현재 작업 영역에 대해 클라우드에 저장된 사용 가능한 작업 변경 내용을 자동으로 계속할지 여부를 제어합니다.
  //  - onReload: 창을 다시 로드할 때 클라우드에서 사용 가능한 작업 변경 내용을 자동으로 계속합니다.
  //  - off: 클라우드에서 작업 변경 내용을 계속하려고 시도하지 마세요.
  "workbench.cloudChanges.autoResume": "onReload",

  // 계속 작업을 사용할 때 사용자에게 작업 변경 내용을 클라우드에 저장하라는 메시지를 표시할지 여부를 제어합니다.
  //  - prompt: 계속 작업을 사용하여 클라우드에 작업 변경 내용을 저장하기 위해 로그인하라는 메시지를 사용자에게 표시합니다.
  //  - off: 사용자가 클라우드 변경 내용을 이미 설정한 경우를 제외하고는 작업 변경을 클라우드에 저장하지 마세요.
  "workbench.cloudChanges.continueOn": "prompt",

  // 현재 선택한 색 테마에서 색을 재정의합니다.
  "workbench.colorCustomizations": {},

  // `window.autoDetectColorScheme`이(가) 활성화되지 않으면 워크벤치에서 사용되는 색 테마로 지정합니다.
  "workbench.colorTheme": "Default Dark Modern",

  // 명령 팔레트에서 채팅 질문을 해야 하는 위치를 제어합니다.
  //  - chatView: 채팅 보기에서 채팅 질문을 하세요.
  //  - quickChat: 빠른 채팅에서 채팅 질문을 하세요.
  "workbench.commandPalette.experimental.askChatLocation": "chatView",

  // 명령 팔레트에 유사한 명령을 포함할지 여부를 제어합니다. 자연어 지원을 제공하는 확장이 설치되어 있어야 합니다.
  "workbench.commandPalette.experimental.enableNaturalLanguageSearch": true,

  // 명령 팔레트에 일반적으로 사용되는 명령 목록이 있어야 하는지 여부를 제어합니다.
  "workbench.commandPalette.experimental.suggestCommands": false,

  // 명령 팔레트 기록을 유지하기 위해 최근 사용한 명령 개수를 제어합니다. 0으로 설정하면 명령 기록을 사용하지 않습니다.
  "workbench.commandPalette.history": 50,

  // 다음에 열 때 마지막으로 명령 팔레트에 입력한 내용을 복원할지 여부를 제어합니다.
  "workbench.commandPalette.preserveInput": false,

  // 편집기 그룹이 활성 상태가 아닌 경우에도 편집기 작업을 항상 표시할지를 제어합니다.
  "workbench.editor.alwaysShowEditorActions": false,

  // 나열된 형식 중 하나와 일치하는 편집기가 편집기 그룹에서 첫 번째로 열리고 둘 이상의 그룹이 열려 있으면, 그룹이 자동으로 잠깁니다. 잠긴 그룹은 사용자 제스처(예: 끌어서 놓기)에 의해 명시적으로 선택된 경우에만 편집기를 여는 데 사용되며 기본적으로는 사용되지 않습니다. 따라서 잠긴 그룹의 활성 편집기는 실수로 다른 편집기로 바뀔 가능성이 적습니다.
  "workbench.editor.autoLockGroups": {
    "default": false,
    "workbench.editor.chatSession": true,
    "workbench.editorinputs.searchEditorInput": false,
    "workbench.editor.processExplorer": true,
    "notebookOutputEditor": false,
    "jupyter-notebook": false,
    "repl": false,
    "workbench.editors.gettingStartedInput": false,
    "terminalEditor": true,
    "imagePreview.previewEditor": false,
    "vscode.audioPreview": false,
    "vscode.videoPreview": false,
    "jsProfileVisualizer.cpuprofile.table": false,
    "jsProfileVisualizer.heapprofile.table": false,
    "jsProfileVisualizer.heapsnapshot.table": false,
    "workbench.editorinputs.sidebysideEditorInput": false,
    "workbench.input.interactive": false,
    "mainThreadWebview-markdown.preview": false,
    "mainThreadWebview-simpleBrowser.view": true,
    "mainThreadWebview-browserPreview": true
  },

  // 가운데 맞춤 레이아웃에서 둘 이상의 그룹을 열 때 최대 너비에 맞게 자동으로 크기를 조정할지 여부를 제어합니다. 하나의 그룹만 열면 원래 가운데 맞춤 너비로 되돌아옵니다.
  "workbench.editor.centeredLayoutAutoResize": true,

  // 창 크기가 조정될 때 가운데 맞춤 레이아웃이 상수 너비를 유지하려고 하는지 여부를 제어합니다.
  "workbench.editor.centeredLayoutFixedWidth": false,

  // 그룹의 마지막 탭을 닫을 때 빈 편집기 그룹의 동작을 제어합니다. 사용하도록 설정하면 그룹이 자동으로 닫히고 사용하지 않도록 설정하면 빈 그룹이 그리드의 일부로 남습니다.
  "workbench.editor.closeEmptyGroups": true,

  // 세션 동안 열린 파일을 표시하는 편집기가 다른 프로세스에서 삭제하거나 이름을 바꾸는 경우 자동으로 닫혀야 하는지 여부를 제어합니다. 이 기능을 사용하지 않으면 해당 이벤트에서 편집기가 계속 열려 있습니다. 애플리케이션 내에서 삭제하는 경우 항상 편집기를 닫으며 저장되지 않은 변경 내용이 있는 편집기는 데이터가 보존되도록 닫히지 않습니다.
  "workbench.editor.closeOnFileDelete": false,

  // 사용자 지정 워크벤치 편집기 레이블을 적용할지 여부를 제어합니다.
  "workbench.editor.customLabels.enabled": true,

  // 편집기 레이블의 렌더링을 제어합니다. 각 __Item__은 파일 경로와 일치하는 패턴입니다. 상대 및 절대 파일 경로가 모두 지원됩니다. 상대 경로에는 WORKSPACE_FOLDER가 포함되어야 합니다(예: `WORKSPACE_FOLDER/src/**.tsx` or `*/src/**.tsx`). 절대 패턴은 `/`로 시작해야 합니다. 여러 패턴이 일치하는 경우 최대 길이 일치 경로가 선택됩니다. 각 __Value__는 __Item__이 일치할 때 렌더링된 편집기의 템플릿입니다. 변수는 컨텍스트에 따라 대체됩니다.
  // - `${dirname}`: 파일이 있는 폴더의 이름입니다(예: `WORKSPACE_FOLDER/folder/file.txt -> folder`).
  // - `${dirname(N)}`: 파일이 있는 n번째 상위 폴더의 이름입니다(예: `N=2: WORKSPACE_FOLDER/static/folder/file.txt -> WORKSPACE_FOLDER`). 음수를 사용하여 경로의 시작 부분에서 폴더를 선택할 수 있습니다(예: `N=-1: WORKSPACE_FOLDER/folder/file.txt -> WORKSPACE_FOLDER`). __Item__이 절대 패턴 경로인 경우 첫 번째 폴더(`N=-1`)는 절대 경로의 첫 번째 폴더를 가리키고, 그렇지 않으면 작업 영역 폴더에 해당합니다.
  // - `${filename}`: 파일 확장명을 제외한 파일의 이름입니다(예: `WORKSPACE_FOLDER/folder/file.txt -> file`).
  // - `${extname}`: 파일 확장명입니다(예: `WORKSPACE_FOLDER/folder/file.txt -> txt`).
  // - '${extname(N)}': '.'로 구분된 파일의 n번째 확장명입니다(예: 'N=2: WORKSPACE_FOLDER/folder/file.ext1.ext2.ext3 -> ext1'). 음수를 사용하여 확장명의 시작 부분에서 확장명을 선택할 수 있습니다(예: `N=-1: WORKSPACE_FOLDER/folder/file.ext1.ext2.ext3 -> ext2`).
  //
  // 예: `"**/static/**/*.html": "${filename} - ${dirname} (${extname})"`은 `WORKSPACE_FOLDER/static/folder/file.html` 파일을 `file - folder (html)`로 렌더링합니다.
  "workbench.editor.customLabels.patterns": {},

  // 편집기 파일 장식에 배지를 사용할지 여부를 제어합니다.
  "workbench.editor.decorations.badges": true,

  // 편집기 파일 장식에 색을 사용할지 여부를 제어합니다.
  "workbench.editor.decorations.colors": true,

  // 이진 파일로 검색된 파일의 기본 편집기입니다. 정의되지 않은 경우 사용자에게 선택기가 표시됩니다.
  "workbench.editor.defaultBinaryEditor": "",

  // 탭을 두 번 클릭할 때 편집기 그룹의 크기를 조정하는 방법을 제어합니다. 이 값은 `workbench.editor.showTabs`(이)가 `multiple`(으)로 설정되지 않은 경우 무시됩니다.
  //  - maximize: 다른 모든 편집기 그룹은 숨겨지고 현재 편집기 그룹은 전체 편집기 영역을 차지하도록 최대화됩니다.
  //  - expand: 편집기 그룹은 다른 모든 편집기 그룹을 가능한 한 작게 만들어 최대한 많은 공간을 차지합니다.
  //  - off: 탭을 두 번 클릭하면 편집기 그룹의 크기가 조정되지 않습니다.
  "workbench.editor.doubleClickTabToToggleEditorGroupSizes": "expand",

  // 편집기를 창 밖으로 끌어서 새 창에서 열 수 있는지를 제어합니다. 이를 동적으로 전환하려면 끄는 동안 `Alt` 키를 길게 누르세요.
  "workbench.editor.dragToOpenWindow": true,

  // 편집기 작업이 표시되는 위치를 제어합니다.
  //  - default: `workbench.editor.showTabs`(이)가 `none`(으)로 설정된 경우 창 제목 표시줄에 편집기 작업을 표시합니다. 그렇지 않으면 편집기 탭 표시줄에 편집기 작업이 표시됩니다.
  //  - titleBar: 창 제목 표시줄에 편집기 작업을 표시합니다. `window.customTitleBarVisibility`(이)가 `never`(으)로 설정되면 편집기 작업이 숨겨집니다.
  //  - hidden: 편집기 작업이 표시되지 않습니다.
  "workbench.editor.editorActionsLocation": "default",

  // 비어 있는 편집기 텍스트 힌트가 편집기에 표시되어야 하는지 여부를 제어합니다.
  "workbench.editor.empty.hint": "text",

  // 편집기를 열 때 미리보기 모드를 사용할지 여부를 제어합니다. 편집기 그룹당 최대 하나의 미리 보기 모드 편집기가 있습니다. 이 편집기는 탭 또는 제목 레이블과 편집기 열기 보기에서 파일 이름을 기울임꼴로 표시합니다. 해당 콘텐츠는 미리보기 모드에서 열린 다음 편집기로 대체됩니다. 미리보기 모드 편집기에서 변경하면 레이블을 두 번 클릭하거나 레이블 컨텍스트 메뉴의 '열린 상태 유지' 옵션과 마찬가지로 변경 내용이 유지됩니다. 탐색기에서 파일을 두 번 클릭하여 열면 편집기가 즉시 유지됩니다.
  "workbench.editor.enablePreview": true,

  // 편집기에서 코드 탐색을 시작하는 경우 편집기가 미리 보기에 남아 있을지를 제어합니다. 미리 보기 편집기는 열린 상태로 유지되지 않으며 명시적으로 열린 상태로 유지되도록 설정할 때까지(더블 클릭 또는 편집을 통해) 재사용됩니다. 이 값은 `workbench.editor.showTabs`(이)가 `multiple`(으)로 설정되지 않은 경우 무시됩니다.
  "workbench.editor.enablePreviewFromCodeNavigation": false,

  // Quick Open에서 연 편집기를 미리 보기 편집기로 표시할지를 제어합니다. 미리 보기 편집기는 열린 상태로 유지되지 않으며 명시적으로 열린 상태로 유지되도록 설정할 때까지(더블 클릭 또는 편집을 통해) 재사용됩니다. 활성화된 경우 선택하기 전에 Ctrl 키를 눌러 편집기를 미리 보기가 아닌 상태로 엽니다. 이 값은 `workbench.editor.showTabs`(이)가 `multiple`(으)로 설정되지 않은 경우 무시됩니다.
  "workbench.editor.enablePreviewFromQuickOpen": false,

  // 편집기를 최근에 사용한 순서대로 닫을 것인지 왼쪽에서 오른쪽으로 닫을 것인지를 제어합니다.
  "workbench.editor.focusRecentEditorAfterClose": true,

  // 저장하지 않은 변경 내용이 있는 편집기의 탭에 위쪽 테두리를 그릴지 여부를 제어합니다. 이 값은 `workbench.editor.showTabs`(이)가 multiple(으)로 설정되지 않은 경우 무시됩니다.
  "workbench.editor.highlightModifiedTabs": false,

  // 언어 감지에서 편집기 기록을 사용할 수 있습니다. 이것은 자동 언어 감지가 최근에 열린 언어를 선호하게 하고 자동 언어 감지가 더 작은 입력으로 작동하도록 합니다.
  "workbench.editor.historyBasedLanguageDetection": true,

  // 편집기 레이블의 형식을 제어합니다.
  //  - default: 파일 이름을 표시합니다. 탭이 사용하도록 설정되어 있고 하나의 그룹에서 파일 2개의 이름이 동일하면, 각 파일 경로의 고유한 섹션이 추가됩니다. 탭이 사용하도록 설정되어 있지 않으면, 작업 영역 폴더에 대한 경로는 편집기가 활성 상태일 때 표시됩니다.
  //  - short: 파일 이름과 파일의 디렉터리 이름을 차례로 표시합니다.
  //  - medium: 파일 이름과 작업 영역 폴더에 상대적인 파일 경로를 차례로 표시합니다.
  //  - long: 파일 이름과 절대 경로를 차례로 표시합니다.
  "workbench.editor.labelFormat": "default",

  // 설정에서 언어를 명확히 설정하지 않은 경우, 텍스트 편집기의 언어가 자동으로 감지할 지를 설정합니다. 또한 이 기능은 언어별로 범위를 지정할 수 있으므로 이 기능을 끄고 싶지 않은 언어들을 지정할 수도 있습니다. 이 기능은 다른 프로그래밍 언어를 포함하는 Markdown과 같은 언어에 유용합니다. Markdown이 아닌 임베디드 언어라고 인식하게 해 언어 감지를 피하게 할 수 있게 합니다.
  "workbench.editor.languageDetection": true,

  // 사용하도록 설정하면 편집기 언어가 감지된 콘텐츠 언어와 일치하지 않을 때 상태 표시줄 빠른 수정을 표시합니다.
  "workbench.editor.languageDetectionHints": {
    "untitledEditors": true,
    "notebookEditors": true
  },

  // 열린 편집기의 수를 제한할지 여부를 제어합니다. 사용하도록 설정하면 편집기를 새로 열기 위한 공간을 만들기 위해 가장 오래 전에 사용한 편집기가 닫힙니다.
  "workbench.editor.limit.enabled": false,

  // 열려 있는 최대 편집기 수가 구성된 한도를 계산하기 위해 더티 편집기를 제외해야 하는지를 제어합니다.
  "workbench.editor.limit.excludeDirty": false,

  // 열린 편집기의 최대 수 제한을 편집기 그룹별로 적용할지 또는 모든 편집기 그룹에 적용할지를 제어합니다.
  "workbench.editor.limit.perEditorGroup": false,

  // 열려 있는 편집기의 최대 수를 제어합니다. `workbench.editor.limit.perEditorGroup` 설정을 사용하여 편집기 그룹 또는 모든 그룹에서 이 제한을 제어합니다.
  "workbench.editor.limit.value": 10,

  // '돌아가기' 및 '앞으로 이동' 명령에 마우스 단추 4와 5를 사용할 수 있습니다.
  "workbench.editor.mouseBackForwardToNavigate": true,

  // '돌아가기' 및 '앞으로 이동'과 같은 명령에 대해 편집기에서 기록 탐색 범위를 제어합니다.
  //  - default: 열려 있는 모든 편집기 및 편집기 그룹을 탐색합니다.
  //  - editorGroup: 활성 편집기 그룹의 편집기에서만 탐색합니다.
  //  - editor: 활성 편집기에서만 탐색합니다.
  "workbench.editor.navigationScope": "default",

  // 편집기가 열리는 위치를 제어합니다. `left` 또는 `right`(을)를 선택하여 현재 활성화된 편집기의 왼쪽 또는 오른쪽에 있는 편집기를 엽니다. `first` 또는 `last`(을)를 선택하여 현재 활성화된 편집기에서 독립적으로 편집기를 엽니다.
  "workbench.editor.openPositioning": "right",

  // 탐색기 등에서 나란히 열리는 편집기의 기본 방향을 제어합니다. 기본적으로 편집기는 현재 활성 편집기 오른쪽에 열립니다. 'down'으로 변경하는 경우 편집기가 현재 활성 편집기 아래에 열립니다. 이는 편집기 도구 모음의 분할 편집기 작업에도 영향을 줍니다.
  "workbench.editor.openSideBySideDirection": "right",

  // 고정된 편집기 탭의 크기를 제어합니다. 고정된 탭은 열려 있는 모든 탭의 시작 부분으로 정렬되며 일반적으로 고정 해제될 때까지 닫지 않습니다. 이 값은 `workbench.editor.showTabs`(이)가 `multiple`(으)로 설정되지 않은 경우 무시됩니다.
  //  - normal: 고정된 탭이 고정되지 않은 탭의 모양을 상속합니다.
  //  - compact: 고정된 탭이 아이콘 또는 편집기 이름의 첫 문자만 있는 컴팩트 형식으로 표시됩니다.
  //  - shrink: 고정된 탭이 편집기 이름의 일부를 표시하는 컴팩트 고정 크기로 축소됩니다.
  "workbench.editor.pinnedTabSizing": "normal",

  // 사용하도록 설정하면 다른 모든 탭 위에 있는 별도의 행에 고정된 탭이 표시됩니다. 이 값은 `workbench.editor.showTabs`(이)가 `multiple`(으)로 설정되지 않은 경우 무시됩니다.
  "workbench.editor.pinnedTabsOnSeparateRow": false,

  // 활성화되면 편집기 기록을 고려하는 언어 감지 모델에 더 높은 우선 순위가 부여됩니다.
  "workbench.editor.preferHistoryBasedLanguageDetection": false,

  // 키보드 또는 마우스 가운데 클릭을 사용하여 닫을 때 고정된 편집기를 닫을지 여부를 제어합니다.
  //  - keyboardAndMouse: 마우스 가운데 클릭 또는 키보드를 사용할 때 항상 고정된 편집기를 닫지 않도록 합니다.
  //  - keyboard: 키보드를 사용할 때 고정된 편집기를 닫지 않습니다.
  //  - mouse: 마우스 가운데 클릭을 사용할 때 고정된 편집기를 닫지 않습니다.
  //  - never: 고정된 편집기를 절대 닫지 않습니다.
  "workbench.editor.preventPinnedEditorClose": "keyboardAndMouse",

  // 편집기를 닫은 후 다시 열 때 마지막 편집기 보기 상태(예: 스크롤 위치)를 복원합니다. 편집기 보기 상태는 편집기 그룹별로 저장되며 그룹이 닫힐 때 삭제됩니다. 편집기 그룹에 대해 이전 보기 상태가 발견되지 않은 경우 모든 편집기 그룹에서 마지막으로 알려진 보기 상태를 사용하려면 `workbench.editor.sharedViewState` 설정을 사용하세요.
  "workbench.editor.restoreViewState": true,

  // 편집기를 여는 경우 보이는 그룹 중 하나에 표시할지를 제어합니다. 사용하지 않도록 설정하면 편집기가 기본적으로 현재 활성 편집기 그룹에 열립니다. 사용하도록 설정하면 현재 활성 편집기 그룹에서 편집기가 다시 열리지 않고 이미 열린 편집기가 표시됩니다. 강제로 편집기가 특정 그룹에서 열리거나 현재 활성 그룹 옆에 열리도록 하는 등의 일부 경우에는 이 설정이 무시됩니다.
  "workbench.editor.revealIfOpen": false,

  // 탭 위로 스크롤하여 열지 여부를 제어합니다. 기본적으로 탭은 스크롤할 때만 표시되지만 열리지는 않습니다. 스크롤하는 동안 Shift 키를 길게 눌러 해당 기간 동안 이 동작을 변경할 수 있습니다. 이 값은 `workbench.editor.showTabs`(이)가 `multiple`(으)로 설정되지 않은 경우 무시됩니다.
  "workbench.editor.scrollToSwitchTabs": false,

  // 모든 편집기 그룹에서 가장 최근의 편집기 보기 상태(예: 스크롤 위치)를 보존하고 편집기 그룹에 대한 특정 편집기 보기 상태가 없는 경우 복원합니다.
  "workbench.editor.sharedViewState": false,

  // 열린 편집기를 아이콘과 함께 표시할지 여부를 제어합니다. 이를 위해서는 파일 아이콘 테마도 사용하도록 설정해야 합니다.
  "workbench.editor.showIcons": true,

  // 열린 편집기가 개별 탭으로 표시되어야 하는지, 하나의 큰 탭으로 표시할지 또는 제목 영역을 표시하지 않아야 하는지를 제어합니다.
  //  - multiple: 각 편집기는 편집기 제목 영역에 탭으로 표시됩니다.
  //  - single: 활성 편집기는 편집기 제목 영역에 하나의 큰 탭으로 표시됩니다.
  //  - none: 편집기 제목 영역이 표시되지 않습니다.
  "workbench.editor.showTabs": "multiple",

  // 편집기가 편집기 그룹에서 세로 또는 가로로 분할될 때의 레이아웃을 제어합니다.
  //  - vertical: 편집기는 위에서 아래로 배치됩니다.
  //  - horizontal: 편집기는 왼쪽에서 오른쪽으로 배치됩니다.
  "workbench.editor.splitInGroupLayout": "horizontal",

  // 편집기 영역의 가장자리에 편집기 또는 파일을 놓아 편집기 그룹을 끌어서 놓기 작업에서 분할할 수 있는지 여부를 제어합니다.
  "workbench.editor.splitOnDragAndDrop": true,

  // 편집기 그룹 분할 시 편집기 그룹 크기를 제어합니다.
  //  - auto: 모든 편집기 그룹이 이미 동일한 부분에 있지 않는 한 활성 편집기 그룹을 동일한 부분으로 분할합니다. 이 경우 모든 편집기 그룹을 동일한 부분으로 분할합니다.
  //  - distribute: 모든 편집기 그룹을 동일한 부분으로 분할합니다.
  //  - split: 활성 편집기 그룹을 동일한 부분으로 분할합니다.
  "workbench.editor.splitSizing": "auto",

  // 탭 닫기 실행 단추의 표시 여부를 제어합니다.
  "workbench.editor.tabActionCloseVisibility": true,

  // 편집기 탭 실행 단추(닫기, 고정 해제)의 위치를 제어합니다. 이 값은 `workbench.editor.showTabs`(이)가 `multiple`(으)로 설정되지 않은 경우 무시됩니다.
  "workbench.editor.tabActionLocation": "right",

  // 탭 고정 해제 실행 단추의 표시 여부를 제어합니다.
  "workbench.editor.tabActionUnpinVisibility": true,

  // 편집기 탭의 크기를 제어합니다. 이 값은 `workbench.editor.showTabs`(이)가 `multiple`(으)로 설정되지 않은 경우 무시됩니다.
  //  - fit: 항상 전체 편집기 레이블을 표시할 만큼 큰 탭을 유지합니다.
  //  - shrink: 한 번에 모든 탭을 표시할 만큼 사용 가능한 공간이 없는 경우 탭을 작게 만들 수 있습니다.
  //  - fixed: 모든 탭을 같은 크기로 만듭니다. 사용 가능한 공간이 부족하여 모든 탭을 한 번에 표시할 수 없을 때는 탭의 크기를 작게 조정할 수 있습니다.
  "workbench.editor.tabSizing": "fit",

  // `workbench.editor.tabSizing`이(가) `fixed`(으)로 설정된 경우 탭의 최대 너비를 제어합니다.
  "workbench.editor.tabSizingFixedMaxWidth": 160,

  // `workbench.editor.tabSizing`이(가) `fixed`(으)로 설정된 경우 탭의 최소 너비를 제어합니다.
  "workbench.editor.tabSizingFixedMinWidth": 50,

  // 편집기 제목 영역에서 탭 및 이동 경로에 사용되는 스크롤 막대의 높이를 제어합니다.
  //  - default: 기본 크기.
  //  - large: 마우스로 더 쉽게 잡을 수 있도록 크기를 늘립니다.
  "workbench.editor.titleScrollbarSizing": "default",

  // 제목 없는 편집기의 레이블 형식을 제어합니다.
  //  - content: 제목 없는 파일의 이름은 연결된 파일 경로가 없는 경우 첫 번째 줄의 콘텐츠에서 파생됩니다. 줄이 비어 있거나 단어 문자가 없는 경우 해당 이름으로 대체됩니다.
  //  - name: 제목 없는 파일의 이름은 파일 콘텐츠에서 파생되지 않습니다.
  "workbench.editor.untitled.labelFormat": "content",

  // 사용 가능한 공간을 초과할 때 탭을 여러 줄에 래핑할지 또는 스크롤 막대를 대신 표시할지 여부를 제어합니다. 이 값은 `workbench.editor.showTabs`(이)가 ‘`multiple`’로 설정되지 않은 경우 무시됩니다.
  "workbench.editor.wrapTabs": false,

  // [GLOB 패턴](https://aka.ms/vscode-glob-patterns)을 편집기로 구성합니다(예: `"*.hex": "hexEditor.hexedit"`). 이러한 동작은 기본 동작보다 우선합니다.
  "workbench.editorAssociations": {},

  // 편집기에서 열 때 확인을 요청하기 전에 파일의 최소 크기(MB)를 제어합니다. 이 설정은 일부 편집기 유형 및 환경에는 적용되지 않을 수 있습니다.
  "workbench.editorLargeFileConfirmation": 1024,

  // Microsoft 온라인 서비스에서 실행할 실험을 가져옵니다.
  "workbench.enableExperiments": true,

  // 현재 작업 영역에 대해 사용 가능한 작업 변경 내용을 클라우드에 자동으로 저장할지 여부를 제어합니다. 이 설정은 웹에는 영향을 주지 않습니다.
  //  - onShutdown: 창을 닫을 때 현재 작업 중인 변경 내용을 클라우드에 자동으로 저장합니다.
  //  - off: 작업 변경 내용을 클라우드에 자동으로 저장하려고 시도하지 마세요.
  "workbench.experimental.cloudChanges.autoStore": "off",

  // 현재 세션과 부분적으로 일치하는 클라우드 변경 내용을 표시할지 여부를 제어합니다.
  "workbench.experimental.cloudChanges.partialMatches.enabled": false,

  // `window.commandCenter`이(가) `true`일 때 명령 센터 옆에 있는 공유 작업을 렌더링할지 여부를 제어합니다.
  "workbench.experimental.share.enabled": false,

  // 외부에서 http 또는 https 링크를 여는 데 사용할 브라우저를 구성합니다. 이는 브라우저의 이름('edge', 'chrome', 'firefox') 또는 브라우저 실행 파일의 절대 경로일 수 있습니다. 설정하지 않으면 시스템 기본값을 사용합니다.
  "workbench.externalBrowser": "",

  // 외부 URI(http, https)에 사용할 opener를 구성합니다.
  "workbench.externalUriOpeners": {},

  // workbench 항목(예: 일부 확장에서 트리 뷰 항목을 제공함)에 호버가 표시된 후 지연 시간(밀리초)을 제어합니다. 이미 표시된 항목에 이 설정 변경 내용을 적용하려면 해당 항목을 새로 고쳐야 할 수 있습니다.
  "workbench.hover.delay": 500,

  // 워크벤치에서 사용한 파일 아이콘 테마를 지정하거나, 파일 아이콘을 표시하지 않도록 'null'을 지정합니다.
  //  - null: 파일 아이콘 없음
  //  - vs-minimal
  //  - vs-seti
  "workbench.iconTheme": "vs-seti",

  // 레이아웃 컨트롤을 사용자 지정 제목 표시줄에 표시할지 여부를 제어합니다. 이 설정은`window.customTitleBarVisibility`이(가) `never`(으)로 설정되지 않은 경우에만 적용됩니다.
  "workbench.layoutControl.enabled": true,

  // 사용자 지정 제목 표시줄의 레이아웃 컨트롤이 단일 메뉴 버튼으로 표시되는지 또는 여러 UI 토글과 함께 표시되는지 제어합니다.
  //  - menu: 레이아웃 옵션의 드롭다운이 있는 단일 버튼을 표시합니다.
  //  - toggles: 패널과 사이드 바의 표시 유형을 전환하기 위한 여러 버튼을 표시합니다.
  //  - both: 드롭다운 및 토글 버튼을 모두 표시합니다.
  "workbench.layoutControl.type": "both",

  // 워크벤치에서 목록 및 트리를 검색할 때 사용하는 일치 유형을 제어합니다.
  //  - fuzzy: 검색할 때 유사 항목 일치를 사용합니다.
  //  - contiguous: 검색할 때 연속 일치를 사용합니다.
  "workbench.list.defaultFindMatchType": "fuzzy",

  // 워크벤치에서 목록 및 트리의 기본 찾기 모드를 제어합니다.
  //  - highlight: 검색할 때 요소를 강조 표시합니다. 추가 위아래 탐색은 강조 표시된 요소만 탐색합니다.
  //  - filter: 검색할 때 요소를 필터링합니다.
  "workbench.list.defaultFindMode": "highlight",

  // 'Alt' 키를 누를 때 스크롤 속도 승수입니다.
  "workbench.list.fastScrollSensitivity": 5,

  // 워크벤치에서 목록 및 트리의 가로 스크롤 여부를 제어합니다. 경고: 이 설정을 켜면 성능에 영향을 미칩니다.
  "workbench.list.horizontalScrolling": false,

  // 대신 'workbench.list.defaultFindMode' 및 'workbench.list.typeNavigationMode'를 사용하세요.
  // 워크벤치의 목록 및 트리 키보드 탐색 스타일을 제어합니다. 간소화하고, 강조 표시하고, 필터링할 수 있습니다.
  //  - simple: 간단한 키보드 탐색에서는 키보드 입력과 일치하는 요소에 집중합니다. 일치는 접두사에서만 수행됩니다.
  //  - highlight: 키보드 탐색 강조 표시에서는 키보드 입력과 일치하는 요소를 강조 표시합니다. 이후로 탐색에서 위 및 아래로 이동하는 경우 강조 표시된 요소만 트래버스합니다.
  //  - filter: 키보드 탐색 필터링에서는 키보드 입력과 일치하지 않는 요소를 모두 필터링하여 숨깁니다.
  "workbench.list.keyboardNavigation": "highlight",

  // 마우스 휠 스크롤 이벤트의 `deltaX` 및 `deltaY`에서 사용할 승수입니다.
  "workbench.list.mouseWheelScrollSensitivity": 1,

  // 마우스로 트리와 목록의 항목을 다중 선택에 추가할 때 사용할 한정자입니다(예를 들어 탐색기에서 편집기와 SCM 보기를 여는 경우). '옆에서 열기' 마우스 제스처(지원되는 경우)는 다중 선택 한정자와 충돌하지 않도록 조정됩니다.
  //  - ctrlCmd: Windows와 Linux의 'Control'을 macOS의 'Command'로 매핑합니다.
  //  - alt: Windows와 Linux의 'Alt'를 macOS의 'Option'으로 매핑합니다.
  "workbench.list.multiSelectModifier": "ctrlCmd",

  // 트리와 목록에서 마우스를 사용하여 항목을 여는 방법을 제어합니다(지원되는 경우). 일부 트리와 목록에서는 이 설정을 적용할 수 없는 경우 무시하도록 선택할 수 있습니다.
  "workbench.list.openMode": "singleClick",

  // 스크롤 막대 스크롤 페이지의 페이지별 클릭 여부를 제어합니다.
  "workbench.list.scrollByPage": false,

  // 목록과 트리에 부드러운 화면 이동 기능이 있는지를 제어합니다.
  "workbench.list.smoothScrolling": false,

  // 워크벤치의 목록 및 트리에서 형식 탐색이 작동하는 방식을 제어합니다. 'trigger'로 설정 시 'list.triggerTypeNavigation' 명령이 실행되면 형식 탐색이 시작됩니다.
  "workbench.list.typeNavigationMode": "automatic",

  // 로컬 파일 기록의 활성화 여부를 제어합니다. 활성화하면 저장된 편집기의 파일 내용이 백업 위치에 저장되어 나중에 내용을 복원하거나 검토할 수 있습니다. 이 설정을 변경해도 기존 로컬 파일 기록 항목에는 영향을 미치지 않습니다.
  "workbench.localHistory.enabled": true,

  // 로컬 파일 기록에서 파일을 제외할 경로 또는 [GLOB 패턴](https://aka.ms/vscode-glob-patterns)을 구성합니다. GLOB 패턴은 절대 경로가 아닌 경우 작업 영역 폴더의 경로에 따라 항상 평가됩니다. 이 설정을 변경해도 기존 로컬 파일 기록 항목에는 영향을 주지 않습니다.
  "workbench.localHistory.exclude": {},

  // 파일당 로컬 파일 기록 항목의 최대 수를 제어합니다. 로컬 파일 기록 항목 수가 파일에 대해 이 수를 초과하면 가장 오래된 항목이 삭제됩니다.
  "workbench.localHistory.maxFileEntries": 50,

  // 로컬 파일 기록에 대해 고려할 파일의 최대 크기(KB)를 제어합니다. 더 큰 파일은 로컬 파일 기록에 추가되지 않습니다. 이 설정을 변경해도 기존 로컬 파일 기록 항목에는 영향을 미치지 않습니다.
  "workbench.localHistory.maxFileSize": 256,

  // 로컬 파일 기록의 마지막 항목이 추가되는 항목으로 대체되는 간격(초)을 구성합니다. 이렇게 하면 자동 저장이 활성화된 경우와 같이 추가되는 전체 항목 수를 줄이는 데 도움이 됩니다. 이 설정은 출처가 동일한 항목에만 적용됩니다. 이 설정을 변경해도 기존 로컬 파일 기록 항목에는 영향을 미치지 않습니다.
  "workbench.localHistory.mergeWindow": 10,

  // 탐색 컨트롤이 사용자 지정 제목 표시줄에 표시되는지 여부를 제어합니다. 이 설정은`window.customTitleBarVisibility`이(가) `never`(으)로 설정되지 않은 경우에만 적용됩니다.
  "workbench.navigationControl.enabled": true,

  // 새 작업 영역에서 패널의 기본 위치(터미널, 디버그 콘솔, 출력, 문제)를 제어합니다. 편집기 영역의 아래쪽, 위쪽, 오른쪽 또는 왼쪽에 표시될 수 있습니다.
  "workbench.panel.defaultLocation": "bottom",

  // 패널이 최대화되어 열리는지 여부를 제어합니다. 항상 최대화되어 열리거나, 최대화되어 열리지 않거나, 닫기 전 상태였던 마지막 상태로 열 수 있습니다.
  //  - always: 패널을 열 때 항상 패널을 최대화합니다.
  //  - never: 패널을 열 때 최대화하지 마세요.
  //  - preserve: 패널을 닫기 전 상태로 엽니다.
  "workbench.panel.opensMaximized": "preserve",

  // 패널 제목의 활동 항목이 레이블 또는 아이콘으로 표시되는지 여부를 제어합니다.
  "workbench.panel.showLabels": true,

  // 시스템 색 모드가 다크 모드이며 `window.autoDetectColorScheme`이(가) 활성화된 경우 색 테마를 지정합니다.
  "workbench.preferredDarkColorTheme": "Default Dark Modern",

  // 고대비 다크 모드이며 `window.autoDetectHighContrast`이(가) 활성화된 경우 색 테마를 지정합니다.
  "workbench.preferredHighContrastColorTheme": "Default High Contrast",

  // 고대비 밝음 모드이며 `window.autoDetectHighContrast`이(가) 활성화된 경우 색 테마를 지정합니다.
  "workbench.preferredHighContrastLightColorTheme": "Default High Contrast Light",

  // 시스템 색 모드가 밝음 모드이며 `window.autoDetectColorScheme`이(가) 활성화된 경우 색 테마를 지정합니다.
  "workbench.preferredLightColorTheme": "Default Light Modern",

  // 사용되는 제품 아이콘 테마를 지정합니다.
  //  - Default: 기본값
  "workbench.productIconTheme": "Default",

  // Quick Open이 포커스를 잃으면 해당 Quick Open을 자동으로 닫을지 여부를 제어합니다.
  "workbench.quickOpen.closeOnFocusLost": true,

  // 다음에 열 때 마지막으로 Quick Open에 입력한 내용을 복원할지 여부를 제어합니다.
  "workbench.quickOpen.preserveInput": false,

  // 워크벤치가 더 적은 애니메이션으로 렌더링되어야 하는지 여부를 제어합니다.
  //  - on: 항상 감소된 동작으로 렌더링합니다.
  //  - off: 축소된 동작으로 렌더링 안 함
  //  - auto: OS 구성에 따라 감소된 동작으로 렌더링합니다.
  "workbench.reduceMotion": "auto",

  // 사용하도록 설정하면 원격 확장 권장 사항이 원격 표시기 메뉴에 표시됩니다.
  "workbench.remoteIndicator.showExtensionRecommendations": true,

  // 보기/편집기 간 끌기 영역의 호버 피드백 지연 시간(밀리초)을 제어합니다.
  "workbench.sash.hoverDelay": 300,

  // 보기/편집기 사이의 끌기 영역의 피드백 영역 크기를 픽셀 단위로 제어합니다. 마우스를 사용하여 보기 크기를 조정하기가 어려운 경우 더 큰 값으로 설정합니다.
  "workbench.sash.size": 4,

  // 작업 영역이나 처음 열리는 빈 창에서 보조 사이드바의 기본 표시 여부를 제어합니다.
  //  - hidden: 보조 사이드바를 기본적으로 숨깁니다.
  //  - visibleInWorkspace: 작업 영역을 열면 보조 사이드바가 기본적으로 표시됩니다.
  //  - visible: 보조 사이드바를 기본적으로 표시합니다.
  //  - maximizedInWorkspace: 작업 영역을 열면 보조 사이드바가 기본적으로 표시되고 최대화됩니다.
  //  - maximized: 보조 사이드바가 기본적으로 표시되고 최대화됩니다.
  "workbench.secondarySideBar.defaultVisibility": "visibleInWorkspace",

  // 보조 사이드바 제목의 활동 항목이 레이블 또는 아이콘으로 표시되는지 여부를 제어합니다. 이 설정은 `workbench.activityBar.location`이(가) `top`(으)로 설정되지 않은 경우에만 적용됩니다.
  "workbench.secondarySideBar.showLabels": true,

  // 모든 프로필에 적용할 설정을 구성합니다.
  "workbench.settings.applyToAllProfiles": [],

  // 기본적으로 사용할 설정 편집기를 결정합니다.
  //  - ui: 설정 UI 편집기를 사용합니다.
  //  - json: JSON 파일 편집기를 사용합니다.
  "workbench.settings.editor": "ui",

  // 설정에 대한 자연어 검색 모드를 사용할지 여부를 제어합니다. 자연어 검색은 Microsoft 온라인 서비스에 의해 제공됩니다.
  "workbench.settings.enableNaturalLanguageSearch": true,

  // 키 바인딩 설정을 열면 모든 기본 키 바인딩 설정을 표시하는 편집기도 열리는지 여부를 제어합니다.
  "workbench.settings.openDefaultKeybindings": false,

  // 설정을 열면 모든 기본 설정을 표시하는 편집기도 열리는지 여부를 제어합니다.
  "workbench.settings.openDefaultSettings": false,

  // 검색하는 동안 설정 편집기 목차의 동작을 제어합니다. 설정 편집기에서 이 설정을 변경하는 경우 검색 쿼리가 수정된 후에 설정이 적용됩니다.
  //  - hide: 검색하는 동안 목차를 숨깁니다.
  //  - filter: 일치하는 설정이 있는 범주로 목차를 필터링합니다. 범주를 클릭하면 해당 범주로 결과가 필터링됩니다.
  "workbench.settings.settingsSearchTocBehavior": "filter",

  // 검색을 수행한 후 AI 검색 결과를 사용할 수 있게 되면 설정 편집기의 검색 창에 AI 검색 결과 토글을 표시할지 여부를 제어합니다.
  "workbench.settings.showAISearchToggle": false,

  // JSON으로 설정을 편집할 때 분할 JSON 편집기를 사용할지 여부를 제어합니다.
  "workbench.settings.useSplitJSON": false,

  // 기본 사이드바 및 활동 표시줄의 위치를 제어합니다. 워크벤치의 왼쪽이나 오른쪽에 표시할 수 있습니다. 보조 사이드 바는 작업대의 반대쪽에 표시됩니다.
  "workbench.sideBar.location": "left",

  // 이전 세션에서 복원된 편집기가 없는 경우 시작 시 편집기의 표시 여부를 제어합니다.
  //  - none: 편집기를 사용하지 않고 시작합니다.
  //  - welcomePage: VS Code 및 확장을 시작하는 데 도움이 되는 콘텐츠가 포함된 시작 페이지를 엽니다.
  //  - readme: 폴더가 포함된 폴더를 열 때 README를 열고, 그렇지 않으면 'welcomePage'로 대체합니다. 참고: 이 항목은 전역 ccnfiguration으로만 관찰되며, 작업 영역 또는 폴더 구성에 설정된 경우 무시됩니다.
  //  - newUntitledFile: 제목 없는 새 텍스트 파일을 엽니다(빈 창을 열 때만 적용됨).
  //  - welcomePageInEmptyWorkbench: 빈 워크벤치를 열 때 시작 페이지를 엽니다.
  //  - terminal: 편집기 영역에서 새 터미널을 엽니다.
  "workbench.startupEditor": "welcomePage",

  // 워크벤치 아래쪽에서 상태 표시줄의 표시 유형을 제어합니다.
  "workbench.statusBar.visible": true,

  // 사용하도록 설정되면 편집기가 열리지 않았을 때 워터마크 팁이 표시됩니다.
  "workbench.tips.enabled": true,

  // 트리에서 고정 스크롤을 사용할지 여부를 제어합니다.
  "workbench.tree.enableStickyScroll": true,

  // 폴더 이름을 클릭할 때 트리 폴더가 확장되는 방법을 제어합니다. 일부 트리와 목록에서는 이 설정을 적용할 수 없는 경우 무시하도록 선택할 수 있습니다.
  "workbench.tree.expandMode": "singleClick",

  // 트리 들여쓰기를 픽셀 단위로 제어합니다.
  "workbench.tree.indent": 8,

  // 트리에서 들여쓰기 가이드를 렌더링할지 여부를 제어합니다.
  "workbench.tree.renderIndentGuides": "onHover",

  // `workbench.tree.enableStickyScroll`을(를) 사용하도록 설정한 경우 트리에 표시되는 고정 요소의 수를 제어합니다.
  "workbench.tree.stickyScrollMaxItemCount": 7,

  // 사용하도록 설정하면 신뢰할 수 있는 작업 영역에서 링크를 열 때 트러스트된 도메인 프롬프트가 표시됩니다.
  "workbench.trustedDomains.promptInTrustedWorkspace": false,

  // 보기 머리글 작업의 표시 여부를 제어합니다. 보기 머리글 작업은 항상 표시할 수도 있고 보기에 포커스가 있거나 보기를 마우스로 가리킬 때만 표시할 수도 있습니다.
  "workbench.view.alwaysShowHeaderActions": false,

  // 확장에서 숨겨진 보기를 표시하도록 요청하는 경우 클릭 가능한 상태 표시줄 표시기를 대신 표시합니다.
  "workbench.view.showQuietly": {},

  // 사용되지 않습니다. 전역 'workbench.reduceMotion'을 사용합니다.
  // 사용하도록 설정하면 시작 페이지에서 동작을 줄입니다.
  "workbench.welcomePage.preferReducedMotion": false,

  // 사용하도록 설정하면 확장 프로그램을 설치할 때 확장 프로그램의 단계별 설명이 열립니다.
  "workbench.welcomePage.walkthroughs.openOnInstall": true,

  // 사용하도록 설정하면 시스템 색 모드에 따라 색 테마가 자동으로 선택됩니다. 시스템 색 모드가 다크 모드이면 `workbench.preferredDarkColorTheme#`을(를) 사용하며, 그렇지 않으면 `#workbench.preferredLightColorTheme`을(를) 사용합니다.
  "window.autoDetectColorScheme": false,

  // 사용하도록 설정하면 OS가 고대비 테마를 사용하는 경우 고대비 테마로 자동 변경됩니다. 사용할 고대비 테마는 `workbench.preferredHighContrastColorTheme#` 및 `#workbench.preferredHighContrastLightColorTheme`(으)로 지정됩니다.
  "window.autoDetectHighContrast": true,

  // 창의 테두리 색을 제어합니다. Windows 설정을 적용하려면 `default`로 설정하고, 비활성화하려면 `off`로 설정하거나 16진수, RGB, RGBA, HSL, HSLA 형식의 특정 색으로 설정하세요. 이렇게 하려면 Windows에서 '제목 표시줄 및 창 테두리에 테마 컬러 표시'를 사용하도록 설정해야 하며 `window.titleBarStyle`이(가) `native`(으)로 설정된 경우 무시됩니다.
  "window.border": "default",

  // 마지막 편집기를 닫을 때 창도 닫을지 여부를 제어합니다. 이 설정은 폴더를 표시하지 않는 창에만 적용됩니다.
  "window.closeWhenEmpty": false,

  // 창 제목과 함께 명령 시작 관리자를 표시합니다. 이 설정은`window.customTitleBarVisibility`이(가) `never`(으)로 설정되지 않은 경우에만 적용됩니다.
  "window.commandCenter": true,

  // 창을 닫거나 애플리케이션을 종료하기 전에 확인 대화 상자를 표시할지 여부를 제어합니다.
  //  - always: 항상 확인을 요청합니다.
  //  - keyboardOnly: 키 바인딩이 사용된 경우에만 확인을 요청합니다.
  //  - never: 확인을 명시적으로 요청하지 마세요.
  "window.confirmBeforeClose": "never",

  // 다른 작업 영역으로 전환할 때 창에 열려 있는 제목 없는 작업 영역을 저장할지 삭제할지 묻는 확인 대화 상자를 표시할지 여부를 제어합니다. 확인 대화 상자를 사용하지 않도록 설정하면 제목 없는 작업 영역이 항상 삭제됩니다.
  "window.confirmSaveUntitledWorkspace": true,

  // OS에 맞게 창 컨트롤의 모양을 네이티브로 조정합니다(사용자 지정 그림 또는 숨김). 변경 내용을 적용하려면 완전히 다시 시작해야 합니다.
  "window.controlsStyle": "native",

  // <Alt> 키를 눌러 메뉴 모음이 포커스되는지 여부를 제어합니다. 이 설정은 <Alt> 키로 메뉴 모음을 토글하는 데는 영향을 주지 않습니다.
  "window.customMenuBarAltFocus": true,

  // 사용자 지정 제목 표시줄을 표시할 시기를 조정합니다. `windowed`를 사용하여 전체 화면 모드에 있을 때 사용자 지정 제목 표시줄을 숨길 수 있습니다. `window.titleBarStyle`이(가) `native`로 설정된 경우 `never`를 사용해야만 전체 화면이 아닌 모드에서 사용자 지정 제목 표시줄을 숨길 수 있습니다.
  //  - auto: 사용자 지정 제목 표시줄 표시 여부를 자동으로 변경합니다.
  //  - windowed: 전체 화면에서 사용자 지정 제목 표시줄을 숨깁니다. 전체 화면이 아닌 경우 사용자 지정 제목 표시줄 표시 여부를 자동으로 변경합니다.
  //  - never: `window.titleBarStyle`이(가) `native`로 설정된 경우 사용자 지정 제목 표시줄을 숨깁니다.
  "window.customTitleBarVisibility": "auto",

  // 대화 상자의 모양을 OS에 맞게 또는 사용자 지정하여 조정합니다.
  "window.dialogStyle": "native",

  // 활성화된 경우 이 설정에서 제목 표시줄의 애플리케이션 아이콘을 두 번 클릭하면 창이 닫힙니다. 창은 아이콘으로 끌 수 없습니다. 이 설정은 `window.titleBarStyle`이(가) `custom`으로 설정된 경우에만 유효합니다.
  "window.doubleClickIconToClose": false,

  // <Alt> 키 바로 가기를 통해 주 메뉴를 열 수 있는지 여부를 제어합니다. 대신 니모닉을 사용하지 않도록 설정하면 이러한 <Alt> 키 바로 가기를 편집기 명령에 바인딩할 수 있습니다.
  "window.enableMenuBarMnemonics": true,

  // 메뉴 모음의 표시 여부를 제어합니다. '토글' 설정은 메뉴 모음이 숨겨지고 'Alt' 키를 한 번 누르면 메뉴 모음이 표시됨을 의미합니다. '컴팩트' 설정은 메뉴를 사이드바로 이동시킵니다.
  //  - classic: 메뉴가 창 위쪽에 표시되고 전체 화면 모드에서만 숨겨집니다.
  //  - visible: 전체 화면 모드에서도 메뉴가 항상 창 위쪽에 표시됩니다.
  //  - toggle: 메뉴가 숨겨지지만, <Alt> 키를 통해 창 위쪽에 표시할 수 있습니다.
  //  - hidden: 메뉴가 항상 숨겨집니다.
  //  - compact: 메뉴는 사이드바에 컴팩트 단추로 표시됩니다. 이 값은 `window.titleBarStyle#`이(가) `native`이고 `#window.menuStyle`이(가) `native` 또는 `inherit`인 경우 무시됩니다.
  "window.menuBarVisibility": "classic",

  // 메뉴 스타일을 OS에서 기본으로 사용하거나 사용자 지정하거나 `window.titleBarStyle`에 정의된 제목 표시줄 스타일에서 상속되도록 조정합니다. 이는 상황에 맞는 메뉴 모양에도 영향을 줍니다. 변경 내용을 적용하려면 완전히 다시 시작해야 합니다.
  //  - custom: 사용자 지정 메뉴를 사용하세요.
  //  - native: 기본 메뉴를 사용합니다. `window.titleBarStyle`이(가) `custom`(으)로 설정된 경우 무시됩니다.
  //  - inherit: 메뉴 스타일을 `window.titleBarStyle`에서 정의된 제목 표시줄 스타일과 일치시킵니다.
  "window.menuStyle": "inherit",

  // 하나 이상의 창이 이미 열려 있을 때 새 창을 여는 크기를 제어합니다. 이 설정은 여는 첫 번째 창에는 적용되지 않습니다. 첫 번째 창의 경우 항상 창을 닫기 전의 크기와 위치가 복원됩니다.
  //  - default: 화면 가운데에서 새 창을 엽니다.
  //  - inherit: 마지막 활성 창과 동일한 크기로 새 창을 엽니다.
  //  - offset: 오프셋 위치에 있는 마지막 활성 창과 차원이 같은 새 창을 엽니다.
  //  - maximized: 최대화된 새 창을 엽니다.
  //  - fullscreen: 전체 화면 모드에서 새 창을 엽니다.
  "window.newWindowDimensions": "default",

  // 새 창을 열 때 사용할 프로필을 지정합니다. 프로필 이름이 제공되면 새 창에서 해당 프로필을 사용합니다. 프로필 이름이 제공되지 않으면 활성 창이 없는 경우 새 창에서 활성 창의 프로필 또는 기본 프로필을 사용합니다.
  "window.newWindowProfile": null,

  // 명령줄이나 파일 대화 상자를 사용할 때 파일을 새 창에서 열어야 하는지 여부를 제어합니다.
  // 이 설정이 무시되는 경우가 여전히 있을 수 있습니다(예: `--new-window` 또는 `--reuse -window` 명령줄 옵션).
  //  - on: 파일이 새 창에서 열립니다.
  //  - off: 파일이 파일의 폴더가 열려 있는 창 또는 마지막 활성 창에서 열립니다.
  //  - default: 애플리케이션 내에서 선택(예: 파일 메뉴를 통해)하는 경우를 제외하고 파일이 새 창에서 열립니다.
  "window.openFilesInNewWindow": "off",

  // 폴더를 새 창에서 열거나 마지막 활성 창을 바꿀지 여부를 제어합니다.
  // 이 설정이 무시되는 경우도 있을 수 있습니다(예: '--new-window' 또는 '--reuse-window' 명령줄 옵션을 사용할 경우).
  //  - on: 폴더가 새 창에서 열립니다.
  //  - off: 폴더가 마지막 활성 창을 바꿉니다.
  //  - default: 폴더를 애플리케이션 내에서 선택(예: 파일 메뉴를 통해)하는 경우를 제외하고 폴더가 새 창에서 열립니다.
  "window.openFoldersInNewWindow": "default",

  // 인수 없이 두 번째 인스턴스를 시작할 때 새로운 빈 창을 열지 또는 실행 중인 마지막 인스턴스에 포커스가 생기는지 여부를 제어합니다.
  // 이 설정이 무시되는 경우도 있을 수 있습니다(예: '--new-window' 또는 '--reuse-window' 명령줄 옵션을 사용할 경우).
  //  - on: 빈 창을 새로 엽니다.
  //  - off: 실행 중인 마지막 활성 인스턴스에 포커스가 생깁니다.
  "window.openWithoutArgumentsInNewWindow": "on",

  // 창이 전체 화면 모드에서 종료된 경우 창을 전체 화면 모드로 복원할지 여부를 제어합니다.
  "window.restoreFullscreen": false,

  // 창 및 편집기를 열 때 복원하는 방법을 제어합니다.
  //  - preserve: 항상 모든 창을 다시 엽니다. 폴더 또는 작업 영역이 열려 있는 경우(예: 명령줄에서) 이전에 열리지 않은 한 새 창으로 엽니다. 파일이 열리면 이전에 열었던 편집기와 함께 복원된 창 중 하나에서 열립니다.
  //  - all: 폴더, 작업 영역 또는 파일이 열려 있지 않은 한(예: 명령줄에서) 모든 창을 다시 엽니다. 파일이 열리면 이전에 창에서 열었던 편집기가 대체됩니다.
  //  - folders: 폴더, 작업 영역 또는 파일이 열려 있지 않은 한(예: 명령줄에서) 열린 폴더 또는 작업 영역이 있는 모든 창을 다시 엽니다. 파일이 열리면 이전에 창에서 열었던 편집기가 대체됩니다.
  //  - one: 폴더, 작업 영역 또는 파일이 열려 있지 않은 한(예: 명령줄에서) 마지막 활성 창을 다시 엽니다. 파일이 열리면 이전에 창에서 열었던 편집기가 대체됩니다.
  //  - none: 창을 다시 열지 않습니다. 폴더 또는 작업 영역이 열려 있지 않은 한(예: 명령줄에서) 빈 창이 표시됩니다.
  "window.restoreWindows": "all",

  // 열린 작업 영역 또는 활성 편집기 같은 현재 컨텍스트를 기반으로 창 제목을 제어합니다. 변수는 컨텍스트에 따라 대체됩니다.
  // - `${activeEditorShort}`: 파일 이름(예: myFile.txt).
  // - '${activeEditorMedium}: 작업 영역 폴더(예: myFolder/myFileFolder/myFile.txt)와 관련된 파일의 경로입니다.
  // - `${activeEditorLong}`: 파일 전체 경로(예: /Users/Development/myFolder/myFileFolder/myFile.txt).
  // - '${activeFolderShort}: 파일이 포함된 폴더 이름(예: myFileFolder)입니다.
  // - `${activeFolderMedium}`: 파일이 포함된 관련된 작업 영역 폴더(예: myFolder/myFileFolder)에 포함된 폴더 경로.
  // - `${activeFolderLong}`: 파일이 포함된 폴더 전체 경로(예: /Users/Development/myFolder/myFileFolder).
  // - `${folderName}`: 파일이 포함된 작업 영역 폴더의 이름(예 : myFolder).
  // - `${folderPath}`: 파일이 포함된 작업 영역 폴더의 파일 경도(예: /Users/Development/myFolder).
  // - `${rootName}`: 해당되는 경우 선택적인 원격 이름 및 작업 영역 표시기가 있는 작업 영역의 이름(예: myFolder, myRemoteFolder [SSH] 또는 myWorkspace(Workspace)).
  // - '${rootNameShort}': 접미사가 없는 작업 영역의 단축 이름입니다(예: myFolder, myRemoteFolder 또는 myWorkspace).
  // - `${rootPath}`: 열려 있는 작업 영역 또는 폴더의 파일 경로입니다(예: /Users/Development/myWorkspace).
  // - `${profileName}`: 작업 영역이 열리는 프로필의 이름입니다(예: 데이터 과학(프로필)). 기본 프로필을 사용하는 경우 무시됩니다.
  // - `${appName}`: 예: VS Code.
  // - `${remoteName}`: 예: SSH
  // - `${dirty}`: 활성 편집기에 저장되지 않은 변경 내용이 있는 경우에 대한 표시기입니다.
  // - `${focusedView}`: 현재 포커스가 맞춰져 있는 보기의 이름입니다.
  // - '${activeRepositoryName}': 활성 리포지토리의 이름(예: vscode)
  // - '${activeRepositoryBranchName}': 활성 리포지토리(예: main)의 활성 분기 이름입니다.
  // - '${activeEditorState}': 활성 편집기의 상태에 대한 정보(예: 수정됨)를 제공합니다. `accessibility.windowTitleOptimized`(이)가 사용하도록 설정된 화면 읽기 프로그램 모드에서 기본적으로 추가됩니다.
  // - `${separator}`: 값 또는 정적 텍스트가 있는 변수로 둘러싸인 경우에만 표시되는 조건부 구분 기호 ( "-").
  "window.title": "${dirty}${activeEditorShort}${separator}${rootName}${separator}${profileName}${separator}${appName}",

  // OS 또는 사용자 지정에 의해 네이티브가 되도록 창 제목 표시줄의 모양을 조정합니다. 변경 내용을 적용하려면 완전히 다시 시작해야 합니다.
  "window.titleBarStyle": "custom",

  // `window.title`이(가) 사용하는 구분 기호입니다.
  "window.titleSeparator": " - ",

  // 모든 창의 기본 확대/축소 수준을 조정합니다. '0'(예: '1') 또는 이하(예: '-1')를 초과하는 각 증가는 확대/축소 '20%'를 더 크거나 더 작게 나타냅니다. 소수 자릿수를 입력하여 확대/축소 수준을 더 세밀하게 조정할 수도 있습니다. '확대' 및 '축소' 명령이 모든 창에 확대/축소 수준을 적용하는지 아니면 활성 창에만 적용하는지 구성하려면 `window.zoomPerWindow`(을)를 참조하세요.
  "window.zoomLevel": 0,

  // '확대' 및 '축소' 명령이 확대/축소 수준을 모든 창에 적용할지 아니면 활성 창에만 적용할지를 제어합니다. 모든 창의 기본 확대/축소 수준을 구성하려면 `window.zoomLevel` 페이지를 참조하세요.
  "window.zoomPerWindow": true,

  // 스크린캐스트 모드 키보드의 글꼴 크기(픽셀)를 제어합니다.
  "screencastMode.fontSize": 56,

  // 스크린캐스트 모드에서 키보드 오버레이를 사용자 지정하는 옵션입니다.
  "screencastMode.keyboardOptions": {
    "showKeys": true,
    "showKeybindings": true,
    "showCommands": true,
    "showCommandGroups": false,
    "showSingleEditorCursorMoves": true
  },

  // 스크린캐스트 모드에서 키보드 오버레이가 표시되는 시간(밀리초)을 제어합니다.
  "screencastMode.keyboardOverlayTimeout": 800,

  // 스크린캐스트 모드에서 마우스 표시기의 헥스(#RGB, #RGBA, #RRGGBB 또는 #RRGGBBAA) 색상을 제어합니다.
  "screencastMode.mouseIndicatorColor": "#FF0000",

  // 스크린캐스트 모드에서 마우스 표시기의 크기(픽셀)를 제어합니다.
  "screencastMode.mouseIndicatorSize": 20,

  // 맨 아래에서 스크린캐스트 모드 오버레이의 수직 오프셋을 워크벤치 높이의 백분율로 제어합니다.
  "screencastMode.verticalOffset": 20,

  // 언어에 대한 파일 연결의 [GLOB 패턴](https://aka.ms/vscode-glob-patterns)을 구성합니다(예: `"*.extension": "html"`). 패턴은 경로 구분 기호가 포함된 경우 파일의 절대 경로에서 일치하며, 그렇지 않은 경우 파일 이름에서 일치합니다. 이는 설치된 언어의 기본 연결보다 우선합니다.
  "files.associations": {},

  // 사용하도록 설정하면 편집기는 파일을 열 때 문자 집합 인코딩을 추측하려고 시도합니다. 이 설정은 언어별로 구성할 수도 있습니다. 이 설정은 텍스트 검색에서 적용되지 않습니다. `files.encoding`만 적용됩니다.
  "files.autoGuessEncoding": false,

  // 저장되지 않은 변경 사항이 있는 편집기의 [자동 저장](https://code.visualstudio.com/docs/editor/codebasics#_save-auto-save)을 제어합니다.
  //  - off: 변경 내용이 있는 편집기는 자동으로 저장되지 않습니다.
  //  - afterDelay: 변경 내용이 있는 편집기는 구성된 '#files.autoSaveDelay#' 후에 자동으로 저장됩니다.
  //  - onFocusChange: 편집기에서 포커스가 손실되면 변경 내용이 있는 편집기가 자동으로 저장됩니다.
  //  - onWindowChange: 창에서 포커스가 손실되면 변경 내용이 있는 편집기가 자동으로 저장됩니다.
  "files.autoSave": "off",

  // 저장되지 않은 변경 내용이 있는 편집기가 자동으로 저장되기까지의 지연(밀리초)을 제어합니다. '#files.autoSave#'가 'afterDelay'(으)로 설정된 경우에만 적용됩니다.
  "files.autoSaveDelay": 1000,

  // 사용하도록 설정하면 자동 저장이 트리거될 때 보고되는 오류가 없는 파일로 편집기의 [자동 저장](https://code.visualstudio.com/docs/editor/codebasics#_save-auto-save)을 제한합니다. `files.autoSave`을(를) 사용하도록 설정된 경우에만 적용됩니다.
  "files.autoSaveWhenNoErrors": false,

  // 사용 설정하면 편집기의 [자동 저장](https://code.visualstudio.com/docs/editor/codebasics#_save-auto-save)을 열린 작업 영역 내에 있는 파일로 제한합니다. `files.autoSave`을(를) 사용하도록 설정된 경우에만 적용됩니다.
  "files.autoSaveWorkspaceFilesOnly": false,

  // 편집기에서 나열된 순서대로 추측해야 하는 문자 집합 인코딩 목록입니다. 확인할 수 없는 경우 `files.encoding` 적용됨
  //  - utf8: UTF-8
  //  - utf16le: UTF-16 LE
  //  - utf16be: UTF-16 BE
  //  - windows1252: Western (Windows 1252)
  //  - windows1250: Central European (Windows 1250)
  //  - iso88592: Central European (ISO 8859-2)
  //  - windows1251: Cyrillic (Windows 1251)
  //  - cp866: Cyrillic (CP 866)
  //  - cp1125: Cyrillic (CP 1125)
  //  - iso88595: Cyrillic (ISO 8859-5)
  //  - koi8r: Cyrillic (KOI8-R)
  //  - windows1253: Greek (Windows 1253)
  //  - iso88597: Greek (ISO 8859-7)
  //  - windows1255: Hebrew (Windows 1255)
  //  - iso88598: Hebrew (ISO 8859-8)
  //  - cp950: Traditional Chinese (Big5)
  //  - shiftjis: Japanese (Shift JIS)
  //  - eucjp: Japanese (EUC-JP)
  //  - euckr: Korean (EUC-KR)
  //  - gb2312: Simplified Chinese (GB 2312)
  "files.candidateGuessEncodings": [],

  // 새 파일에 할당된 기본 언어 식별자입니다. `${activeEditorLanguage}`로 구성된 경우 현재 활성화된 텍스트 편집기의 언어 식별자(있는 경우)를 사용합니다.
  "files.defaultLanguage": "",

  // 파일 대화 상자의 기본 경로로, 사용자의 홈 경로를 재정의합니다. 가장 최근에 연 파일 또는 폴더와 같은 컨텍스트 관련 경로가 없는 경우에만 사용됩니다.
  "files.dialog.defaultPath": "",

  // 파일/폴더를 삭제하면 OS 휴지통(Windows의 휴지통)으로 이동합니다. 사용하지 않도록 설정하면 파일/폴더를 영구적으로 삭제합니다.
  "files.enableTrash": true,

  // 파일을 읽고 쓸 때 사용할 기본 문자 집합 인코딩입니다. 이 설정은 언어별로 구성할 수도 있습니다.
  //  - utf8: UTF-8
  //  - utf8bom: UTF-8 with BOM
  //  - utf16le: UTF-16 LE
  //  - utf16be: UTF-16 BE
  //  - windows1252: Western (Windows 1252)
  //  - iso88591: Western (ISO 8859-1)
  //  - iso88593: Western (ISO 8859-3)
  //  - iso885915: Western (ISO 8859-15)
  //  - macroman: Western (Mac Roman)
  //  - cp437: DOS (CP 437)
  //  - windows1256: Arabic (Windows 1256)
  //  - iso88596: Arabic (ISO 8859-6)
  //  - windows1257: Baltic (Windows 1257)
  //  - iso88594: Baltic (ISO 8859-4)
  //  - iso885914: Celtic (ISO 8859-14)
  //  - windows1250: Central European (Windows 1250)
  //  - iso88592: Central European (ISO 8859-2)
  //  - cp852: Central European (CP 852)
  //  - windows1251: Cyrillic (Windows 1251)
  //  - cp866: Cyrillic (CP 866)
  //  - cp1125: Cyrillic (CP 1125)
  //  - iso88595: Cyrillic (ISO 8859-5)
  //  - koi8r: Cyrillic (KOI8-R)
  //  - koi8u: Cyrillic (KOI8-U)
  //  - iso885913: Estonian (ISO 8859-13)
  //  - windows1253: Greek (Windows 1253)
  //  - iso88597: Greek (ISO 8859-7)
  //  - windows1255: Hebrew (Windows 1255)
  //  - iso88598: Hebrew (ISO 8859-8)
  //  - iso885910: Nordic (ISO 8859-10)
  //  - iso885916: Romanian (ISO 8859-16)
  //  - windows1254: Turkish (Windows 1254)
  //  - iso88599: Turkish (ISO 8859-9)
  //  - windows1258: Vietnamese (Windows 1258)
  //  - gbk: Simplified Chinese (GBK)
  //  - gb18030: Simplified Chinese (GB18030)
  //  - cp950: Traditional Chinese (Big5)
  //  - big5hkscs: Traditional Chinese (Big5-HKSCS)
  //  - shiftjis: Japanese (Shift JIS)
  //  - eucjp: Japanese (EUC-JP)
  //  - euckr: Korean (EUC-KR)
  //  - windows874: Thai (Windows 874)
  //  - iso885911: Latin/Thai (ISO 8859-11)
  //  - koi8ru: Cyrillic (KOI8-RU)
  //  - koi8t: Tajik (KOI8-T)
  //  - gb2312: Simplified Chinese (GB 2312)
  //  - cp865: Nordic DOS (CP 865)
  //  - cp850: Western European DOS (CP 850)
  "files.encoding": "utf8",

  // 줄 바꿈 문자의 기본 끝입니다.
  //  - \n: LF
  //  - \r\n: CRLF
  //  - auto: 운영 체제별 줄 바꿈 문자를 사용합니다.
  "files.eol": "auto",

  // 파일 및 폴더 제외를 위해 [GLOB 패턴](https://aka.ms/vscode-glob-patterns)을 구성합니다. 예를 들어 파일 탐색기는 이 설정에 따라 표시하거나 숨길 파일과 폴더를 결정합니다. 검색 제외를 정의하려면 `search.exclude#` 설정을 참조합니다. `.gitignore`에 따라 파일을 무시하려면 `#explorer.excludeGitIgnore` 설정을 참조합니다.
  "files.exclude": {
    "**/.git": true,
    "**/.svn": true,
    "**/.hg": true,
    "**/.DS_Store": true,
    "**/Thumbs.db": true
  },

  // [Hot Exit](https://aka.ms/vscode-hot-exit)는 저장하지 않은 파일을 세션 간에 기억하여, 편집기를 종료할 때 저장할지 묻는 메시지를 건너뛸지 여부를 제어합니다.
  //  - off: 핫 종료를 사용하지 않도록 설정합니다. 저장하지 않은 변경 내용이 있는 편집기가 있는 창을 닫을 때 프롬프트가 표시됩니다.
  //  - onExit: Windows/Linux에서 마지막 창이 닫히거나 `workbench.action.quit` 명령이 트리거될 때(명령 팔레트, 키 바인딩, 메뉴) Hot Exit가 트리거됩니다. 열린 폴더가 없는 모든 창은 다음 실행 시 복원됩니다. 저장되지 않은 파일이 있는 이전에 연 창 목록은 `파일 > 최근 파일 열기 > 더 보기...`에서 액세스할 수 있습니다.
  //  - onExitAndWindowClose: Windows/Linux에서 마지막 창이 닫히거나 `workbench.action.quit` 명령이 트리거될 때(명령 팔레트, 키 바인딩, 메뉴) 또는 마지막 창인지 여부와 관계 없이 폴더가 열린 모든 창에 대해 Hot Exit가 트리거됩니다. 열린 폴더가 없는 모든 창은 다음 실행 시 복원됩니다. 저장되지 않은 파일이 있는 이전에 연 창 목록은 `파일 > 최근 파일 열기 > 더 보기...`에서 액세스할 수 있습니다.
  "files.hotExit": "onExit",

  // 사용하도록 설정되면 저장할 때 파일 끝에 마지막 줄바꿈을 삽입합니다.
  "files.insertFinalNewline": false,

  // 생성, 이름 바꾸기 및 삭제를 위한 파일 참가자가 취소된 후 밀리초 단위의 시간 제한입니다. 참가자를 비활성화하려면 '0'을 사용합니다.
  "files.participants.timeout": 60000,

  // `files.readonlyInclude` 설정 결과와 일치하는 경우 경로 또는 [GLOB 패턴](https://aka.ms/vscode-glob-patterns)이 읽기 전용으로 표시되지 않도록 구성합니다. GLOB 패턴은 절대 경로가 아닌 경우 작업 영역 폴더의 경로에 따라 항상 평가됩니다. 읽기 전용 파일 시스템 공급자의 파일은 항상 이 설정과 독립적으로 읽기 전용입니다.
  "files.readonlyExclude": {},

  // 파일 사용 권한이 다음과 같이 표시되면 파일을 읽기 전용으로 표시합니다. 이 설정은 `files.readonlyInclude#` 및 `#files.readonlyExclude` 설정을 통해 재정의할 수 있습니다.
  "files.readonlyFromPermissions": false,

  // 읽기 전용으로 표시하도록 경로 또는 [GLOB 패턴](https://aka.ms/vscode-glob-patterns)을 구성합니다. GLOB 패턴은 절대 경로가 아닌 경우 작업 영역 폴더의 경로에 따라 항상 평가됩니다. `files.readonlyExclude` 설정을 통해 일치하는 경로를 제외할 수 있습니다. 읽기 전용 파일 시스템 공급자의 파일은 항상 이 설정과 독립적으로 읽기 전용입니다.
  "files.readonlyInclude": {},

  // 리팩터링의 일부인 파일이 자동으로 저장되는지를 제어합니다.
  "files.refactoring.autoSave": true,

  // 파일을 다시 열 때 실행 취소 스택을 복원합니다.
  "files.restoreUndoStack": true,

  // 그동안 다른 프로그램에 의해 변경된 디스크에 파일을 저장할 경우 저장 충돌이 발생할 수 있습니다. 데이터 손실을 방지하기 위해 편집기의 변경 내용과 디스크의 버전을 비교하라는 메시지가 사용자에게 표시됩니다. 이 설정은 충돌 오류가 자주 발생하는 경우에만 변경해야 하며, 부주의한 사용은 데이터 손실을 초래할 수 있습니다.
  //  - askUser: 저장을 거부하고 수동으로 저장 충돌을 해결하도록 요청합니다.
  //  - overwriteFileOnDisk: 편집기의 변경 내용으로 디스크의 파일을 덮어써서 저장 충돌을 해결할 수 있습니다.
  "files.saveConflictResolution": "askUser",

  // 파일 및 폴더를 열고 저장할 수 있는 단순 파일 대화 상자를 활성화합니다. 사용 가능한 경우 단순 파일 대화 상자가 시스템 파일 대화 상자를 대체합니다.
  "files.simpleDialog.enable": false,

  // 사용하도록 설정되면 저장할 때 파일 끝에 마지막 줄 바꿈 이후의 모든 줄 바꿈이 잘립니다.
  "files.trimFinalNewlines": false,

  // 사용하도록 설정되면 파일을 저장할 때 후행 공백이 잘립니다.
  "files.trimTrailingWhitespace": false,

  // 사용하도록 설정하면 후행 공백이 여러 줄 문자열에서 제거되고 저장 시 또는 'editor.action.trimTrailingWhitespace'를 실행할 때 regexe가 제거됩니다. 이로 인해 최신 토큰 정보가 없는 경우 줄에서 공백이 잘려지지 않을 수 있습니다.
  "files.trimTrailingWhitespaceInRegexAndStrings": true,

  // 파일 감시에서 제외할 경로 또는 [GLOB 패턴](https://aka.ms/vscode-glob-patterns)을 구성합니다. 경로는 감시되는 폴더의 상대 경로이거나 절대 경로일 수 있습니다. GLOB 패턴은 감시되는 폴더에서 상대적으로 일치합니다. 파일 감시자 프로세스에서 CPU를 많이 사용하는 경우 관심도가 낮은 큰 폴더(예: 빌드 출력 폴더)를 제외해야 합니다.
  "files.watcherExclude": {
    "**/.git/objects/**": true,
    "**/.git/subtree-cache/**": true,
    "**/.hg/store/**": true
  },

  // 작업 영역 내부의 변경 내용을 감시할 추가 경로를 구성합니다. 기본적으로 기호 링크인 폴더를 제외한 모든 작업 영역 폴더는 재귀적으로 감시됩니다. 기호 링크인 감시 폴더를 지원하기 위해 절대 또는 상대 경로를 명시적으로 추가할 수 있습니다. 상대 경로는 현재 열려 있는 작업 영역을 사용하여 절대 경로로 해석됩니다.
  "files.watcherInclude": [],

  // Zen 모드를 켜면 레이아웃도 가운데로 맞춰지는지 여부를 제어합니다.
  "zenMode.centerLayout": true,

  // Zen 모드를 켜면 워크벤치도 전체 화면 모드로 전환되는지 여부를 제어합니다.
  "zenMode.fullScreen": true,

  // Zen 모드를 켜면 워크벤치의 왼쪽 또는 오른쪽에 있는 작업 막대도 숨길지 여부를 제어합니다.
  "zenMode.hideActivityBar": true,

  // Zen 모드를 설정하면 편집기 줄 번호도 숨길 것인지 여부를 제어합니다.
  "zenMode.hideLineNumbers": true,

  // Zen 모드를 켜면 워크벤치 하단에서 상태 표시줄도 숨길지 여부를 제어합니다.
  "zenMode.hideStatusBar": true,

  // 창이 Zen 모드에서 종료된 경우 Zen 모드로 복원할지를 제어합니다.
  "zenMode.restore": true,

  // Zen 모드를 켜면 여러 편집기 탭, 단일 편집기 탭을 표시할지 아니면 편집기 제목 영역을 완전히 숨길지 여부를 제어합니다.
  //  - multiple: 각 편집기는 편집기 제목 영역에 탭으로 표시됩니다.
  //  - single: 활성 편집기는 편집기 제목 영역에 하나의 큰 탭으로 표시됩니다.
  //  - none: 편집기 제목 영역이 표시되지 않습니다.
  "zenMode.showTabs": "multiple",

  // Zen 모드에 있는 동안 알림 방해 금지 모드를 활성화할지를 제어합니다. true인 경우 오류 알림만 표시합니다.
  "zenMode.silentNotifications": true,

  // 탐색기에 파일을 놓을 때 탐색기에서 자동으로 파일을 열지 여부를 제어합니다.
  "explorer.autoOpenDroppedFile": true,

  // 탐색기에서 파일을 열 때 자동으로 표시하고 선택할지를 제어합니다.
  //  - true: 파일이 표시되고 선택됩니다.
  //  - false: 파일이 표시되지 않고 선택되지 않습니다.
  //  - focusNoScroll: 파일을 스크롤하여 볼 수 없지만 포커스는 계속 있습니다.
  "explorer.autoReveal": true,

  // 파일 및 폴더가 열려 있을 때 탐색기에서 파일 및 폴더가 표시 및 선택되지 않도록 경로 또는 [GLOB 패턴](https://aka.ms/vscode-glob-patterns)을 구성합니다. GLOB 패턴은 절대 경로가 아닌 경우 작업 영역 폴더의 경로에 따라 항상 평가됩니다.
  "explorer.autoRevealExclude": {
    "**/node_modules": true,
    "**/bower_components": true
  },

  // 탐색기가 폴더를 압축 형식으로 렌더링할지를 제어합니다. 이러한 양식에서 단일 하위 폴더는 결합된 트리 요소로 압축됩니다. 예를 들어 Java 패키지 구조에 유용합니다.
  "explorer.compactFolders": true,

  // 파일을 휴지통에서 삭제할 때 탐색기에서 확인을 요청해야 할지를 제어합니다.
  "explorer.confirmDelete": true,

  // 끌어서 놓기를 사용하여 파일 및 폴더를 이동하기 위해 탐색기에서 확인을 요청해야 할지를 제어합니다.
  "explorer.confirmDragAndDrop": true,

  // 탐색기가 네이티브 파일 및 폴더를 붙여넣을 때 확인을 요청해야 하는지 여부를 제어합니다.
  "explorer.confirmPasteNative": true,

  // 탐색기가 실행 취소할 때 확인을 요청해야 하는지 여부를 제어합니다.
  //  - verbose: 탐색기는 모든 실행 취소 작업 전에 메시지를 표시합니다.
  //  - default: 탐색기는 파괴적인 실행 취소 작업 전에 메시지를 표시합니다.
  //  - light: 탐색기는 포커스가 있을 때 작업을 실행 취소하기 전에 메시지를 표시하지 않습니다.
  "explorer.confirmUndo": "default",

  // 파일 경로를 복사할 때 사용되는 경로 구분 문자입니다.
  //  - /: 슬래시를 경로 구분 문자로 사용하세요.
  //  - \: 백슬래시를 경로 분리 문자로 사용하세요.
  //  - auto: 운영 체제별 경로 구분 문자를 사용하세요.
  "explorer.copyPathSeparator": "auto",

  // 상대 파일 경로를 복사할 때 사용되는 경로 구분 문자입니다.
  //  - /: 슬래시를 경로 구분 문자로 사용하세요.
  //  - \: 백슬래시를 경로 분리 문자로 사용하세요.
  //  - auto: 운영 체제별 경로 구분 문자를 사용하세요.
  "explorer.copyRelativePathSeparator": "auto",

  // 파일 장식에 배지를 사용할지 여부를 제어합니다.
  "explorer.decorations.badges": true,

  // 파일 장식에 색을 사용할지 여부를 제어합니다.
  "explorer.decorations.colors": true,

  // 탐색기에서 끌어서 놓기를 통해 파일 및 폴더를 이동할지를 제어합니다. 이 설정은 탐색기 내에서 끌어서 놓기에만 영향을 미칩니다.
  "explorer.enableDragAndDrop": true,

  // 탐색기가 파일 및 폴더 작업 실행 취소를 지원해야 하는지 여부를 제어합니다.
  "explorer.enableUndo": true,

  // .gitignore의 항목을 구문 분석하고 탐색기에서 제외해야 하는지 여부를 제어합니다. `files.exclude`과(와) 비슷합니다.
  "explorer.excludeGitIgnore": false,

  // 초기화 중에 폴더가 하나만 포함된 다중 루트 작업 영역을 탐색기에서 확장해야 하는지 여부를 제어합니다.
  "explorer.expandSingleFolderWorkspaces": true,

  // 탐색기에서 파일 중첩을 사용할지 여부를 제어합니다. 파일 중첩을 사용하면 디렉터리의 관련 파일을 단일 상위 파일 아래에 시각적으로 그룹화할 수 있습니다.
  "explorer.fileNesting.enabled": false,

  // 파일 중첩이 자동으로 확장되는지 여부를 제어합니다. 이 작업을 적용하려면 `explorer.fileNesting.enabled`을(를) 설정해야 합니다.
  "explorer.fileNesting.expand": true,

  // 탐색기에서 파일 중첩을 제어합니다. 이를 적용하려면 `explorer.fileNesting.enabled`을(를) 설정해야 합니다. 각 __Item__은 상위 패턴을 나타내며 모든 문자열과 일치하는 단일 `*` 문자를 포함할 수 있습니다. 각 __Value__는 지정된 상위 항목 아래에 중첩되어 표시되어야 하는 하위 패턴의 쉼표로 구분된 목록을 나타냅니다. 하위 패턴에는 다음과 같은 몇 가지 특수 토큰이 포함될 수 있습니다.
  // - `${capture}`: 상위 패턴의 확인된 `*` 값과 일치
  // - `${basename}`: 상위 파일의 기본 이름과 일치, `file.ts`의 `file`
  // - `${extname}`: 상위 파일의 확장명과 일치, `file.ts`의 `ts
  // - `${dirname}`: 상위 파일의 디렉터리 이름과 일치, `src/file.ts`의 `src`
  // - `*`: 모든 문자열과 일치, 하위 패턴당 한 번만 사용할 수 있음
  "explorer.fileNesting.patterns": {
    "*.ts": "${capture}.js",
    "*.js": "${capture}.js.map, ${capture}.min.js, ${capture}.d.ts",
    "*.jsx": "${capture}.js",
    "*.tsx": "${capture}.ts",
    "tsconfig.json": "tsconfig.*.json",
    "package.json": "package-lock.json, yarn.lock, pnpm-lock.yaml, bun.lockb, bun.lock"
  },

  // 붙여넣기에서 중복된 탐색기 항목에 새 이름을 지정할 때 사용할 명명 규칙을 제어합니다.
  //  - simple: 중복된 이름 끝에 "복사본"이라는 단어를 추가하고 뒤에 숫자를 붙일 수 있습니다.
  //  - smart: 중복된 이름 끝에 숫자를 추가합니다. 숫자가 이미 이름의 일부인 경우 숫자를 더 추가합니다.
  //  - disabled: 증분 이름 지정을 비활성화합니다. 같은 이름의 파일이 두 개 있는 경우 기존 파일을 덮어쓰라는 메시지가 표시됩니다.
  "explorer.incrementalNaming": "simple",

  // 편집기 열기 창에 미리 할당된 편집기 슬롯의 최소 수입니다. 0으로 설정하면 편집기 열기 창은 편집기 수에 따라 동적으로 크기가 조정됩니다.
  "explorer.openEditors.minVisible": 0,

  // 열린 편집기 창에서 편집기의 정렬 순서를 제어합니다.
  //  - editorOrder: 편집기가 편집기 탭이 표시된 것과 같은 순서로 정렬됩니다.
  //  - alphabetical: 편집기는 각 편집기 그룹 내에서 탭 이름을 기준으로 사전순으로 정렬됩니다.
  //  - fullPath: 편집기는 각 편집기 그룹 내의 전체 경로를 기준으로 사전순으로 정렬됩니다.
  "explorer.openEditors.sortOrder": "editorOrder",

  // 편집자 열기 창에 표시되는 초기 최대 편집자 수입니다. 이 제한을 초과하면 스크롤 막대가 표시되고 창 크기를 조정하여 더 많은 항목을 표시할 수 있습니다.
  "explorer.openEditors.visible": 9,

  // 탐색기에서 파일 및 폴더의 속성 기반 정렬을 제어합니다. `explorer.fileNesting.enabled`가 활성화되면 중첩된 파일의 정렬도 제어합니다.
  //  - default: 파일 및 폴더가 이름별로 정렬됩니다. 폴더가 파일 앞에 표시됩니다.
  //  - mixed: 파일 및 폴더가 이름별로 정렬됩니다. 파일이 폴더와 뒤섞입니다.
  //  - filesFirst: 파일 및 폴더가 이름별로 정렬됩니다. 파일이 폴더 앞에 표시됩니다.
  //  - type: 파일 및 폴더가 확장 형식별로 그룹화되고 이름별로 정렬됩니다. 폴더가 파일 앞에 표시됩니다.
  //  - modified: 파일 및 폴더가 마지막으로 수정한 날짜별로 내림차순 정렬됩니다. 폴더가 파일 앞에 표시됩니다.
  //  - foldersNestsFiles: 파일과 폴더는 이름별로 정렬됩니다. 폴더가 파일 앞에 표시됩니다. 중첩된 자식이 있는 파일이 다른 파일 앞에 표시됩니다.
  "explorer.sortOrder": "default",

  // Explorer에서 파일 및 폴더 이름의 사전 정렬을 제어합니다.
  //  - default: 대문자와 소문자는 함께 혼합됩니다.
  //  - upper: 대문자는 소문자 이름 앞에 함께 그룹화됩니다.
  //  - lower: 소문자는 대문자 이름 앞에 함께 그룹화됩니다.
  //  - unicode: 이름은 유니코드 순서로 정렬됩니다.
  "explorer.sortOrderLexicographicOptions": "default",

  // 파일 및 폴더 정렬 순서를 되돌릴지 여부를 제어합니다.
  "explorer.sortOrderReverse": false,

  // 검색 보기에서 행의 작업 모음 위치를 제어합니다.
  //  - auto: 검색 보기가 좁을 때는 오른쪽에, 그리고 검색 보기가 넓을 때는 콘텐츠 바로 뒤에 작업 모음을 배치합니다.
  //  - right: 작업 모음을 항상 오른쪽에 배치합니다.
  "search.actionsPosition": "right",

  // 검색 결과를 축소 또는 확장할지 여부를 제어합니다.
  //  - auto: 결과가 10개 미만인 파일이 확장됩니다. 다른 파일은 축소됩니다.
  //  - alwaysCollapse
  //  - alwaysExpand
  "search.collapseResults": "alwaysExpand",

  // 검색 파일 장식에 배지를 사용할지 여부를 제어합니다.
  "search.decorations.badges": true,

  // 검색 파일 장식에서 색을 사용해야 하는지 여부를 제어합니다.
  "search.decorations.colors": true,

  // 기본 검색 결과 보기 모드를 제어합니다.
  //  - tree: 검색 결과를 트리로 표시합니다.
  //  - list: 검색 결과를 목록으로 표시합니다.
  "search.defaultViewMode": "list",

  // 전체 텍스트 검색에서 파일 및 폴더를 제외하고 빠른 열기에서 파일 및 폴더를 제외하도록 [GLOB 패턴](https://code.visualstudio.com/docs/editor/codebasics#_advanced-search-options)을 구성합니다. 빠른 열기에서 최근에 열린 목록에서 파일을 제외하려면 패턴이 절대 패턴이어야 합니다(예: '**/node_modules/**'). '#files.exclude#' 설정에서 모든 GLOB 패턴을 상속합니다.
  "search.exclude": {
    "**/node_modules": true,
    "**/bower_components": true,
    "**/*.code-search": true
  },

  // 닫힌 전자 필기장에 대한 전자 필기장 편집기 서식 있는 콘텐츠 결과를 표시합니다. 이 설정을 변경한 후 검색 결과를 새로 고치세요.
  "search.experimental.closedNotebookRichContentResults": false,

  // 검색하는 동안 symlink를 누를지 여부를 제어합니다.
  "search.followSymlinks": true,

  // 이 설정은 더 이상 사용되지 않습니다. 대신 검색 아이콘을 새 위치로 끌 수 있습니다.
  // 검색을 사이드바의 보기로 표시할지 또는 가로 간격을 늘리기 위해 패널 영역의 패널로 표시할지를 제어합니다.
  "search.location": "sidebar",

  // 검색 캐시는 종료되지 않는 확장 호스트에 보관되므로 이 설정은 더 이상 필요하지 않습니다.
  // 사용하도록 설정하면 searchService 프로세스가 1시간의 비활성 상태 이후 종료되지 않고 계속 유지됩니다. 메모리에 파일 검색 캐시가 유지됩니다.
  "search.maintainFileSearchCache": false,

  // 최대 검색 결과 수를 제어합니다. 이 값을 'null'(비어 있음)으로 설정하여 무제한 결과를 반환할 수 있습니다.
  "search.maxResults": 20000,

  // 검색 보기 또는 검색 편집기 중 새 `검색: 파일에서 찾기` 및 `폴더에서 찾기` 작업이 발생하는 위치를 제어합니다.
  //  - view: 패널 또는 사이드바의 검색 보기에서 검색합니다.
  //  - reuseEditor: 기존 검색 편집기(있는 경우)에서 검색합니다. 기존 검색 편집기가 없으면 새 검색 편집기에서 검색합니다.
  //  - newEditor: 새 검색 편집기에서 검색합니다.
  "search.mode": "view",

  // 다음에 열 때 마지막으로 빠른 검색에 입력한 내용을 복원할지 여부를 제어합니다.
  "search.quickAccess.preserveInput": false,

  // 필터링할 때 빠른 열기에서 편집기 기록의 정렬 순서를 제어합니다.
  //  - default: 기록 항목은 사용된 필터 값을 기준으로 관련성별로 정렬됩니다. 관련성이 더 높은 항목이 먼저 표시됩니다.
  //  - recency: 기록이 최신순으로 정렬됩니다. 가장 최근에 열람한 항목부터 표시됩니다.
  "search.quickOpen.history.filterSortOrder": "default",

  // Quick Open에 대한 파일 결과에 최근에 연 파일의 결과를 포함할지 여부입니다.
  "search.quickOpen.includeHistory": true,

  // Quick Open에 대한 파일 결과에 전역 기호 검색 결과를 포함할지 여부입니다.
  "search.quickOpen.includeSymbols": false,

  // 검색에 사용할 스레드 수입니다. 0으로 설정하면 엔진이 이 값을 자동으로 결정합니다.
  "search.ripgrep.maxThreads": 0,

  // 새 검색 편집기를 만들 때 사용할 둘러싸는 컨텍스트 줄의 기본 수입니다. `search.searchEditor.reusePriorSearchConfiguration`을 사용하는 경우, 이전 검색 편집기의 구성을 사용하려면 `null`(비어 있음)로 설정할 수 있습니다.
  "search.searchEditor.defaultNumberOfContextLines": 1,

  // 검색 편집기에서 결과를 두 번 클릭하는 효과를 구성합니다.
  //  - selectWord: 두 번 클릭하면 커서 아래에 있는 단어가 선택됩니다.
  //  - goToLocation: 두 번 클릭하면 활성 편집기 그룹에 결과가 열립니다.
  //  - openLocationToSide: 두 번 클릭하면 측면의 편집기 그룹에 결과가 열리고, 편집기 그룹이 없으면 새로 만듭니다.
  "search.searchEditor.doubleClickBehaviour": "goToLocation",

  // 검색이 트리거되면 검색 편집기 입력 대신 검색 편집기 결과에 포커스를 둡니다.
  "search.searchEditor.focusResultsOnSearch": false,

  // 사용하도록 설정하면 새 검색 편집기가 이전에 연 검색 편집기의 포함, 제외, 플래그를 다시 사용합니다.
  "search.searchEditor.reusePriorSearchConfiguration": false,

  // 검색 편집기에서 결과를 한 번 클릭하는 효과를 구성합니다.
  //  - default: 한 번 클릭해도 아무 작업도 수행되지 않습니다.
  //  - peekDefinition: 한 번 클릭하면 정의 피킹 창이 열립니다.
  "search.searchEditor.singleClickBehaviour": "default",

  // 입력할 때 모든 파일을 검색합니다.
  "search.searchOnType": true,

  // `search.searchOnType#`을(를) 사용하도록 설정하면 입력되는 문자와 검색 시작 사이의 시간 제한(밀리초)을 제어합니다. `#search.searchOnType`을(를) 사용하지 않도록 설정된 경우에는 아무런 효과가 없습니다.
  "search.searchOnTypeDebouncePeriod": 300,

  // 검색 보기에서 키워드 제안을 사용하도록 설정합니다.
  "search.searchView.keywordSuggestions": false,

  // 검색 보기에서 표시되는 의미 체계 검색 결과의 동작을 제어합니다.
  //  - manual: 의미 체계 검색 결과만 수동으로 요청합니다.
  //  - runOnEmpty: 텍스트 검색 결과가 없을 때만 의미 체계 결과를 자동으로 요청합니다.
  //  - auto: 검색할 때마다 의미 체계 결과를 자동으로 요청합니다.
  "search.searchView.semanticSearchBehavior": "manual",

  // 검색 보기에 포커스가 있을 때 검색 쿼리를 편집기의 선택한 텍스트로 업데이트합니다. 이 동작은 클릭 시 또는 `workbench.views.search.focus` 명령을 트리거할 때 발생합니다.
  "search.seedOnFocus": false,

  // 활성 편집기에 선택 항목이 없을 경우 커서에 가장 가까운 단어에서 시드 검색을 사용합니다.
  "search.seedWithNearestWord": false,

  // 검색 결과의 줄 번호를 표시할지 여부를 제어합니다.
  "search.showLineNumbers": false,

  // 패턴이 모두 소문자인 경우 대/소문자를 구분하지 않고 검색하고, 그렇지 않으면 대/소문자를 구분하여 검색합니다.
  "search.smartCase": false,

  // 검색 결과의 정렬 순서를 제어합니다.
  //  - default: 결과는 폴더 및 파일 이름의 알파벳 순으로 정렬됩니다.
  //  - fileNames: 결과는 폴더 순서를 무시하고 파일 이름별 알파벳 순으로 정렬됩니다.
  //  - type: 결과는 파일 확장자의 알파벳 순으로 정렬됩니다.
  //  - modified: 결과는 파일을 마지막으로 수정한 날짜의 내림차순으로 정렬됩니다.
  //  - countDescending: 결과는 파일별 개수의 내림차순으로 정렬됩니다.
  //  - countAscending: 결과는 파일별 개수의 오름차순으로 정렬됩니다.
  "search.sortOrder": "default",

  // 파일을 검색할 때 전역 gitignore 파일(예: '$HOME/.config/git/ignore')을 사용할지 여부를 제어합니다. `search.useIgnoreFiles`을(를) 사용하도록 설정해야 합니다.
  "search.useGlobalIgnoreFiles": false,

  // 파일을 검색할 때 '.gitignore' 파일 및 '.ignore' 파일을 사용할지 여부를 제어합니다.
  "search.useIgnoreFiles": true,

  // 파일을 검색할 때 부모 디렉터리에서 '.gitignore' 파일 및 '.ignore' 파일을 사용할지 여부를 제어합니다. `search.useIgnoreFiles`을(를) 사용하도록 설정해야 합니다.
  "search.useParentIgnoreFiles": false,

  // 사용되지 않습니다. PCRE2는 PCRE2에서만 지원하는 regex 기능을 사용할 경우 자동으로 사용됩니다.
  // 텍스트 검색에서 PCRE2 regex 엔진을 사용할지 여부입니다. 사용하도록 설정하면 lookahead 및 backreferences와 같은 몇 가지 고급 regex 기능을 사용할 수 있습니다. 하지만 모든 PCRE2 기능이 지원되지는 않으며, JavaScript에서도 지원되는 기능만 지원됩니다.
  "search.usePCRE2": false,

  // 일치하는 항목을 선택하거나 바꿀 때 미리 보기 바꾸기를 열지 여부를 제어합니다.
  "search.useReplacePreview": true,

  // 사용되지 않습니다. 고급 regex 기능을 지원하려면 "search.usePCRE2"를 사용해 보세요.
  // 이 설정은 사용되지 않으며 이제 "search.usePCRE2"로 대체됩니다.
  "search.useRipgrep": true,

  // 이 설정은 사용되지 않습니다. 'update.mode'을(를) 대신 사용하세요.
  // 자동 업데이트를 받을지 여부를 구성합니다. 변경 후 다시 시작해야 합니다. 업데이트는 Microsoft 온라인 서비스에서 가져옵니다.
  "update.channel": "default",

  // 새로운 VS Code 버전을 Windows 백그라운드에 다운로드 및 설치하려면 사용하도록 설정
  "update.enableWindowsBackgroundUpdates": true,

  // 자동 업데이트를 받을지 여부를 구성합니다. 변경 후 다시 시작해야 합니다. 업데이트는 Microsoft 온라인 서비스에서 가져옵니다.
  //  - none: 업데이트를 사용하지 않도록 설정합니다.
  //  - manual: 자동 백그라운드 업데이트 확인을 사용하지 않도록 설정합니다. 업데이트를 수동으로 확인하여 진행할 수 있습니다.
  //  - start: 시작할 때만 업데이트를 확인합니다. 자동 백그라운드 업데이트 검사를 사용하지 않도록 설정합니다.
  //  - default: 자동 업데이트 확인을 사용하도록 설정합니다. Code에서 정기적으로 업데이트를 자동 확인합니다.
  "update.mode": "default",

  // 업데이트 후 릴리스 노트를 표시합니다. 릴리스 노트는 Microsoft 온라인 서비스에서 가져옵니다.
  "update.showReleaseNotes": true,

  // AltGraph+ 한정자를 Ctrl+Alt+로 처리해야 하는지를 제어합니다.
  "keyboard.mapAltGrToCtrlAlt": false,

  // Node.js의 페치 구현 대신 Electron의 페치 구현을 사용할지 여부를 제어합니다. 모든 로컬 확장은 전역 페치 API에 대한 Electron의 페치 구현을 가져옵니다.
  "http.electronFetch": false,

  // OS에서 CA 인증서의 실험적 로드를 사용하도록 설정할지 여부를 제어합니다. 기본 구현보다 더 일반적인 방법을 사용합니다. [remote development](https://aka.ms/vscode-remote) 동안 `http.useLocalProxyConfiguration` 설정을 사용하지 않도록 설정하는 경우 로컬 및 원격 설정에서 별도로 이 설정을 구성할 수 있습니다.
  "http.experimental.systemCertificatesV2": false,

  // 추가 지원을 통해 Node.js 가져오기 구현을 확장할지 여부를 제어합니다. 해당 설정을 사용하도록 설정하면 현재 프록시 지원(`http.proxySupport#`) 및 시스템 인증서(`#http.systemCertificates#`)가 추가됩니다. [remote development](https://aka.ms/vscode-remote) 동안 `#http.useLocalProxyConfiguration` 설정을 사용하지 않도록 설정하는 경우 로컬 및 원격 설정에서 별도로 이 설정을 구성할 수 있습니다.
  "http.fetchAdditionalSupport": true,

  // HTTP/HTTPS 요청에 대해 프록시 설정을 무시해야 하는 도메인 이름을 지정합니다. [remote development](https://aka.ms/vscode-remote) 동안 `http.useLocalProxyConfiguration` 설정을 사용하지 않도록 설정하는 경우 로컬 및 원격 설정에서 별도로 이 설정을 구성할 수 있습니다.
  "http.noProxy": [],

  // 사용할 프록시 설정입니다. 설정하지 않으면 'http_proxy' 및 'https_proxy' 환경 변수에서 상속됩니다. [remote development](https://aka.ms/vscode-remote) 동안 `http.useLocalProxyConfiguration` 설정을 사용하지 않도록 설정하는 경우 로컬 및 원격 설정에서 별도로 이 설정을 구성할 수 있습니다.
  "http.proxy": "",

  // 모든 네트워크 요청에 대해 'Proxy-Authorization' 헤더로 보낼 값입니다. [remote development](https://aka.ms/vscode-remote) 동안 `http.useLocalProxyConfiguration` 설정을 사용하지 않도록 설정하는 경우 로컬 및 원격 설정에서 별도로 이 설정을 구성할 수 있습니다.
  "http.proxyAuthorization": null,

  // Kerberos 인증에 대한 주 서비스 이름을 HTTP 프록시로 재정의합니다. 프록시 호스트 이름을 기반으로 하는 기본값은 설정되지 않은 경우에 사용됩니다. [remote development](https://aka.ms/vscode-remote) 동안 `http.useLocalProxyConfiguration` 설정을 사용하지 않도록 설정하는 경우 로컬 및 원격 설정에서 별도로 이 설정을 구성할 수 있습니다.
  "http.proxyKerberosServicePrincipal": "",

  // 제공된 CA 목록에 대해 프록시 서버 인증서를 확인해야 하는지 여부를 제어합니다. [remote development](https://aka.ms/vscode-remote) 동안 `http.useLocalProxyConfiguration` 설정을 사용하지 않도록 설정하는 경우 로컬 및 원격 설정에서 별도로 이 설정을 구성할 수 있습니다.
  "http.proxyStrictSSL": true,

  // 확장에 프록시 지원을 사용합니다. [remote development](https://aka.ms/vscode-remote) 동안 `http.useLocalProxyConfiguration` 설정을 사용하지 않도록 설정하는 경우 로컬 및 원격 설정에서 별도로 이 설정을 구성할 수 있습니다.
  //  - off: 확장에 대한 프록시 지원을 사용하지 않도록 설정합니다.
  //  - on: 확장에 대한 프록시 지원을 사용하도록 설정합니다.
  //  - fallback: 프록시를 찾을 수 없는 경우 확장에 대한 프록시 지원을 사용하도록 설정하고 요청 옵션으로 대체합니다.
  //  - override: 확장에 대한 프록시 지원을 사용하지 않도록 설정하고 요청 옵션을 재정의합니다.
  "http.proxySupport": "override",

  // OS에서 CA 인증서를 로드해야 하는지 여부를 제어합니다. Windows 및 macOS에서는 이 기능을 끈 후 창을 다시 로드해야 합니다. [remote development](https://aka.ms/vscode-remote) 동안 `http.useLocalProxyConfiguration` 설정을 사용하지 않도록 설정하는 경우 로컬 및 원격 설정에서 별도로 이 설정을 구성할 수 있습니다.
  "http.systemCertificates": true,

  // 원격 확장 호스트에서 로컬 프록시 구성을 사용할지 여부를 제어합니다. 이 설정은 [remote development](https://aka.ms/vscode-remote). 중에 원격 설정으로만 적용됩니다.
  "http.useLocalProxyConfiguration": true,

  // 모든 파일에서 중단점을 설정할 수 있습니다.
  "debug.allowBreakpointsEverywhere": false,

  // getter와 같이 지연적으로 확인되는 변수가 디버거에 의해 자동으로 확인되고 확장되는지 여부를 제어합니다.
  //  - auto: 화면 읽기 프로그램 최적화 모드에서 지연 변수를 자동으로 확장합니다.
  //  - on: 항상 지연 변수를 자동으로 확장합니다.
  //  - off: 지연 변수를 자동으로 확장하지 않습니다.
  "debug.autoExpandLazyVariables": "auto",

  // 디버그 세션이 끝나면 해당 세션과 연결된 모든 읽기 전용 탭이 닫힙니다.
  "debug.closeReadonlyTabsOnEnd": false,

  // 활성 디버그 세션이 있는 경우 창이 닫힐 때 확인할지 여부를 제어합니다.
  //  - never: 절대 확인하지 마세요.
  //  - always: 디버그 세션이 있는지 항상 확인하세요.
  "debug.confirmOnExit": "never",

  // 디버그 콘솔에서 Enter를 누를 시 제안을 수락할지 여부를 제어합니다. Enter는 디버그 콘솔에 입력된 내용을 평가하는 데에도 사용됩니다.
  "debug.console.acceptSuggestionOnEnter": "off",

  // 디버그 세션을 종료할 때 디버그 콘솔을 자동으로 닫을지를 제어합니다.
  "debug.console.closeOnEnd": false,

  // 디버그 콘솔에서 같은 줄을 축소하고 발생 횟수를 배지로 표시해야 할지를 제어합니다.
  "debug.console.collapseIdenticalLines": true,

  // 디버그 콘솔에서 글꼴 패밀리를 제어합니다.
  "debug.console.fontFamily": "default",

  // 디버그 콘솔에서 글꼴 크기(픽셀)를 제어합니다.
  "debug.console.fontSize": 14,

  // 디버그 콘솔에서 이전에 입력한 항목을 제안할지 여부를 제어합니다.
  "debug.console.historySuggestions": true,

  // 디버그 콘솔에서 줄 높이(픽셀)를 제어합니다. 글꼴 크기에서 줄 높이를 계산하려면 0을 사용합니다.
  "debug.console.lineHeight": 0,

  // 디버그 콘솔에서 최대 줄 수를 제어합니다.
  "debug.console.maximumLines": 10000,

  // 디버그 콘솔에서 줄을 자동으로 바꿀지를 제어합니다.
  "debug.console.wordWrap": true,

  // 디스어셈블리 뷰에서 소스 코드를 표시합니다.
  "debug.disassemblyView.showSourceCode": true,

  // 디버거가 활성화된 경우 상태 표시줄의 색입니다.
  "debug.enableStatusBarColor": true,

  // 디버거가 중단될 때 편집기에 초점을 맞출지 여부를 제어합니다.
  "debug.focusEditorOnBreak": true,

  // 디버거가 중단될 때 워크벤치 창이 포커스를 받을지 여부를 제어합니다.
  "debug.focusWindowOnBreak": true,

  // 마우스 가운데 단추로 편집기 여백을 클릭할 때 수행할 작업을 제어합니다.
  //  - logpoint: Logpoint를 추가합니다.
  //  - conditionalBreakpoint: 조건부 중단점을 추가합니다.
  //  - triggeredBreakpoint: 트리거된 중단점을 추가합니다.
  //  - none: 아무 작업도 수행하지 마세요.
  "debug.gutterMiddleClickAction": "logpoint",

  // 디버깅이 활성화된 동안 '실행 및 디버그' 보기의 제목 표시줄에서 '디버깅 시작' 컨트롤을 숨깁니다. `debug.toolBarLocation`이(가) '도킹'되지 않은 경우에만 관련이 있습니다.
  "debug.hideLauncherWhileDebugging": false,

  // `preLaunchTask`가 한동안 실행 중일 때 표시되는 경고를 숨깁니다.
  "debug.hideSlowPreLaunchWarning": false,

  // 디버그하는 동안 편집기에서 변수 값을 인라인으로 표시합니다.
  //  - on: 디버그하는 동안 편집기에서 변수 값을 인라인으로 항상 표시합니다.
  //  - off: 디버그하는 동안 편집기에서 변수 값을 인라인으로 표시하지 않습니다.
  //  - auto: 언어에서 인라인 값 위치를 지원하는 경우 디버깅하는 동안 변수 값을 편집기에 인라인으로 표시합니다.
  "debug.inlineValues": "auto",

  // 내부 디버그 콘솔을 열어야 할 경우를 제어합니다.
  "debug.internalConsoleOptions": "openOnFirstSessionStart",

  // preLaunchTask를 실행한 후 오류가 발생할 때 수행할 작업을 제어합니다.
  //  - debugAnyway: 작업 오류를 무시하고 디버깅을 시작합니다.
  //  - showErrors: 문제 보기를 표시하고 디버깅을 시작하지 않습니다.
  //  - prompt: 프롬프트 사용자입니다.
  //  - abort: 디버깅을 취소합니다.
  "debug.onTaskErrors": "prompt",

  // 디버그 보기를 열 경우를 제어합니다.
  "debug.openDebug": "openOnDebugBreak",

  // 디버그 세션 끝에 자동으로 탐색기 뷰를 엽니다.
  "debug.openExplorerOnEnd": false,

  // 디버그 세션을 시작하기 전에 저장할 편집기를 제어합니다.
  //  - allEditorsInActiveGroup: 디버그 세션을 시작하기 전에 모든 편집기를 활성 그룹에 저장합니다.
  //  - nonUntitledEditorsInActiveGroup: 디버그 세션을 시작하기 전에 제목이 없는 편집기를 제외한 모든 편집기를 활성 그룹에 저장합니다.
  //  - none: 디버그 세션을 시작하기 전에 편집기를 저장하지 않습니다.
  "debug.saveBeforeStart": "allEditorsInActiveGroup",

  // 중단점을 개요 눈금자에 표시할지 여부를 제어합니다.
  "debug.showBreakpointsInOverviewRuler": false,

  // 디버깅하는 동안 인라인 중단점 후보 장식을 편집기에 표시할지 여부를 제어합니다.
  "debug.showInlineBreakpointCandidates": true,

  // 디버그 상태 표시줄을 표시할 경우를 제어합니다.
  //  - never: 상태 표시줄에 디버그 표시 안 함
  //  - always: 상태 표시줄에 디버그 항상 표시
  //  - onFirstSessionStart: 디버그를 처음으로 시작한 후에만 상태 표시줄에 디버그 표시
  "debug.showInStatusBar": "onFirstSessionStart",

  // 디버그 도구 모음에서 디버그 하위 세션을 표시할지 여부를 제어합니다. 이 설정이 false이면 하위 세션의 중지 명령이 부모 세션도 중지합니다.
  "debug.showSubSessionsInToolBar": false,

  // 디버그 세션 중 변수 창에 변수 형식 표시
  "debug.showVariableTypes": false,

  // 통합 또는 외부 터미널에서 새 디버그 세션을 시작하기 전에 터미널을 지우세요.
  "debug.terminal.clearBeforeReusing": false,

  // 디버그 도구 모음의 위치를 제어합니다. '부동'(모든 뷰), '고정'(디버그 뷰), 'commandCenter'(`window.commandCenter` 필요) 또는 '숨김'입니다.
  //  - floating: 모든 보기에서 디버그 도구 모음을 표시합니다.
  //  - docked: 디버그 보기에만 디버그 도구 모음을 표시합니다.
  //  - commandCenter: '(실험적)' 명령 센터에 디버그 도구 모음을 표시합니다.
  //  - hidden: 디버그 도구 모음을 표시하지 않습니다.
  "debug.toolBarLocation": "floating",

  // 전역 디버그 시작 구성입니다. 작업 영역에서 공유되는 'launch.json' 대신 사용되어야 합니다.
  "launch": {
    "configurations": [],
    "compounds": []
  },

  // 스레드가 확인될 때 주석 스레드를 축소할지 여부를 제어합니다.
  "comments.collapseOnResolve": true,

  // 주석 위젯이 스크롤되거나 확장되는지 여부를 제어합니다.
  "comments.maxHeight": true,

  // 이 설정은 'comments.openView'를 위해 사용되지 않습니다.
  // 주석 패널을 열어야 하는 경우를 제어합니다.
  "comments.openPanel": "openOnSessionStartWithComments",

  // 주석 뷰를 열어야 하는 시기를 제어합니다.
  //  - never: 주석 보기는 열리지 않습니다.
  //  - file: 메모가 있는 파일이 활성 상태이면 메모 보기가 열립니다.
  //  - firstFile: 이 세션 중에 메모 보기가 아직 열리지 않은 경우 메모가 있는 파일이 활성 상태인 세션 중에 처음으로 열립니다.
  //  - firstFileUnresolved: 이 세션 중에 주석 보기가 아직 열리지 않았고 주석이 해결되지 않은 경우 주석이 있는 파일이 활성 상태인 세션 중에 처음으로 열립니다.
  "comments.openView": "firstFile",

  // 주석 스레드를 축소할 때 확인 대화 상자를 표시할지 여부를 제어합니다.
  //  - whenHasUnsubmittedComments: 제출되지 않은 주석이 있는 주석 스레드를 축소할 때 확인 대화 상자를 표시합니다.
  //  - never: 주석 스레드를 축소할 때 확인 대화 상자를 표시하지 않습니다.
  "comments.thread.confirmOnCollapse": "whenHasUnsubmittedComments",

  // 상대 시간이 메모 타임스탬프(예: '1일 전')에 사용될지 여부를 결정합니다.
  "comments.useRelativeTime": true,

  // 댓글 범위 및 댓글이 있는 편집기에서 댓글 표시줄 및 댓글 스레드의 표시 여부를 제어합니다. 댓글은 여전히 ​​댓글 보기를 통해 액세스할 수 있으며 "댓글: 편집기 댓글 달기 전환" 명령을 실행하여 댓글을 토글하는 것과 같은 방식으로 댓글이 켜집니다.
  "comments.visible": true,

  // HTML 태그의 자동 닫기를 사용하거나 사용하지 않습니다.
  "html.autoClosingTags": true,

  // HTML 속성 할당을 위한 따옴표 자동 생성을 사용하도록/사용하지 않도록 설정합니다. 따옴표의 유형은 `html.completion.attributeDefaultValue`로 구성할 수 있습니다.
  "html.autoCreateQuotes": true,

  // 완료가 수락되는 경우 특성의 기본값을 제어합니다.
  //  - doublequotes: 특성 값이 ""(으)로 설정됩니다.
  //  - singlequotes: 특성 값이 ''(으)로 설정되어 있습니다.
  //  - empty: 특성 값이 설정되지 않았습니다.
  "html.completion.attributeDefaultValue": "doublequotes",

  // [사용자 지정 데이터 형식](https://github.com/microsoft/vscode-html-languageservice/blob/master/docs/customData.md)에 따라 JSON 파일을 가리키는 상대 파일 경로의 목록입니다.
  //
  // VS Code는 시작 시 사용자 지정 데이터를 로드하여 JSON 파일에 지정하는 사용자 지정 HTML 태그, 특성 및 특성 값에 대한 HTML 지원을 향상합니다.
  //
  // 파일 경로는 작업 영역에 상대적이며 작업 영역 폴더 설정만 고려됩니다.
  "html.customData": [],

  // 쉼표로 분리된 태그 목록으로, 콘텐츠의 서식을 다시 지정해서는 안 됩니다. 'pre' 태그의 기본값은 'null'로 설정됩니다.
  "html.format.contentUnformatted": "pre,code,textarea",

  // 기본 HTML 포맷터를 사용하거나 사용하지 않도록 설정합니다.
  "html.format.enable": true,

  // 쉼표로 분리된 태그 목록으로 앞에 줄 바꿈을 추가로 넣어야 합니다. '"head, body, /html"'의 기본값은 'null'로 설정됩니다.
  "html.format.extraLiners": "head, body, /html",

  // `{{#foo}}` 및 `{{/foo}}`를 서식 지정하고 들여쓰기합니다.
  "html.format.indentHandlebars": false,

  // '<head>' 및 '<body>' 섹션을 들여씁니다.
  "html.format.indentInnerHtml": false,

  // 청크 한 개에 유지할 수 있는 최대 줄 바꿈 수입니다. 무제한일 때는 'null'을 사용합니다.
  "html.format.maxPreserveNewLines": null,

  // 요소 앞에 있는 기존 줄 바꿈을 유지해야 하는지 제어합니다. 요소 앞에만 적용되며 태그 안에서나 텍스트에는 적용되지 않습니다.
  "html.format.preserveNewLines": true,

  // django, erb, handlebars 및 php 템플릿 언어 태그를 사용합니다.
  "html.format.templating": false,

  // 쉼표로 분리된 태그 목록으로, 서식을 다시 지정해서는 안 됩니다. https://www.w3.org/TR/html5/dom.html#phrasing-content에 나열된 모든 태그의 기본값은 'null'로 설정됩니다.
  "html.format.unformatted": "wbr",

  // 이 문자열 간에 텍스트 콘텐츠를 함께 유지합니다.
  "html.format.unformattedContentDelimiter": "",

  // 특성을 래핑합니다.
  //  - auto: 줄 길이를 초과하는 경우에만 특성을 래핑합니다.
  //  - force: 첫 번째 특성을 제외한 각 특성을 래핑합니다.
  //  - force-aligned: 첫 번째 특성을 제외한 각 특성을 래핑하고 정렬된 상태를 유지합니다.
  //  - force-expand-multiline: 각 특성을 래핑합니다.
  //  - aligned-multiple: 줄 길이를 초과하는 경우 줄 바꿈하여 특성을 세로로 정렬합니다.
  //  - preserve: 특성 줄 바꿈을 유지합니다.
  //  - preserve-aligned: 특성의 줄 바꿈을 유지하되 정렬합니다.
  "html.format.wrapAttributes": "auto",

  // 래핑된 속성을 N자 이후로 들여씁니다. 기본 들여쓰기 크기를 사용하려면 'null'을 사용하세요. `html.format.wrapAttributes`가 `aligned`(정렬)로 설정된 경우 무시됩니다.
  "html.format.wrapAttributesIndentSize": null,

  // 한 줄당 최대 문자 수입니다(0 = 사용 안 함).
  "html.format.wrapLineLength": 120,

  // 가리킬 때 태그 및 특성 설명서를 표시합니다.
  "html.hover.documentation": true,

  // 가리킬 때 MDN에 대한 참조를 표시합니다.
  "html.hover.references": true,

  // 사용되지 않으며, 대신 `editor.linkedEditing`이 사용됩니다.
  // 일치하는 HTML 태그에서 미러링 커서를 활성화/비활성화합니다.
  "html.mirrorCursorOnMatchingTag": false,

  // 기본으로 제공하는 HTML 언어 지원에서 HTML5 태그와 속성 및 값을 제안할지 여부를 제어합니다.
  "html.suggest.html5": true,

  // VS Code와 HTML 언어 서버 간 통신을 추적합니다.
  "html.trace.server": "off",

  // 기본으로 제공하는 HTML 언어 지원에서 포함된 스크립트 유효성을 검사할지 여부를 제어합니다.
  "html.validate.scripts": true,

  // 기본으로 제공하는 HTML 언어 지원에서 포함된 스타일의 유효성을 검사할지 여부를 제어합니다.
  "html.validate.styles": true,

  // `json.colorDecorators.enable` 설정은 `editor.colorDecorators`를 위해 사용되지 않습니다.
  // 색 데코레이터 사용 또는 사용 안 함
  "json.colorDecorators.enable": true,

  // 기본 JSON 포맷터를 사용하거나 사용하지 않습니다.
  "json.format.enable": true,

  // 서식을 지정할 때 기존의 모든 새 줄을 유지합니다.
  "json.format.keepLines": false,

  // 계산된 최대 윤곽선 기호 및 폴딩 영역의 수입니다(성능상의 이유로 제한됨).
  "json.maxItemsComputed": 5000,

  // 사용하도록 설정하면 http 및 https 위치에서 JSON 스키마를 페치할 수 있습니다.
  "json.schemaDownload.enable": true,

  // 현재 프로젝트에서 스키마를 JSON 파일에 연결합니다.
  "json.schemas": [],

  // VS Code와 JSON 언어 서버 간 통신을 추적합니다.
  "json.trace.server": "off",

  // JSON 유효성 검사를 사용하거나 사용하지 않도록 설정합니다.
  "json.validate.enable": true,

  // 복사/붙여넣기 또는 끌어서 놓기로 만든 파일의 경로와 파일 이름을 설정합니다. 새 파일을 만들어야 하는 대상 경로에 대한 Markdown 문서 경로와 일치하는 GLOB 맵입니다.
  //
  // 대상 경로는 다음 변수를 사용할 수 있습니다.
  //
  // - '${documentDirName}' — Markdown 문서의 절대 부모 디렉터리 경로입니다(예: '/Users/me/myProject/docs').
  // - '${documentRelativeDirName}' — Markdown 문서의 상대 부모 디렉터리 경로입니다(예: 'docs'). 파일이 작업 영역의 일부가 아닌 경우 '${documentDirName}'과(와) 동일합니다.
  // - '${documentFileName}' — Markdown 문서의 전체 파일 이름입니다(예: 'README.md').
  // - '${documentBaseName}' — Markdown 문서의 기본 이름입니다(예: 'README').
  // - '${documentExtName}' — Markdown 문서의 확장입니다(예: 'md').
  // - '${documentFilePath}' — Markdown 문서의 절대 경로입니다(예: '/Users/me/myProject/docs/README.md').
  // - '${documentRelativeFilePath}' — Markdown 문서의 상대 경로입니다(예: 'docs/README.md'). 파일이 작업 영역의 일부가 아닌 경우 '${documentFilePath}'과(와) 동일합니다.
  // - '${documentWorkspaceFolder}' — Markdown 문서의 작업 영역 폴더입니다(예: '/Users/me/myProject'). 파일이 작업 영역의 일부가 아닌 경우 '${documentDirName}'과(와) 동일합니다.
  // - '${fileName}' — 삭제된 파일의 파일 이름입니다(예: 'image.png').
  // - '${fileExtName}' — 삭제된 파일의 확장명입니다(예: 'png').
  // - '${unixTime}' - 현재 Unix 타임스탬프입니다(밀리초 단위).
  // - '${isoTime}' — ISO 8601 형식의 현재 시간입니다(예: '2025-06-06T08:40:32.123Z').
  "markdown.copyFiles.destination": {},

  // 놓기 또는 붙여넣기로 만든 파일이 기존 파일을 덮어쓸지 여부를 제어합니다.
  //  - nameIncrementally: 이름이 같은 파일이 이미 있는 경우 파일 이름에 숫자를 추가합니다(예: 'image.png'는 'image-1.png'가 됩니다.).
  //  - overwrite: 이름이 같은 파일이 이미 있는 경우 덮어씁니다.
  "markdown.copyFiles.overwriteBehavior": "nameIncrementally",

  // Markdown 편집기에 놓인 작업 영역 외부의 파일을 작업 영역으로 복사할지 여부를 제어합니다.
  //
  // `markdown.copyFiles.destination`을 사용하여 복사한 파일을 만들 위치를 구성합니다.
  //  - mediaFiles: 외부 이미지 및 비디오 파일을 작업 영역에 복사해 봅니다.
  //  - never: 외부 파일을 작업 영역에 복사하지 마세요.
  "markdown.editor.drop.copyIntoWorkspace": "mediaFiles",

  // Shift 키를 누른 상태에서 Markdown 편집기에 파일 놓기를 설정합니다. '#editor.dropIntoEditor.enabled#'을 사용하도록 설정해야 합니다.
  //  - always: 항상 Markdown 링크를 삽입합니다.
  //  - smart: 코드 블록 또는 다른 특수 요소에 드롭하지 않을 때 기본적으로 Markdown 링크를 스마트하게 만듭니다. 드롭 위젯을 사용하여 일반 텍스트로 붙여넣기 또는 Markdown 링크로 붙여넣기 간에 전환합니다.
  //  - never: Markdown 링크를 만들지 않습니다.
  "markdown.editor.drop.enabled": "smart",

  // Markdown에 오디오를 추가할 때 사용되는 코드 조각입니다. 이 코드 조각은 다음 변수를 사용할 수 있습니다.
  // - `${src}` - 오디오 파일의 확인된 경로입니다.
  // - `${title}` - 오디오에 사용되는 제목입니다. 이 변수에 대한 코드 조각 자리 표시자가 자동으로 만들어집니다.
  "markdown.editor.filePaste.audioSnippet": "<audio controls src=\"${src}\" title=\"${title}\"></audio>",

  // Markdown 편집기에 붙여넣은 작업 영역 외부의 파일을 작업 영역으로 복사할지 여부를 제어합니다.
  //
  // `markdown.copyFiles.destination`을 사용하여 복사한 파일을 만들 위치를 구성합니다.
  //  - mediaFiles: 외부 이미지 및 비디오 파일을 작업 영역에 복사해 봅니다.
  //  - never: 외부 파일을 작업 영역에 복사하지 마세요.
  "markdown.editor.filePaste.copyIntoWorkspace": "mediaFiles",

  // Markdown 편집기에 파일을 붙여넣어 Markdown 링크를 만들 수 있습니다. `#editor.pasteAs.enabled#를 활성화해야 합니다.
  //  - always: 항상 Markdown 링크를 삽입합니다.
  //  - smart: 코드 블록 또는 다른 특수 요소에 붙여넣지 않을 때 기본적으로 Markdown 링크를 스마트하게 만듭니다. 붙여넣기 위젯을 사용하여 일반 텍스트로 붙여넣기 또는 Markdown 링크로 붙여넣기 간에 전환합니다.
  //  - never: Markdown 링크를 만들지 않습니다.
  "markdown.editor.filePaste.enabled": "smart",

  // Markdown에 비디오를 추가할 때 사용되는 코드 조각입니다. 이 코드 조각은 다음 변수를 사용할 수 있습니다.
  // - `${src}` - 비디오 파일의 확인된 경로입니다.
  // - `${title}` - 비디오에 사용되는 제목입니다. 이 변수에 대한 코드 조각 자리 표시자가 자동으로 만들어집니다.
  "markdown.editor.filePaste.videoSnippet": "<video controls src=\"${src}\" title=\"${title}\"></video>",

  // URL을 Markdown 편집기에 붙여넣을 때 Markdown 링크가 만들어지는지 여부를 제어합니다. '#editor.pasteAs.enabled#'을 사용하도록 설정해야 합니다.
  //  - always: 항상 Markdown 링크를 삽입합니다.
  //  - smart: 코드 블록 또는 다른 특수 요소에 붙여넣지 않을 때 기본적으로 Markdown 링크를 스마트하게 만듭니다. 붙여넣기 위젯을 사용하여 일반 텍스트로 붙여넣기 또는 Markdown 링크로 붙여넣기 간에 전환합니다.
  //  - smartWithSelection: 텍스트를 선택했고 코드 블록이나 기타 특수 요소에 붙여넣지 않는 경우 기본적으로 스마트 Markdown 링크를 생성합니다. 붙여넣기 위젯을 사용하여 일반 텍스트로 붙여넣기 또는 Markdown 링크로 붙여넣기 간에 전환합니다.
  //  - never: Markdown 링크를 만들지 않습니다.
  "markdown.editor.pasteUrlAsFormattedLink.enabled": "smartWithSelection",

  // Markdown 편집기 간에 복사하여 붙여넣은 텍스트의 링크 및 참조를 업데이트하는 붙여넣기 옵션을 사용/사용 안 함으로 설정합니다.
  //
  // 이 기능을 사용하려면 업데이트 가능한 링크가 포함된 텍스트를 붙여넣은 후 붙여넣기 위젯을 클릭하고 '붙여넣은 링크 붙여넣기 및 업데이트'를 선택하기만 하면 됩니다.
  "markdown.editor.updateLinksOnPaste.enabled": true,

  // Markdown 파일의 링크를 열어야 하는 위치를 제어합니다.
  //  - currentGroup: 활성 편집기 그룹에서 링크를 엽니다.
  //  - beside: 활성 편집기 옆에 있는 링크를 엽니다.
  "markdown.links.openLocation": "currentGroup",

  // 현재 문서에서 링크 항목 강조 표시를 사용하도록 설정합니다.
  "markdown.occurrencesHighlight.enabled": false,

  // markdown 파일 링크에 파일 확장명(예: `.md`)이 추가되는지 여부를 제어합니다. 이 설정은 경로 완성 또는 파일 이름 바꾸기와 같은 도구를 사용하여 파일 경로를 추가할 때 사용됩니다.
  //  - auto: 기존 경로인 경우 파일 확장명 형식을 유지하려고 합니다. 새 경로인 경우 파일 확장명을 추가합니다.
  //  - includeExtension: 파일 확장명 포함을 선호합니다. 예를 들어 이름이 `file.md`인 파일에 대한 경로 완성은 `file.md`를 삽입합니다.
  //  - removeExtension: 파일 확장명 제거를 선호합니다. 예를 들어 이름이 `file.md`인 파일에 대한 경로 완성은 `.md` 없이 `file`을 삽입합니다.
  "markdown.preferredMdPathExtensionStyle": "auto",

  // Markdown 미리 보기에서 줄 바꿈을 렌더링하는 방식을 설정합니다. 'true'로 설정하면 단락 안의 줄 바꿈에 대해 '<br>'이(가) 생성됩니다.
  "markdown.preview.breaks": false,

  // Markdown 미리 보기에서 두 번 클릭하여 편집기로 전환합니다.
  "markdown.preview.doubleClickToSwitchToEditor": true,

  // Markdown 미리 보기에서 사용되는 글꼴 패밀리를 제어합니다.
  "markdown.preview.fontFamily": "-apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif",

  // Markdown 미리 보기에서 사용되는 글꼴 크기(픽셀)를 제어합니다.
  "markdown.preview.fontSize": 14,

  // Markdown 미리 보기에 사용되는 줄 높이를 제어합니다. 이 숫자는 글꼴 크기에 상대적입니다.
  "markdown.preview.lineHeight": 1.6,

  // Markdown 미리 보기에서 URL과 유사한 텍스트를 링크로 변환합니다.
  "markdown.preview.linkify": true,

  // Markdown 미리 보기에 현재 편집기 선택을 표시합니다.
  "markdown.preview.markEditorSelection": true,

  // Markdown 미리 보기에서 다른 Markdown 파일의 링크를 여는 방법을 제어합니다.
  //  - inPreview: Markdown 미리 보기에서 링크를 열어 보세요.
  //  - inEditor: 편집기에서 링크를 열어 보세요.
  "markdown.preview.openMarkdownLinks": "inPreview",

  // Markdown 미리 보기를 스크롤할 때 편집기의 보기를 업데이트합니다.
  "markdown.preview.scrollEditorWithPreview": true,

  // Markdown 편집기를 스크롤할 때 미리 보기의 보기를 업데이트합니다.
  "markdown.preview.scrollPreviewWithEditor": true,

  // Markdown 미리 보기에서 언어 중립적인 대체 및 인용 부호를 사용하도록 설정합니다.
  "markdown.preview.typographer": false,

  // Markdown 언어 서버의 로깅 수준을 제어합니다.
  "markdown.server.log": "off",

  // Markdown 미리 보기에서 사용할 CSS 스타일시트의 URL 또는 로컬 경로 목록입니다. 상대 경로는 Explorer에서 열린 폴더를 기준으로 해석됩니다. 열린 폴더가 없으면 Markdown 파일의 위치를 기준으로 해석됩니다. 모든 '\'는 '\\'로 써야 합니다.
  "markdown.styles": [],

  // Markdown 파일에서 링크를 작성하는 동안 경로 제안을 사용하도록 설정합니다.
  "markdown.suggest.paths.enabled": true,

  // 현재 작업 영역의 다른 Markdown 파일에서 헤더에 대한 제안을 사용하도록 설정합니다. 이러한 제안 중 하나를 수락하면 헤더 전체 경로(예: '[link text](/path/to/file.md#header)')가 해당 파일에 삽입됩니다.
  //  - never: 작업 영역 헤더 제안을 사용하지 않습니다.
  //  - onDoubleHash: 경로에 '##'을 입력한 후 작업 영역 헤더 제안을 사용합니다. 예: '[link text](##'.
  //  - onSingleOrDoubleHash: 경로에 '##' 또는 '#'을 입력한 후 작업 영역 헤더 제안을 사용합니다. 예: '[link text](#' 또는 '[link text](##'.
  "markdown.suggest.paths.includeWorkspaceHeaderCompletions": "onDoubleHash",

  // VS Code와 Markdown 언어 서버 간 통신을 추적합니다.
  "markdown.trace.server": "off",

  // 작업 영역에서 파일 이름 변경/이동 시 Markdown 파일의 링크를 업데이트해 보세요. 링크 업데이트를 트리거하는 파일을 구성하려면 `markdown.updateLinksOnFileMove.include`를 사용하세요.
  //  - prompt: 각 파일 이동에 대한 프롬프트입니다.
  //  - always: 링크를 항상 자동으로 업데이트합니다.
  //  - never: 링크를 업데이트하지 않고 메시지를 표시하지 마세요.
  "markdown.updateLinksOnFileMove.enabled": "never",

  // 작업 영역에서 디렉터리를 이동하거나 이름을 바꿀 때 링크를 업데이트할 수 있도록 설정합니다.
  "markdown.updateLinksOnFileMove.enableForDirectories": true,

  // 자동 링크 업데이트를 트리거하는 파일을 지정하는 GLOB 패턴입니다. 이 기능에 대한 자세한 내용은 '#markdown.updateLinksOnFileMove.enabled#'를 참조하세요.
  "markdown.updateLinksOnFileMove.include": [
    "**/*.{md,mkd,mdwn,mdown,markdown,markdn,mdtxt,mdtext,workbook}",
    "**/*.{jpg,jpe,jpeg,png,bmp,gif,ico,webp,avif,tiff,svg,mp4}"
  ],

  // 현재 파일에서 중복된 정의의 유효성을 검사합니다.
  "markdown.validate.duplicateLinkDefinitions.enabled": "warning",

  // Markdown 파일에서 모든 오류 보고를 사용하도록 설정합니다.
  "markdown.validate.enabled": false,

  // Markdown 파일에서 다른 파일로 연결되는 링크의 유효성을 검사합니다(예: `[link](/path/to/file.md)`). 이를 통해 대상 파일이 존재하는지 확인할 수 있습니다. `markdown.experimental.validate.enabled`를 사용하도록 설정해야 합니다.
  "markdown.validate.fileLinks.enabled": "warning",

  // Markdown 파일에서 다른 파일의 헤더로 연결되는 링크의 조각 부분 유효성을 확인합니다(예: `[link](/path/to/file.md#header)`). 기본적으로 `markdown.validate.fragmentLinks.enabled`에서 설정 값을 상속합니다.
  "markdown.validate.fileLinks.markdownFragmentLinks": "inherit",

  // 현재 Markdown 파일의 헤더로 연결되는 조각 링크의 유효성을 검사합니다(예: `[link](#header)`). `markdown.validate.enabled`를 사용하도록 설정해야 합니다.
  "markdown.validate.fragmentLinks.enabled": "warning",

  // 유효성을 검사하지 않아야 하는 링크를 구성합니다. 예를 들어 `/about` 추가는 `[about](/about)` 링크의 유효성을 검사하지 않으며, glob `/assets/**/*.svg`를 사용하면 `assets` 디렉터리 아래의 `.svg` 파일로 연결되는 모든 링크에 대한 유효성 검사를 건너뛸 수 있습니다.
  "markdown.validate.ignoredLinks": [],

  // Markdown 파일에서 참조 링크(예: `[link][ref]`)의 유효성을 검사합니다. `markdown.validate.enabled`를 사용하도록 설정해야 합니다.
  "markdown.validate.referenceLinks.enabled": "warning",

  // 현재 파일에서 사용되지 않는 링크 정의의 유효성을 검사합니다.
  "markdown.validate.unusedLinkDefinitions.enabled": "hint",

  // 기본 제공 PHP 언어 제안을 사용하는지 여부를 구성합니다. 지원에서는 PHP 전역 및 변수를 제안합니다.
  "php.suggest.basic": true,

  // 기본 제공 PHP 유효성 검사를 사용하거나 사용하지 않습니다.
  "php.validate.enable": true,

  // PHP 실행 파일을 가리킵니다.
  "php.validate.executablePath": null,

  // 저장 시 또는 입력 시 Linter의 실행 여부입니다.
  "php.validate.run": "onSave",

  // JSX 태그의 자동 닫기를 사용하거나 사용하지 않도록 설정합니다.
  "javascript.autoClosingTags": true,

  // 대신 ‘원본 정의로 이동’을 트리거하여 가능한 경우 ‘정의로 이동’ 작업이 유형 선언 파일을 사용하지 않도록 합니다. 이렇게 하면 ‘원본 정의로 이동’이 마우스 제스처로 트리거될 수 있습니다.
  "javascript.preferGoToSourceDefinition": false,

  // JavaScript 파일에서 CodeLense 참조를 사용/사용 안 함으로 설정합니다.
  "javascript.referencesCodeLens.enabled": false,

  // JavaScript 파일의 모든 기능에 대한 참조 CodeLens를 사용/사용하지 않도록 설정합니다.
  "javascript.referencesCodeLens.showOnAllFunctions": false,

  // 편집기에서 JavaScript 파일에 대한 제안 진단을 사용하거나 사용하지 않도록 설정합니다.
  "javascript.suggestionActions.enabled": true,

  // VS Code에서 파일을 이동하거나 이름을 바꿀 때 가져오기 경로의 자동 업데이트를 사용하거나 사용하지 않도록 설정합니다.
  //  - prompt: 이름을 바꿀 때마다 프롬프트를 표시합니다.
  //  - always: 항상 경로를 자동으로 업데이트합니다.
  //  - never: 경로 이름을 바꾸지 않고 메시지를 표시하지 않습니다.
  "javascript.updateImportsOnFileMove.enabled": "prompt",

  // 코드를 붙여넣을 때 가져오기를 자동으로 업데이트합니다. TypeScript 5.6+가 필요합니다.
  "javascript.updateImportsOnPaste.enabled": true,

  // JavaScript 유효성 검사를 사용하거나 사용하지 않습니다.
  "javascript.validate.enable": true,

  // 가리키기에서 최대 문자 수입니다. 가리키기 시간이 이보다 길면 잘립니다. TypeScript 5.9 이상이 필요합니다.
  "js/ts.hover.maximumLength": 500,

  // JavaScript 파일의 의미 체계 검사를 사용하거나 사용하지 않도록 설정합니다. 기존 `jsconfig.json` 또는 `tsconfig.json` 파일은 이 설정을 재정의합니다.
  "js/ts.implicitProjectConfig.checkJs": false,

  // 프로젝트의 일부가 아닌 JavaScript 파일에서 'experimentalDecorators'를 사용하거나 사용하지 않도록 설정합니다. 기존 `jsconfig.json` 또는 `tsconfig.json` 파일은 이 설정을 재정의합니다.
  "js/ts.implicitProjectConfig.experimentalDecorators": false,

  // 프로그램의 모듈 시스템을 설정합니다. 자세한 내용은 https://www.typescriptlang.org/tsconfig#module을 참조하세요.
  "js/ts.implicitProjectConfig.module": "ESNext",

  // 프로젝트의 일부가 아닌 JavaScript 및 TypeScript 파일에서 [strict 함수 형식](https://www.typescriptlang.org/tsconfig#strictFunctionTypes)을 사용하거나 사용하지 않도록 설정합니다. 기존 `jsconfig.json` 또는 `tsconfig.json` 파일은 이 설정을 재정의합니다.
  "js/ts.implicitProjectConfig.strictFunctionTypes": true,

  // 프로젝트의 일부가 아닌 JavaScript 및 TypeScript 파일에서 [strict null 검사](https://www.typescriptlang.org/tsconfig#strictNullChecks)를 사용하거나 사용하지 않도록 설정합니다. 기존 `jsconfig.json` 또는 `tsconfig.json` 파일은 이 설정을 재정의합니다.
  "js/ts.implicitProjectConfig.strictNullChecks": true,

  // 내보낸 JavaScript에 대한 대상 JavaScript 언어 버전을 설정하고 라이브러리 선언을 포함합니다. 자세한 내용은 https://www.typescriptlang.org/tsconfig#target을 참조하세요.
  "js/ts.implicitProjectConfig.target": "ES2022",

  // JSX 태그의 자동 닫기를 사용하거나 사용하지 않도록 설정합니다.
  "typescript.autoClosingTags": true,

  // [자동 형식 인식](https://code.visualstudio.com/docs/nodejs/working-with-javascript#_typings-and-automatic-type-acquisition)을 사용하지 않도록 설정합니다. 자동 형식 인식은 npm에서 '@types' 패키지를 가져와 외부 라이브러리에 대한 IntelliSense를 개선합니다.
  "typescript.disableAutomaticTypeAcquisition": false,

  // Intellisense 작업 영역에서 구성된 TypeScript 버전을 사용하라는 메시지를 사용자에게 표시할 수 있습니다.
  "typescript.enablePromptUseWorkspaceTsdk": false,

  // TypeScript Go 실험적 확장을 사용할 수 있도록 TypeScript 및 JavaScript 언어 기능을 비활성화합니다. TypeScript Go를 설치하고 구성해야 합니다. 이 설정을 변경한 후 확장을 다시 로드해야 합니다.
  "typescript.experimental.useTsgo": false,

  // CodeLens 구현을 사용하거나 사용하지 않습니다. 이 CodeLens는 인터페이스의 구현자를 표시합니다.
  "typescript.implementationsCodeLens.enabled": false,

  // 구현 인터페이스의 CodeLens 메서드를 활성화/비활성화합니다.
  "typescript.implementationsCodeLens.showOnInterfaceMethods": false,

  // JavaScript 및 TypeScript 오류를 보고하는 데 사용되는 로케일을 설정합니다. 기본값은 VS Code의 로케일을 사용하는 것입니다.
  //  - auto: VS Code의 구성된 표시 언어 사용
  //  - de: Deutsch
  //  - es: español
  //  - en: English
  //  - fr: français
  //  - it: italiano
  //  - ja: 日本語
  //  - ko: 한국어
  //  - ru: русский
  //  - zh-CN: 中文(简体)
  //  - zh-TW: 中文(繁體)
  "typescript.locale": "auto",

  // 대신 ‘원본 정의로 이동’을 트리거하여 가능한 경우 ‘정의로 이동’ 작업이 유형 선언 파일을 사용하지 않도록 합니다. 이렇게 하면 ‘원본 정의로 이동’이 마우스 제스처로 트리거될 수 있습니다.
  "typescript.preferGoToSourceDefinition": false,

  // TypeScript 파일에서 참조 CodeLens를 사용하거나 사용하지 않도록 설정합니다.
  "typescript.referencesCodeLens.enabled": false,

  // TypeScript 파일의 모든 기능에 대한 참조 CodeLens를 사용/사용하지 않도록 설정합니다.
  "typescript.referencesCodeLens.showOnAllFunctions": false,

  // 스타일 검사를 경고로 보고합니다.
  "typescript.reportStyleChecksAsWarnings": true,

  // 편집기에서 TypeScript 파일에 대한 제안 진단을 사용하거나 사용하지 않도록 설정합니다.
  "typescript.suggestionActions.enabled": true,

  // tsc 작업의 자동 검색을 제어합니다.
  //  - on: 빌드 및 조사식 작업을 모두 만듭니다.
  //  - off: 이 기능을 사용하지 않도록 설정합니다.
  //  - build: 단일 실행 컴파일 작업만 만듭니다.
  //  - watch: 컴파일 및 조사식 작업만 만듭니다.
  "typescript.tsc.autoDetect": "on",

  // IntelliSense에 사용할 TypeScript 설치에서 tsserver 및 `lib*.d.ts` 파일의 폴더 경로를 지정합니다. 예: `./node_modules/typescript/lib`.
  //
  // - 사용자 설정으로 지정한 경우 'typescript.tsdk'의 TypeScript 버전이 자동으로 기본 제공 TypeScript 버전을 바꿉니다.
  // - 작업 영역 설정으로 지정한 경우 'typescript.tsdk'를 사용하여 'TypeScript: TypeScript 버전 선택' 명령으로 IntelliSense용 TypeScript의 해당 작업 영역 버전을 사용하도록 전환할 수 있습니다.
  //
  // TypeScript 버전 관리에 대한 자세한 내용은 [TypeScript 설명서](https://code.visualstudio.com/docs/typescript/typescript-compiling#_using-newer-typescript-versions)를 참조하세요.
  "typescript.tsdk": "",

  // TypeScript에서 지역 기반 진단을 사용하도록 설정합니다. 작업 영역에서 TypeScript 5.6 이상을 사용해야 합니다.
  "typescript.tsserver.enableRegionDiagnostics": true,

  // VS Code에서 파일을 이동하거나 이름을 바꿀 때 가져오기 경로의 자동 업데이트를 사용하거나 사용하지 않도록 설정합니다.
  //  - prompt: 이름을 바꿀 때마다 프롬프트를 표시합니다.
  //  - always: 항상 경로를 자동으로 업데이트합니다.
  //  - never: 경로 이름을 바꾸지 않고 메시지를 표시하지 않습니다.
  "typescript.updateImportsOnFileMove.enabled": "prompt",

  // 코드를 붙여넣을 때 가져오기를 자동으로 업데이트합니다. TypeScript 5.6+가 필요합니다.
  "typescript.updateImportsOnPaste.enabled": true,

  // TypeScript 유효성 검사를 사용하거나 사용하지 않습니다.
  "typescript.validate.enable": true,

  // ‘Go to Symbol in Workspace(작업 영역에서 기호로 이동)’ 결과의 라이브러리 파일에서 가져온 기호를 제외합니다. 작업 영역에서 TypeScript 5.3+를 사용해야 합니다.
  "typescript.workspaceSymbols.excludeLibrarySymbols": true,

  // [작업 영역에서 기호로 이동](https://code.visualstudio.com/docs/editor/editingevolved#_open-symbol-by-name)하여 검색할 파일을 제어합니다.
  //  - allOpenProjects: 열려 있는 모든 JavaScript 또는 TypeScript 프로젝트에서 기호를 검색합니다.
  //  - currentProject: 현재 JavaScript 또는 TypeScript 프로젝트에서만 기호를 검색합니다.
  "typescript.workspaceSymbols.scope": "allOpenProjects",

  // 자동 가져오기에서 제외할 파일의 GLOB 패턴을 지정합니다. 상대 경로는 작업 영역 루트를 기준으로 확인됩니다. 패턴은 tsconfig.json ['exclude'](https://www.typescriptlang.org/tsconfig#exclude) 의미 체계를 사용하여 평가됩니다.
  "javascript.preferences.autoImportFileExcludePatterns": [],

  // 일치하는 가져오기 지정자를 사용하여 자동 가져오기를 제외할 정규식을 지정합니다. 예:
  //
  // - `^node:`
  // - 'lib/internal'(슬래시는 이스케이프할 필요가 없습니다.)
  // - '/lib\/internal/i'(... 'i' 또는 'u' 플래그에 주변 슬래시를 포함하지 않는 한)
  // - '^lodash$'(lodash에서 하위 경로 가져오기만 허용)
  "javascript.preferences.autoImportSpecifierExcludeRegexes": [],

  // 자동 가져오기의 기본 경로 스타일입니다.
  //  - shortest: 상대적 가져오기보다 적은 경로 세그먼트가 포함된 가져오기가 사용 가능한 경우에만 상대적이지 않은 가져오기를 사용합니다.
  //  - relative: 가져온 파일 위치의 상대 경로를 사용합니다.
  //  - non-relative: `jsconfig.json` / `tsconfig.json`에 구성된 `baseUrl` 또는 `paths`를 기반으로 상대적이지 않은 가져오기를 사용합니다.
  //  - project-relative: 상대 가져오기 경로가 패키지 또는 프로젝트 디렉터리를 벗어나는 경우에만 비 상대 가져오기를 선호합니다.
  "javascript.preferences.importModuleSpecifier": "shortest",

  // 자동 가져오기를 위한 기본 경로 끝자리.
  //  - auto: 프로젝트 설정을 사용하여 기본값을 선택합니다.
  //  - minimal: `./component/index.js`를 `./component`로 줄입니다.
  //  - index: `./component/index.js`를 `./component/index`로 줄입니다.
  //  - js: 경로 끝부분을 줄이지 마세요. `.js` 또는 `.ts` 확장명을 포함하세요.
  "javascript.preferences.importModuleSpecifierEnding": "auto",

  // JSX 특성 완성에 선호되는 스타일입니다.
  //  - auto: prop 유형을 기준으로 특성 이름 뒤에 `={}` 또는 `=""`를 삽입합니다. 문자열 특성에 사용되는 따옴표 형식을 제어하려면 '#javascript.preferences.quoteStyle#'을 참조하세요.
  //  - braces: 속성 이름 뒤에 `={}`를 삽입하세요.
  //  - none: 특성 이름만 삽입하세요.
  "javascript.preferences.jsxAttributeCompletionStyle": "auto",

  // 가져오기 순서 지정 방법을 제어하는 고급 기본 설정입니다.
  "javascript.preferences.organizeImports": {},

  // 빠른 수정에 사용할 기본 견적 스타일입니다.
  //  - auto: 기존 코드에서 따옴표 형식 유추
  //  - single: 항상 작은따옴표(`'`) 사용
  //  - double: 항상 큰따옴표(`"`) 사용
  "javascript.preferences.quoteStyle": "auto",

  // JSX 태그에서 기호 이름을 바꾸는 대신 일치하는 태그의 이름을 바꾸세요. 작업 영역에서 TypeScript 5.1 이상을 사용해야 합니다.
  "javascript.preferences.renameMatchingJsxTags": true,

  // 이름을 바꾸는 동안 개체 줄임 속성의 별칭 소개를 사용하거나 사용하지 않도록 설정합니다.
  "javascript.preferences.useAliasesForRenames": true,

  // 자동 가져오기에서 제외할 파일의 GLOB 패턴을 지정합니다. 상대 경로는 작업 영역 루트를 기준으로 확인됩니다. 패턴은 tsconfig.json ['exclude'](https://www.typescriptlang.org/tsconfig#exclude) 의미 체계를 사용하여 평가됩니다.
  "typescript.preferences.autoImportFileExcludePatterns": [],

  // 일치하는 가져오기 지정자를 사용하여 자동 가져오기를 제외할 정규식을 지정합니다. 예:
  //
  // - `^node:`
  // - 'lib/internal'(슬래시는 이스케이프할 필요가 없습니다.)
  // - '/lib\/internal/i'(... 'i' 또는 'u' 플래그에 주변 슬래시를 포함하지 않는 한)
  // - '^lodash$'(lodash에서 하위 경로 가져오기만 허용)
  "typescript.preferences.autoImportSpecifierExcludeRegexes": [],

  // 자동 가져오기의 기본 경로 스타일입니다.
  //  - shortest: 상대적 가져오기보다 적은 경로 세그먼트가 포함된 가져오기가 사용 가능한 경우에만 상대적이지 않은 가져오기를 사용합니다.
  //  - relative: 가져온 파일 위치의 상대 경로를 사용합니다.
  //  - non-relative: `jsconfig.json` / `tsconfig.json`에 구성된 `baseUrl` 또는 `paths`를 기반으로 상대적이지 않은 가져오기를 사용합니다.
  //  - project-relative: 상대 가져오기 경로가 패키지 또는 프로젝트 디렉터리를 벗어나는 경우에만 비 상대 가져오기를 선호합니다.
  "typescript.preferences.importModuleSpecifier": "shortest",

  // 자동 가져오기를 위한 기본 경로 끝자리.
  //  - auto: 프로젝트 설정을 사용하여 기본값을 선택합니다.
  //  - minimal: `./component/index.js`를 `./component`로 줄입니다.
  //  - index: `./component/index.js`를 `./component/index`로 줄입니다.
  //  - js: 경로 끝부분을 줄이지 마세요. `.js` 또는 `.ts` 확장명을 포함하세요.
  "typescript.preferences.importModuleSpecifierEnding": "auto",

  // 사용할 수 있는 자동 가져오기 기능의 'package.json' 종속성을 검색하도록/하지 않도록 설정합니다.
  //  - auto: 예상 성능 영향에 따라 종속성을 검색합니다.
  //  - on: 종속성을 항상 검색합니다.
  //  - off: 종속성을 검색하지 않습니다.
  "typescript.preferences.includePackageJsonAutoImports": "auto",

  // JSX 특성 완성에 선호되는 스타일입니다.
  //  - auto: prop 유형을 기준으로 특성 이름 뒤에 `={}` 또는 `=""`를 삽입합니다. 문자열 특성에 사용되는 따옴표 형식을 제어하려면 '#typescript.preferences.quoteStyle#'을 참조하세요.
  //  - braces: 속성 이름 뒤에 `={}`를 삽입하세요.
  //  - none: 특성 이름만 삽입하세요.
  "typescript.preferences.jsxAttributeCompletionStyle": "auto",

  // 가져오기 순서 지정 방법을 제어하는 고급 기본 설정입니다.
  "typescript.preferences.organizeImports": {},

  // 가능한 경우 항상 자동 가져오기에 `type` 키워드를 포함합니다. 작업 영역에서 TypeScript 5.3 이상을 사용해야 합니다.
  "typescript.preferences.preferTypeOnlyAutoImports": false,

  // 빠른 수정에 사용할 기본 견적 스타일입니다.
  //  - auto: 기존 코드에서 따옴표 형식 유추
  //  - single: 항상 작은따옴표(`'`) 사용
  //  - double: 항상 큰따옴표(`"`) 사용
  "typescript.preferences.quoteStyle": "auto",

  // JSX 태그에서 기호 이름을 바꾸는 대신 일치하는 태그의 이름을 바꾸세요. 작업 영역에서 TypeScript 5.1 이상을 사용해야 합니다.
  "typescript.preferences.renameMatchingJsxTags": true,

  // 이름을 바꾸는 동안 개체 줄임 속성의 별칭 소개를 사용하거나 사용하지 않도록 설정합니다.
  "typescript.preferences.useAliasesForRenames": true,

  // 자동 가져오기 제안을 사용하거나 사용하지 않도록 설정합니다.
  "javascript.suggest.autoImports": true,

  // 클래스 멤버에 대한 코드 조각 완성을 활성화/비활성화합니다.
  "javascript.suggest.classMemberSnippets.enabled": true,

  // 매개 변수 서명으로 함수를 완료하세요.
  "javascript.suggest.completeFunctionCalls": false,

  // 제안을 사용하거나 사용하지 않도록 설정하여 JSDoc 주석을 완료합니다.
  "javascript.suggest.completeJSDocs": true,

  // 자동 완성 제안을 사용하거나 사용하지 않도록 설정합니다.
  "javascript.suggest.enabled": true,

  // 선택적 체인 호출을 삽입하는 잠재적으로 정의되지 않은 값에 대한 완료 표시를 활성/비활성화합니다. 사용하려면 엄격한 null 검사가 필요합니다.
  "javascript.suggest.includeAutomaticOptionalChainCompletions": true,

  // 부분적으로 입력된 가져오기 문에서 가져오기 스타일 자동 완성을 활성/비활성화합니다.
  "javascript.suggest.includeCompletionsForImportStatements": true,

  // JSDoc 템플릿에 대한 '@returns' 주석 생성을 활성/비활성화합니다.
  "javascript.suggest.jsdoc.generateReturns": true,

  // JavaScript 제안에서 파일의 고유한 이름 포함을 사용하거나 사용하지 않도록 설정합니다. 이름 제안은 `@ts-check` 또는 `checkJs`를 사용하여 의미 체계적으로 확인되는 JavaScript 코드에서 항상 사용하지 않도록 설정됩니다.
  "javascript.suggest.names": true,

  // import 문 및 요청 호출의 경로에 대한 제안을 사용하거나 사용하지 않도록 설정합니다.
  "javascript.suggest.paths": true,

  // 자동 가져오기 제안을 사용하거나 사용하지 않도록 설정합니다.
  "typescript.suggest.autoImports": true,

  // 클래스 멤버에 대한 코드 조각 완성을 활성화/비활성화합니다.
  "typescript.suggest.classMemberSnippets.enabled": true,

  // 매개 변수 서명으로 함수를 완료하세요.
  "typescript.suggest.completeFunctionCalls": false,

  // 제안을 사용하거나 사용하지 않도록 설정하여 JSDoc 주석을 완료합니다.
  "typescript.suggest.completeJSDocs": true,

  // 자동 완성 제안을 사용하거나 사용하지 않도록 설정합니다.
  "typescript.suggest.enabled": true,

  // 선택적 체인 호출을 삽입하는 잠재적으로 정의되지 않은 값에 대한 완료 표시를 활성/비활성화합니다. 사용하려면 엄격한 null 검사가 필요합니다.
  "typescript.suggest.includeAutomaticOptionalChainCompletions": true,

  // 부분적으로 입력된 가져오기 문에서 가져오기 스타일 자동 완성을 활성/비활성화합니다.
  "typescript.suggest.includeCompletionsForImportStatements": true,

  // JSDoc 템플릿에 대한 '@returns' 주석 생성을 활성/비활성화합니다.
  "typescript.suggest.jsdoc.generateReturns": true,

  // 개체 리터럴의 메서드에 대한 코드 조각 완성을 활성화/비활성화합니다.
  "typescript.suggest.objectLiteralMethodSnippets.enabled": true,

  // import 문 및 요청 호출의 경로에 대한 제안을 사용하거나 사용하지 않도록 설정합니다.
  "typescript.suggest.paths": true,

  // `testing.followRunningTest`이(가) 켜져 있을 때 실행된 테스트를 항상 표시합니다. 이 설정을 끄면 실패한 테스트만 표시됩니다.
  "testing.alwaysRevealTestOnStateChange": false,

  // 오류 Peek 보기가 자동으로 열리는 경우를 구성합니다.
  //  - failureAnywhere: 오류 위치와 관계없이 자동으로 엽니다.
  //  - failureInVisibleDocument: 표시되는 문서에서 테스트가 실패할 경우 자동으로 엽니다.
  //  - never: 자동으로 열리지 않습니다.
  "testing.automaticallyOpenPeekView": "never",

  // 연속 실행 모드의 Peek 보기 자동 열기 여부를 제어합니다.
  "testing.automaticallyOpenPeekViewDuringAutoRun": false,

  // 테스트 뷰를 열어야 하는 시기를 제어합니다.
  //  - neverOpen: 테스트 보기를 자동으로 열지 않음
  //  - openOnTestStart: 테스트가 시작될 때 테스트 결과 보기 열기
  //  - openOnTestFailure: 테스트 실패 시 테스트 결과 보기 열기
  //  - openExplorerOnTestStart: 테스트가 시작될 때 테스트 탐색기 열기
  "testing.automaticallyOpenTestResults": "openOnTestStart",

  // 작업 막대에서 테스팅 아이콘의 개수 배지를 제어합니다.
  //  - failed: 실패한 테스트 수 표시
  //  - off: 테스트 수 배지 사용 안 함
  //  - passed: 통과한 테스트 수 표시
  //  - skipped: 건너뛴 테스트 수 표시
  "testing.countBadge": "failed",

  // 테스트 적용 범위 막대의 백분율에 사용되는 색을 구성합니다.
  "testing.coverageBarThresholds": {
    "red": 0,
    "yellow": 60,
    "green": 90
  },

  // 편집기에서 적용 범위 도구 모음을 표시할지를 제어합니다.
  "testing.coverageToolbarEnabled": false,

  // 제본용 여백에서 테스트 장식을 마우스 왼쪽 단추로 클릭할 때 수행할 동작을 제어합니다.
  //  - run: 테스트를 실행합니다.
  //  - debug: 테스트를 디버그합니다.
  //  - runWithCoverage: 적용 범위로 테스트 실행
  //  - contextMenu: 추가 옵션을 보려면 상황에 맞는 메뉴를 엽니다.
  "testing.defaultGutterClickAction": "run",

  // 테스트 적용 범위에 대해 기본적으로 표시되는 백분율을 구성합니다.
  //  - totalCoverage: 결합된 문, 함수 및 분기 적용 범위의 계산입니다.
  //  - statement: 문 적용 범위입니다.
  //  - minimum: 문, 함수 및 분기 적용 범위의 최소값입니다.
  "testing.displayedCoveragePercent": "totalCoverage",

  // 테스트 탐색기 보기에서 실행 중인 테스트를 따라야 할지를 제어합니다.
  "testing.followRunningTest": false,

  // 테스트 장식이 편집기 여백에 표시되는지 여부를 제어합니다.
  "testing.gutterEnabled": true,

  // 테스트를 실행하기 전에 모든 더티 편집기를 저장할지 여부를 제어합니다.
  "testing.saveBeforeTest": true,

  // 모든 테스트 실행의 메시지를 표시할지 여부를 제어합니다.
  "testing.showAllMessages": false,

  // 파일 탐색기 보기에서 테스트 검사를 종료할지 여부입니다.
  "testing.showCoverageInExplorer": true,

  // CSS 속성을 완료할 때 줄의 끝에 세미콜론을 삽입합니다.
  "css.completion.completePropertyWithSemicolon": true,

  // 기본적으로 VS Code는 CSS 속성을 선택한 후 속성 값 완료를 트리거합니다. 이 동작을 비활성화하려면 이 설정을 사용합니다.
  "css.completion.triggerPropertyValueCompletion": true,

  // [사용자 지정 데이터 형식](https://github.com/microsoft/vscode-css-languageservice/blob/master/docs/customData.md)에 따라 JSON 파일을 가리키는 상대 파일 경로의 목록입니다.
  //
  // VS Code는 시작 시 사용자 지정 데이터를 로드하여 JSON 파일에서 지정한 CSS 사용자 지정 속성(변수), at-rules, 의사 클래스 및 의사 요소에 대한 CSS 지원을 향상시킵니다.
  //
  // 파일 경로는 작업 영역에 상대적이며 작업 영역 폴더 설정만 고려됩니다.
  "css.customData": [],

  // 규칙(`collapse`)과 동일한 줄에 중괄호를 배치하거나 자체 줄(`expand`)에 중괄호를 배치합니다.
  "css.format.braceStyle": "collapse",

  // 기본 CSS 포맷터를 활성화/비활성화합니다.
  "css.format.enable": true,

  // `css.format.preserveNewLines`을(를) 사용하는 경우 한 청크에서 보존할 최대 줄 바꿈 수입니다.
  "css.format.maxPreserveNewLines": null,

  // 규칙 집합을 빈 줄로 구분합니다.
  "css.format.newlineBetweenRules": true,

  // 선택기를 새 줄로 구분합니다.
  "css.format.newlineBetweenSelectors": true,

  // 규칙 및 선언 전에 기존 줄 바꿈을 유지해야 하는지 여부입니다.
  "css.format.preserveNewLines": true,

  // 선택기 구분 기호 '>', '+', '~' 주위에 공백 문자가 있는지 확인합니다(예: 'a > b').
  "css.format.spaceAroundSelectorSeparator": false,

  // CSS 가리키기에서 속성 및 값 설명서를 표시합니다.
  "css.hover.documentation": true,

  // CSS 호버에 MDN에 대한 참조를 표시합니다.
  "css.hover.references": true,

  // 매개 변수 개수가 잘못되었습니다.
  "css.lint.argumentsInColorFunction": "error",

  // 'padding' 또는 'border'를 사용하는 경우 'width' 또는 'height'를 사용하지 마세요.
  "css.lint.boxModel": "ignore",

  // 공급업체 관련 접두사를 사용할 경우 다른 모든 공급업체 관련 속성도 포함합니다.
  "css.lint.compatibleVendorPrefixes": "ignore",

  // 중복된 스타일 정의를 사용하지 마세요.
  "css.lint.duplicateProperties": "ignore",

  // 빈 규칙 집합을 사용하지 마세요.
  "css.lint.emptyRules": "warning",

  // 'float'를 사용하지 않도록 합니다. Float를 사용하면 레이아웃의 한쪽이 바뀔 경우 CSS가 쉽게 깨질 수 있습니다.
  "css.lint.float": "ignore",

  // `@font-face` 규칙에서 'src' 및 'font-family' 속성을 정의해야 합니다.
  "css.lint.fontFaceProperties": "warning",

  // 16진수 색상은 3, 4, 6 또는 8진수로 구성되어야 합니다.
  "css.lint.hexColorLength": "error",

  // 이러한 규칙은 HTML과 긴밀하게 결합되므로 선택기에 ID를 포함하면 안 됩니다.
  "css.lint.idSelector": "ignore",

  // IE 핵(Hack)은 IE7 이상을 지원할 때만 필요합니다.
  "css.lint.ieHack": "ignore",

  // '!important'는 사용하지 않도록 합니다. 이것은 전체 CSS의 특정성에 문제가 있어서 리팩터링해야 함을 나타냅니다.
  "css.lint.important": "ignore",

  // Import 문은 병렬로 로드되지 않습니다.
  "css.lint.importStatement": "ignore",

  // display 때문에 속성이 무시됩니다. 예를 들어 'display: inline'을 사용할 경우 'width', 'height', 'margin-top', 'margin-bottom' 및 'float' 속성은 적용되지 않습니다.
  "css.lint.propertyIgnoredDueToDisplay": "warning",

  // 범용 선택기(*)는 느린 것으로 알려져 있습니다.
  "css.lint.universalSelector": "ignore",

  // 알 수 없는 @ 규칙 입니다.
  "css.lint.unknownAtRules": "warning",

  // 알 수 없는 속성입니다.
  "css.lint.unknownProperties": "warning",

  // 알 수 없는 공급업체 관련 속성입니다.
  "css.lint.unknownVendorSpecificProperties": "ignore",

  // `unknownProperties` 규칙에 따라 유효성이 검사되지 않은 속성 목록입니다.
  "css.lint.validProperties": [],

  // 공급업체 관련 접두사를 사용할 경우 표준 속성도 포함합니다.
  "css.lint.vendorPrefix": "warning",

  // 0에는 단위가 필요하지 않습니다.
  "css.lint.zeroUnits": "ignore",

  // VS Code와 CSS 언어 서버 간 통신을 추적합니다.
  "css.trace.server": "off",

  // 모든 유효성 검사를 사용하거나 사용하지 않습니다.
  "css.validate": true,

  // 기본 JavaScript 포맷터를 사용하거나 사용하지 않습니다.
  "javascript.format.enable": true,

  // switch 문의 case 절을 들여쓰기합니다. 작업 영역에서 TypeScript 5.1+를 사용해야 합니다.
  "javascript.format.indentSwitchCase": true,

  // 쉼표 구분 기호 뒤에 오는 공백 처리를 정의합니다.
  "javascript.format.insertSpaceAfterCommaDelimiter": true,

  // 생성자 키워드 뒤에 오는 공백 처리를 정의합니다.
  "javascript.format.insertSpaceAfterConstructor": false,

  // 익명 함수의 function 키워드 뒤에 오는 공백 처리를 정의합니다.
  "javascript.format.insertSpaceAfterFunctionKeywordForAnonymousFunctions": true,

  // 제어 흐름 문의 키워드 뒤에 오는 공백 처리를 정의합니다.
  "javascript.format.insertSpaceAfterKeywordsInControlFlowStatements": true,

  // 비어 있는 여는 중괄호 뒤와 닫는 중괄호 앞의 공백 처리를 정의합니다.
  "javascript.format.insertSpaceAfterOpeningAndBeforeClosingEmptyBraces": true,

  // JSX 식의 여는 중괄호 뒤와 닫는 중괄호 앞의 공백 처리를 정의합니다.
  "javascript.format.insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces": false,

  // 비어 있지 않은 여는 중괄호 뒤와 닫는 중괄호 앞의 공백 처리를 정의합니다.
  "javascript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces": true,

  // 비어 있지 않은 여는 대괄호 뒤와 닫는 대괄호 앞에 오는 공백 처리를 정의합니다.
  "javascript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets": false,

  // 비어 있지 않은 여는 괄호 뒤와 닫는 괄호 앞에 오는 공백 처리를 정의합니다.
  "javascript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis": false,

  // 템플릿 문자열의 여는 중괄호 뒤와 닫는 중괄호 앞의 공백 처리를 정의합니다.
  "javascript.format.insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces": false,

  // for 문에서 세미콜론 뒤에 오는 공백 처리를 정의합니다.
  "javascript.format.insertSpaceAfterSemicolonInForStatements": true,

  // 이항 연산자 뒤에 오는 공백 처리를 정의합니다.
  "javascript.format.insertSpaceBeforeAndAfterBinaryOperators": true,

  // 함수 인수 괄호 앞에 오는 공백 처리를 정의합니다.
  "javascript.format.insertSpaceBeforeFunctionParenthesis": false,

  // 제어 블록의 새 줄에 여는 중괄호를 넣을지 정의합니다.
  "javascript.format.placeOpenBraceOnNewLineForControlBlocks": false,

  // 함수의 새 줄에 여는 중괄호를 넣을지 정의합니다.
  "javascript.format.placeOpenBraceOnNewLineForFunctions": false,

  // 선택적 세미콜론 처리를 정의합니다.
  //  - ignore: 세미콜론을 삽입하거나 제거하지 마세요.
  //  - insert: 문 끝에 세미콜론을 삽입합니다.
  //  - remove: 불필요한 세미콜론을 제거합니다.
  "javascript.format.semicolons": "ignore",

  // 기본 TypeScript 포맷터를 사용하거나 사용하지 않습니다.
  "typescript.format.enable": true,

  // switch 문의 case 절을 들여쓰기합니다. 작업 영역에서 TypeScript 5.1+를 사용해야 합니다.
  "typescript.format.indentSwitchCase": true,

  // 쉼표 구분 기호 뒤에 오는 공백 처리를 정의합니다.
  "typescript.format.insertSpaceAfterCommaDelimiter": true,

  // 생성자 키워드 뒤에 오는 공백 처리를 정의합니다.
  "typescript.format.insertSpaceAfterConstructor": false,

  // 익명 함수의 function 키워드 뒤에 오는 공백 처리를 정의합니다.
  "typescript.format.insertSpaceAfterFunctionKeywordForAnonymousFunctions": true,

  // 제어 흐름 문의 키워드 뒤에 오는 공백 처리를 정의합니다.
  "typescript.format.insertSpaceAfterKeywordsInControlFlowStatements": true,

  // 비어 있는 여는 중괄호 뒤와 닫는 중괄호 앞의 공백 처리를 정의합니다.
  "typescript.format.insertSpaceAfterOpeningAndBeforeClosingEmptyBraces": true,

  // JSX 식의 여는 중괄호 뒤와 닫는 중괄호 앞의 공백 처리를 정의합니다.
  "typescript.format.insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces": false,

  // 비어 있지 않은 여는 중괄호 뒤와 닫는 중괄호 앞의 공백 처리를 정의합니다.
  "typescript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces": true,

  // 비어 있지 않은 여는 대괄호 뒤와 닫는 대괄호 앞에 오는 공백 처리를 정의합니다.
  "typescript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets": false,

  // 비어 있지 않은 여는 괄호 뒤와 닫는 괄호 앞에 오는 공백 처리를 정의합니다.
  "typescript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis": false,

  // 템플릿 문자열의 여는 중괄호 뒤와 닫는 중괄호 앞의 공백 처리를 정의합니다.
  "typescript.format.insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces": false,

  // for 문에서 세미콜론 뒤에 오는 공백 처리를 정의합니다.
  "typescript.format.insertSpaceAfterSemicolonInForStatements": true,

  // TypeScript에서 형식 어설션 뒤에 오는 공백 처리를 정의합니다.
  "typescript.format.insertSpaceAfterTypeAssertion": false,

  // 이항 연산자 뒤에 오는 공백 처리를 정의합니다.
  "typescript.format.insertSpaceBeforeAndAfterBinaryOperators": true,

  // 함수 인수 괄호 앞에 오는 공백 처리를 정의합니다.
  "typescript.format.insertSpaceBeforeFunctionParenthesis": false,

  // 제어 블록의 새 줄에 여는 중괄호를 넣을지 정의합니다.
  "typescript.format.placeOpenBraceOnNewLineForControlBlocks": false,

  // 함수의 새 줄에 여는 중괄호를 넣을지 정의합니다.
  "typescript.format.placeOpenBraceOnNewLineForFunctions": false,

  // 선택적 세미콜론 처리를 정의합니다.
  //  - ignore: 세미콜론을 삽입하거나 제거하지 마세요.
  //  - insert: 문 끝에 세미콜론을 삽입합니다.
  //  - remove: 불필요한 세미콜론을 제거합니다.
  "typescript.format.semicolons": "ignore",

  // CSS 속성을 완료할 때 줄의 끝에 세미콜론을 삽입합니다.
  "less.completion.completePropertyWithSemicolon": true,

  // 기본적으로 VS Code는 CSS 속성을 선택한 후 속성 값 완료를 트리거합니다. 이 동작을 비활성화하려면 이 설정을 사용합니다.
  "less.completion.triggerPropertyValueCompletion": true,

  // 규칙(`collapse`)과 동일한 줄에 중괄호를 배치하거나 자체 줄(`expand`)에 중괄호를 배치합니다.
  "less.format.braceStyle": "collapse",

  // 기본 LESS 포맷터를 활성화/비활성화합니다.
  "less.format.enable": true,

  // `less.format.preserveNewLines`을(를) 사용하는 경우 한 청크에서 보존할 최대 줄 바꿈 수입니다.
  "less.format.maxPreserveNewLines": null,

  // 규칙 집합을 빈 줄로 구분합니다.
  "less.format.newlineBetweenRules": true,

  // 선택기를 새 줄로 구분합니다.
  "less.format.newlineBetweenSelectors": true,

  // 규칙 및 선언 전에 기존 줄 바꿈을 유지해야 하는지 여부입니다.
  "less.format.preserveNewLines": true,

  // 선택기 구분 기호 '>', '+', '~' 주위에 공백 문자가 있는지 확인합니다(예: 'a > b').
  "less.format.spaceAroundSelectorSeparator": false,

  // LESS 가리키기에서 속성 및 값 설명서를 표시합니다.
  "less.hover.documentation": true,

  // LESS 호버에 MDN에 대한 참조를 표시합니다.
  "less.hover.references": true,

  // 매개 변수 개수가 잘못되었습니다.
  "less.lint.argumentsInColorFunction": "error",

  // 'padding' 또는 'border'를 사용하는 경우 'width' 또는 'height'를 사용하지 마세요.
  "less.lint.boxModel": "ignore",

  // 공급업체 관련 접두사를 사용할 경우 다른 모든 공급업체 관련 속성도 포함합니다.
  "less.lint.compatibleVendorPrefixes": "ignore",

  // 중복된 스타일 정의를 사용하지 마세요.
  "less.lint.duplicateProperties": "ignore",

  // 빈 규칙 집합을 사용하지 마세요.
  "less.lint.emptyRules": "warning",

  // 'float'를 사용하지 않도록 합니다. Float를 사용하면 레이아웃의 한쪽이 바뀔 경우 CSS가 쉽게 깨질 수 있습니다.
  "less.lint.float": "ignore",

  // `@font-face` 규칙에서 'src' 및 'font-family' 속성을 정의해야 합니다.
  "less.lint.fontFaceProperties": "warning",

  // 16진수 색상은 3, 4, 6 또는 8진수로 구성되어야 합니다.
  "less.lint.hexColorLength": "error",

  // 이러한 규칙은 HTML과 긴밀하게 결합되므로 선택기에 ID를 포함하면 안 됩니다.
  "less.lint.idSelector": "ignore",

  // IE 핵(Hack)은 IE7 이상을 지원할 때만 필요합니다.
  "less.lint.ieHack": "ignore",

  // '!important'는 사용하지 않도록 합니다. 이것은 전체 CSS의 특정성에 문제가 있어서 리팩터링해야 함을 나타냅니다.
  "less.lint.important": "ignore",

  // Import 문은 병렬로 로드되지 않습니다.
  "less.lint.importStatement": "ignore",

  // display 때문에 속성이 무시됩니다. 예를 들어 'display: inline'을 사용할 경우 'width', 'height', 'margin-top', 'margin-bottom' 및 'float' 속성은 적용되지 않습니다.
  "less.lint.propertyIgnoredDueToDisplay": "warning",

  // 범용 선택기(*)는 느린 것으로 알려져 있습니다.
  "less.lint.universalSelector": "ignore",

  // 알 수 없는 @ 규칙 입니다.
  "less.lint.unknownAtRules": "warning",

  // 알 수 없는 속성입니다.
  "less.lint.unknownProperties": "warning",

  // 알 수 없는 공급업체 관련 속성입니다.
  "less.lint.unknownVendorSpecificProperties": "ignore",

  // `unknownProperties` 규칙에 따라 유효성이 검사되지 않은 속성 목록입니다.
  "less.lint.validProperties": [],

  // 공급업체 관련 접두사를 사용할 경우 표준 속성도 포함합니다.
  "less.lint.vendorPrefix": "warning",

  // 0에는 단위가 필요하지 않습니다.
  "less.lint.zeroUnits": "ignore",

  // 모든 유효성 검사를 사용하거나 사용하지 않습니다.
  "less.validate": true,

  // 함수 시그니처의 암시적 반환 형식에 대한 인레이 힌트 활성화/비활성화:
  // ```typescript
  //
  // function foo() /* :number */ {
  //  return Date.now();
  //  }
  //
  // ```
  "javascript.inlayHints.functionLikeReturnTypes.enabled": false,

  // 매개 변수 이름에 대한 인레이 힌트 활성화/비활성화:
  // ```typescript
  //
  // parseInt(/* str: */ '123', /* radix: */ 8)
  //
  // ```
  //  - none: 매개변수 이름 힌트를 비활성화합니다.
  //  - literals: 리터럴 인수에 대해서만 매개변수 이름 힌트를 활성화합니다.
  //  - all: 리터럴 및 비리터럴 인수에 대한 매개변수 이름 힌트를 활성화합니다.
  "javascript.inlayHints.parameterNames.enabled": "none",

  // 텍스트가 매개변수 이름과 동일한 인수에 대해 매개변수 이름 힌트를 표시하지 않습니다.
  "javascript.inlayHints.parameterNames.suppressWhenArgumentMatchesName": true,

  // 암시적 매개 변수 유형에 대한 인레이 힌트 활성화/비활성화:
  // ```typescript
  //
  // el.addEventListener('click', e /* :MouseEvent */ => ...)
  //
  //  ```
  "javascript.inlayHints.parameterTypes.enabled": false,

  // 속성 선언의 암시적 유형에 대한 인레이 힌트 활성화/비활성화:
  // ```typescript
  //
  // class Foo {
  //  prop /* :number */ = Date.now();
  // }
  //
  // ```
  "javascript.inlayHints.propertyDeclarationTypes.enabled": false,

  // 암시적 변수 유형에 대한 인레이 힌트 활성화/비활성화:
  // ```typescript
  //
  // const foo /* :number */ = Date.now();
  //
  // ```
  "javascript.inlayHints.variableTypes.enabled": false,

  // 이름이 형식 이름과 동일한 변수에 대한 형식 힌트를 표시하지 않습니다.
  "javascript.inlayHints.variableTypes.suppressWhenTypeMatchesName": true,

  // 열거형 선언의 멤버 값에 대한 인레이 힌트 활성화/비활성화:
  // ```typescript
  //
  // enum MyValue {
  //  A /* = 0 */;
  //  B /* = 1 */;
  // }
  //
  // ```
  "typescript.inlayHints.enumMemberValues.enabled": false,

  // 함수 시그니처의 암시적 반환 형식에 대한 인레이 힌트 활성화/비활성화:
  // ```typescript
  //
  // function foo() /* :number */ {
  //  return Date.now();
  //  }
  //
  // ```
  "typescript.inlayHints.functionLikeReturnTypes.enabled": false,

  // 매개 변수 이름에 대한 인레이 힌트 활성화/비활성화:
  // ```typescript
  //
  // parseInt(/* str: */ '123', /* radix: */ 8)
  //
  // ```
  //  - none: 매개변수 이름 힌트를 비활성화합니다.
  //  - literals: 리터럴 인수에 대해서만 매개변수 이름 힌트를 활성화합니다.
  //  - all: 리터럴 및 비리터럴 인수에 대한 매개변수 이름 힌트를 활성화합니다.
  "typescript.inlayHints.parameterNames.enabled": "none",

  // 텍스트가 매개변수 이름과 동일한 인수에 대해 매개변수 이름 힌트를 표시하지 않습니다.
  "typescript.inlayHints.parameterNames.suppressWhenArgumentMatchesName": true,

  // 암시적 매개 변수 유형에 대한 인레이 힌트 활성화/비활성화:
  // ```typescript
  //
  // el.addEventListener('click', e /* :MouseEvent */ => ...)
  //
  //  ```
  "typescript.inlayHints.parameterTypes.enabled": false,

  // 속성 선언의 암시적 유형에 대한 인레이 힌트 활성화/비활성화:
  // ```typescript
  //
  // class Foo {
  //  prop /* :number */ = Date.now();
  // }
  //
  // ```
  "typescript.inlayHints.propertyDeclarationTypes.enabled": false,

  // 암시적 변수 유형에 대한 인레이 힌트 활성화/비활성화:
  // ```typescript
  //
  // const foo /* :number */ = Date.now();
  //
  // ```
  "typescript.inlayHints.variableTypes.enabled": false,

  // 이름이 형식 이름과 동일한 변수에 대한 형식 힌트를 표시하지 않습니다.
  "typescript.inlayHints.variableTypes.suppressWhenTypeMatchesName": true,

  // CSS 속성을 완료할 때 줄의 끝에 세미콜론을 삽입합니다.
  "scss.completion.completePropertyWithSemicolon": true,

  // 기본적으로 VS Code는 CSS 속성을 선택한 후 속성 값 완료를 트리거합니다. 이 동작을 비활성화하려면 이 설정을 사용합니다.
  "scss.completion.triggerPropertyValueCompletion": true,

  // 규칙(`collapse`)과 동일한 줄에 중괄호를 배치하거나 자체 줄(`expand`)에 중괄호를 배치합니다.
  "scss.format.braceStyle": "collapse",

  // 기본 SCSS 포맷터를 활성화/비활성화합니다.
  "scss.format.enable": true,

  // `scss.format.preserveNewLines`을(를) 사용하도록 설정한 경우 한 청크에서 보존할 최대 줄 바꿈 수입니다.
  "scss.format.maxPreserveNewLines": null,

  // 규칙 집합을 빈 줄로 구분합니다.
  "scss.format.newlineBetweenRules": true,

  // 선택기를 새 줄로 구분합니다.
  "scss.format.newlineBetweenSelectors": true,

  // 규칙 및 선언 전에 기존 줄 바꿈을 유지해야 하는지 여부입니다.
  "scss.format.preserveNewLines": true,

  // 선택기 구분 기호 '>', '+', '~' 주위에 공백 문자가 있는지 확인합니다(예: 'a > b').
  "scss.format.spaceAroundSelectorSeparator": false,

  // SCSS 가리키기에서 속성 및 값 설명서를 표시합니다.
  "scss.hover.documentation": true,

  // SCSS 호버에 MDN에 대한 참조를 표시합니다.
  "scss.hover.references": true,

  // 매개 변수 개수가 잘못되었습니다.
  "scss.lint.argumentsInColorFunction": "error",

  // 'padding' 또는 'border'를 사용하는 경우 'width' 또는 'height'를 사용하지 마세요.
  "scss.lint.boxModel": "ignore",

  // 공급업체 관련 접두사를 사용할 경우 다른 모든 공급업체 관련 속성도 포함합니다.
  "scss.lint.compatibleVendorPrefixes": "ignore",

  // 중복된 스타일 정의를 사용하지 마세요.
  "scss.lint.duplicateProperties": "ignore",

  // 빈 규칙 집합을 사용하지 마세요.
  "scss.lint.emptyRules": "warning",

  // 'float'를 사용하지 않도록 합니다. Float를 사용하면 레이아웃의 한쪽이 바뀔 경우 CSS가 쉽게 깨질 수 있습니다.
  "scss.lint.float": "ignore",

  // `@font-face` 규칙에서 'src' 및 'font-family' 속성을 정의해야 합니다.
  "scss.lint.fontFaceProperties": "warning",

  // 16진수 색상은 3, 4, 6 또는 8진수로 구성되어야 합니다.
  "scss.lint.hexColorLength": "error",

  // 이러한 규칙은 HTML과 긴밀하게 결합되므로 선택기에 ID를 포함하면 안 됩니다.
  "scss.lint.idSelector": "ignore",

  // IE 핵(Hack)은 IE7 이상을 지원할 때만 필요합니다.
  "scss.lint.ieHack": "ignore",

  // '!important'는 사용하지 않도록 합니다. 이것은 전체 CSS의 특정성에 문제가 있어서 리팩터링해야 함을 나타냅니다.
  "scss.lint.important": "ignore",

  // Import 문은 병렬로 로드되지 않습니다.
  "scss.lint.importStatement": "ignore",

  // display 때문에 속성이 무시됩니다. 예를 들어 'display: inline'을 사용할 경우 'width', 'height', 'margin-top', 'margin-bottom' 및 'float' 속성은 적용되지 않습니다.
  "scss.lint.propertyIgnoredDueToDisplay": "warning",

  // 범용 선택기(*)는 느린 것으로 알려져 있습니다.
  "scss.lint.universalSelector": "ignore",

  // 알 수 없는 @ 규칙 입니다.
  "scss.lint.unknownAtRules": "warning",

  // 알 수 없는 속성입니다.
  "scss.lint.unknownProperties": "warning",

  // 알 수 없는 공급업체 관련 속성입니다.
  "scss.lint.unknownVendorSpecificProperties": "ignore",

  // `unknownProperties` 규칙에 따라 유효성이 검사되지 않은 속성 목록입니다.
  "scss.lint.validProperties": [],

  // 공급업체 관련 접두사를 사용할 경우 표준 속성도 포함합니다.
  "scss.lint.vendorPrefix": "warning",

  // 0에는 단위가 필요하지 않습니다.
  "scss.lint.zeroUnits": "ignore",

  // 모든 유효성 검사를 사용하거나 사용하지 않습니다.
  "scss.validate": true,

  // [자동 형식 인식](https://code.visualstudio.com/docs/nodejs/working-with-javascript#_typings-and-automatic-type-acquisition)을 위해 npm이 설치되어 있는지 확인하세요.
  "typescript.check.npmIsInstalled": true,

  // [자동 형식 인식](https://code.visualstudio.com/docs/nodejs/working-with-javascript#_typings-and-automatic-type-acquisition)에 사용되는 npm 실행 파일의 경로를 지정합니다.
  "typescript.npm": "",

  // 디렉터리에 대해 TS 서버 성능 추적을 사용하도록 설정합니다. 이 추적 파일은 TS 서버 성능 문제를 진단하는 데 사용될 수 있습니다. 로그에는 파일 경로, 소스 코드 및 프로젝트에서 잠재적으로 중요한 기타 정보가 포함될 수 있습니다.
  "typescript.tsserver.enableTracing": false,

  // 프로젝트 전체 오류 보고를 활성화합니다.
  "typescript.tsserver.experimental.enableProjectDiagnostics": false,

  // 파일에 대해 TS 서버 로깅을 사용하도록 설정합니다. 이 로그는 TS 서버 문제를 진단하는 데 사용될 수 있습니다. 로그에는 파일 경로, 소스 코드 및 프로젝트에서 잠재적으로 중요한 기타 정보가 포함될 수 있습니다.
  "typescript.tsserver.log": "off",

  // TypeScript 서버 프로세스에 할당할 최대 메모리 양(MB)입니다. 4GB보다 큰 메모리 제한을 사용하려면 '#typescript.tsserver.nodePath#'을 사용하여 사용자 지정 노드 설치로 TS Server를 실행합니다.
  "typescript.tsserver.maxTsServerMemory": 3072,

  // 사용자 지정 노드 설치에서 TS 서버를 실행합니다. 이 값은 노드 실행 파일의 경로이거나 VS 코드가 노드 설치를 감지하도록 하려는 경우 'node'일 수 있습니다.
  "typescript.tsserver.nodePath": "",

  // TypeScript 언어 서비스 플러그 인을 검색할 추가 경로입니다.
  "typescript.tsserver.pluginPaths": [],

  // TypeScript가 컴퓨팅 코드 접기와 같은 구문 관련 작업을 보다 빠르게 처리하기 위해 전용 서버를 시작하는지 여부를 제어합니다.
  //  - always: 경량 구문 서버를 사용하여 모든 IntelliSense 작업을 처리하세요. 이 구문 서버는 열린 파일에 대해서만 IntelliSense를 제공할 수 있습니다.
  //  - never: 전용 구문 서버를 사용하지 마세요. 단일 서버를 사용하여 모든 IntelliSense 작업을 처리하세요.
  //  - auto: 전체 서버와 구문 작업 전용의 경량 서버를 모두 생성하세요. 구문 서버는 프로젝트를 로드하는 동안 구문 작업을 가속화하고 IntelliSense를 제공하는 데 사용됩니다.
  "typescript.tsserver.useSyntaxServer": "auto",

  // 파일 및 디렉터리 추적에 사용할 감시 전략을 구성합니다.
  "typescript.tsserver.watchOptions": "vscode",

  // 웹에서 프로젝트 전체 IntelliSense를 사용/사용 안 함으로 설정합니다. VS Code는 신뢰할 수 있는 컨텍스트에서 실행되어야 합니다.
  "typescript.tsserver.web.projectWideIntellisense.enabled": true,

  // 프로젝트 전체 IntelliSense를 사용하도록 설정한 경우에도 웹에서 의미 체계 오류를 표시하지 않습니다. 프로젝트 전체 IntelliSense를 사용하도록 설정하지 않았거나 사용할 수 없는 경우 항상 켜져 있습니다. `typescript.tsserver.web.projectWideIntellisense.enabled`를 참조하세요.
  "typescript.tsserver.web.projectWideIntellisense.suppressSemanticErrors": false,

  // 웹에서 패키지 취득을 사용하거나 사용하지 않도록 설정합니다. 이렇게 하면 가져온 패키지에 대해 IntelliSense가 활성화됩니다. '#typescript.tsserver.web.projectWideIntellisense.enabled#'이 필요합니다. 현재 Safari에서 지원되지 않습니다.
  "typescript.tsserver.web.typeAcquisition.enabled": true,

  // 동기화하는 동안 무시할 확장 목록입니다. 확장의 식별자는 항상 `${publisher}.${name}`입니다(예: `vscode.csharp`).
  "settingsSync.ignoredExtensions": [],

  // 동기화하는 동안 무시할 설정을 구성합니다.
  "settingsSync.ignoredSettings": [],

  // 각 플랫폼에 대해 키 바인딩을 동기화합니다.
  "settingsSync.keybindingsPerPlatform": true,

  // 출력 보기에서 스마트 스크롤 기능을 사용하거나 사용하지 않도록 설정합니다. 스마트 스크롤 기능을 사용하면 출력 보기를 클릭하면 스크롤이 자동으로 잠기고 마지막 줄을 클릭하면 잠금이 해제됩니다.
  "output.smartScroll.enabled": true,

  // 사용할 수 있는 확장 목록을 지정합니다. 이는 권한 없는 확장의 사용을 제한하여 안전하고 일관된 개발 환경을 유지하는 데 도움이 됩니다. 이 설정을 구성하는 방법에 대한 자세한 내용은 [허용된 확장 구성](https://code.visualstudio.com/docs/setup/enterprise#_configure-allowed-extensions) 섹션을 방문하세요.
  "extensions.allowed": "*",

  // 사용하도록 설정하면 확장의 업데이트가 있는지를 자동으로 확인합니다. 확장의 업데이트가 있으면 확장 보기에서 오래된 것으로 표시됩니다. 업데이트는 Microsoft 온라인 서비스에서 가져옵니다.
  "extensions.autoCheckUpdates": true,

  // 확장의 자동 업데이트 동작을 제어합니다. 업데이트는 Microsoft 온라인 서비스에서 페치됩니다.
  //  - true: 모든 확장의 업데이트를 자동으로 다운로드하고 설치합니다.
  //  - onlyEnabledExtensions: 활성화된 확장에 대해서만 업데이트를 자동으로 다운로드하고 설치합니다.
  //  - false: 확장이 자동으로 업데이트되지 않습니다.
  "extensions.autoUpdate": true,

  // 사용하도록 설정하는 경우 확장 뷰에서 나가면 확장 정보가 포함된 편집기가 자동으로 닫힙니다.
  "extensions.closeExtensionDetailsOnViewChange": false,

  // 확장이 여기에 나열되어 있으면 해당 확장에서 URI를 처리할 때 확인 프롬프트가 표시되지 않습니다.
  "extensions.confirmedUriHandlerExtensionIds": [],

  // 다른 확장 호스트 프로세스에서 실행되도록 확장을 구성합니다.
  "extensions.experimental.affinity": {},

  // 사용하도록 설정하면 제한 시간 후에 'onStartupFinished' 활성화 이벤트를 선언하는 확장이 활성화됩니다.
  "extensions.experimental.deferredStartupFinishedActivation": false,

  // 사용하도록 설정하면 빠른 액세스를 통해 확장을 검색하고 해당 위치에서 문제를 보고할 수 있습니다.
  "extensions.experimental.issueQuickAccess": true,

  // 사용하도록 설정하면 확장 권장 사항에 대한 알림이 표시되지 않습니다.
  "extensions.ignoreRecommendations": false,

  // 이 설정은 사용되지 않습니다. extensions.ignoreRecommendations 설정을 사용하여 권장 사항 알림을 제어합니다. 확장 보기의 표시 작업을 사용하여 권장 보기를 기본적으로 숨깁니다.
  //
  "extensions.showRecommendationsOnlyOnDemand": false,

  // 사용하도록 설정하면 Node.js 탐색기 개체가 전역 범위에 노출됩니다.
  "extensions.supportNodeGlobalNavigator": false,

  // 확장의 신뢰할 수 없는 작업 영역 지원을 재정의합니다. 'true'를 사용하는 확장은 항상 사용할 수 있습니다. '제한됨'을 사용하는 확장은 항상 사용할 수 있으며, 확장은 신뢰를 필요로 하는 기능을 숨깁니다. 'false'를 사용한 확장은 작업 영역을 신뢰할 수 있는 경우에만 사용할 수 있습니다.
  "extensions.supportUntrustedWorkspaces": {},

  // 확장의 가상 작업 영역 지원을 재정의합니다.
  "extensions.supportVirtualWorkspaces": {},

  // 사용하도록 설정하면 확장을 설치하기 전에 서명된 것으로 확인됩니다.
  "extensions.verifySignature": true,

  // 웹 작업자 확장 호스트를 사용합니다.
  //  - true: 웹 작업자 확장 호스트는 항상 시작됩니다.
  //  - false: 웹 작업자 확장 호스트는 시작되지 않습니다.
  //  - auto: 웹 작업자 확장 호스트는 웹 확장에 필요한 경우 시작됩니다.
  "extensions.webWorker": "auto",

  // 대화형 창의 코드 셀이 기본적으로 축소되는지 여부를 제어합니다.
  "interactiveWindow.collapseCellInputCode": "fromEditor",

  // 핫 다시 로드를 위해 Notebook 파일이 더 이상 백업되지 않는 Notebook 출력 크기 제한(KB)입니다. 무제한으로 0을 사용합니다.
  "notebook.backup.sizeLimit": 10000,

  // 사용하도록 설정하면 Notebook 이동 경로에 코드 셀이 포함됩니다.
  "notebook.breadcrumbs.showCodeCells": true,

  // 셀 상태 표시줄에서 셀 실행 시간의 세부 정보 표시를 제어합니다.
  //  - default: 가리킨 항목의 도구 설명에 고급 정보와 함께 셀 실행 기간이 표시됩니다.
  //  - verbose: 가리킨 항목의 도구 설명에 고급 정보와 함께 셀의 마지막 실행 타임스탬프와 기간이 표시됩니다.
  "notebook.cellExecutionTimeVerbosity": "default",

  // 셀 오류에 대해 사용 가능한 진단을 표시합니다.
  "notebook.cellFailureDiagnostics": true,

  // 셀 테두리를 따라 또는 왼쪽 여백에서 포커스 표시기가 렌더링되는 위치를 제어합니다.
  "notebook.cellFocusIndicator": "gutter",

  // 셀 도구 모음을 표시해야 하거나 숨겨야 하는지 여부입니다.
  "notebook.cellToolbarLocation": {
    "default": "right"
  },

  // 셀 도구 모음을 마우스로 가리키거나 클릭할 때 표시할지 여부입니다.
  "notebook.cellToolbarVisibility": "click",

  // 전자 필기장 편집기를 압축된 형식으로 렌더링할지 여부를 제어합니다. 예를 들어 이 기능을 켜면 왼쪽 여백 너비가 줄어듭니다.
  "notebook.compactView": true,

  // 실행 중인 셀을 삭제하기 위해 확인 프롬프트가 필요한지를 제어합니다.
  "notebook.confirmDeleteRunningCell": true,

  // 출력 도구 모음에서 출력 동작을 렌더링할지 여부를 제어합니다.
  "notebook.consolidatedOutputButton": true,

  // 실행 단추 옆의 드롭다운에 추가 작업이 표시되는지 여부를 제어합니다.
  "notebook.consolidatedRunButton": false,

  // 다른 모든 포맷터 설정보다 우선하는 기본 Notebook 포맷터를 정의합니다. 포맷터를 제공하는 확장의 식별자여야 합니다.
  //  - null: None
  //  - formulahendry.code-runner: Run C, C++, Java, JS, PHP, Python, Perl, Ruby, Go, Lua, Groovy, PowerShell, CMD, BASH, F#, C#, VBScript, TypeScript, CoffeeScript, Scala, Swift, Julia, Crystal, OCaml, R, AppleScript, Elixir, VB.NET, Clojure, Haxe, Obj-C, Rust, Racket, Scheme, AutoHotkey, AutoIt, Kotlin, Dart, Pascal, Haskell, Nim, D, Lisp, Kit, V, SCSS, Sass, CUDA, Less, Fortran, Ring, Standard ML, Zig, Mojo, Erlang, SPWN, Pkl, Gleam
  //  - vscode.css-language-features: CSS, LESS 및 SCSS 파일에 대한 다양한 언어 지원을 제공합니다.
  //  - vscode.html-language-features: HTML 및 Handlebar 파일에 대해 다양한 언어 지원을 제공합니다.
  //  - vscode.json-language-features: JSON 파일에 대한 다양한 언어 지원을 제공합니다.
  //  - vscode.markdown-language-features: Markdown에 대한 다양한 언어 지원을 제공합니다.
  //  - vscode.markdown-math: 전자 필기장의 Markdown에 수학 지원을 추가합니다.
  //  - vscode.php-language-features: PHP 파일에 대한 다양한 언어 지원을 제공합니다.
  //  - esbenp.prettier-vscode: Code formatter using prettier
  //  - syler.sass-indented: Indented Sass syntax Highlighting, Autocomplete & Formatter
  //  - vscode.typescript-language-features: JavaScript 및 TypeScript에 대한 다양한 언어 지원을 제공합니다.
  //  - dbaeumer.vscode-eslint: Integrates ESLint JavaScript into VS Code.
  //  - CoenraadS.bracket-pair-colorizer-2: A customizable extension for colorizing matching brackets
  //  - vscode.configuration-editing: 설정, 시작 및 확장 추천 파일과 같은 구성 파일에서 기능(고급 IntelliSense, 자동 수정)을 제공합니다.
  //  - vscode.debug-auto-launch: 노드 디버그 확장이 비활성화될 때 자동 연결 기능을 위한 도우미입니다.
  //  - vscode.debug-server-ready: 디버깅 중인 서버가 준비되면 브라우저에서 URI를 엽니다.
  //  - vscode.emmet: VS Code에 대한 Emmet 지원
  //  - vscode.extension-editing: 확장 제작을 위한 Lint 기능을 제공합니다.
  //  - vscode.git: Git SCM 통합
  //  - vscode.git-base: GIT 고정적 기여 및 선택기입니다.
  //  - donjayamanne.githistory: View git log, file history, compare branches or commits
  //  - vscode.github: VS Code용 GitHub 기능
  //  - vscode.github-authentication: GitHub 인증 공급자
  //  - vscode.grunt: Extension to add Grunt capabilities to VS Code.
  //  - vscode.gulp: VSCode에 Gulp 기능을 추가할 확장입니다.
  //  - vscode.ipynb: Jupyter의 .ipynb 노트북 파일 열기 및 읽기에 대한 기본 지원을 제공합니다
  //  - vscode.jake: VS Code에 Jake 기능을 추가할 확장입니다.
  //  - ms-vscode.js-debug: An extension for debugging Node.js programs and Chrome.
  //  - ms-vscode.js-debug-companion: Companion extension to js-debug that provides capability for remote debugging
  //  - glenn2223.live-sass: Compile Sass or Scss to CSS at realtime.
  //  - ritwickdey.LiveServer: Launch a development local Server with live reload feature for static & dynamic pages
  //  - vscode.media-preview: 이미지, 오디오 및 비디오에 대한 VS Code 기본 제공 미리 보기를 제공합니다.
  //  - vscode.merge-conflict: 인라인 병합 충돌에 대한 강조 표시 및 명령입니다.
  //  - vscode.microsoft-authentication: Microsoft 인증 공급자
  //  - vscode.npm: npm 스크립트에 대한 작업 지원을 추가할 확장입니다.
  //  - techer.open-in-browser: This allows you to open the current file in your default browser or application.
  //  - vscode.references-view: 사이드바에서 검색 결과를 별도의 안정적인 보기로 참조
  //  - vscode.search-result: 탭된 검색 결과에 대한 구문 강조 표시 및 언어 기능을 제공합니다.
  //  - vscode.simple-browser: 웹 콘텐츠를 표시하기 위한 매우 기본적인 기본 제공 웹 보기입니다.
  //  - vscode.terminal-suggest: zsh, bash 및 fish 터미널에 대한 터미널 완성을 추가하는 확장입니다.
  //  - vscode.tunnel-forwarding: 전달 로컬 포트를 인터넷을 통해 액세스할 수 있도록 허용합니다.
  //  - ms-vscode.vscode-js-profile-table: Text visualizer for profiles taken from the JavaScript debugger
  "notebook.defaultFormatter": null,

  // Notebook에 향상된 텍스트 Diff 편집기를 사용할지 여부입니다.
  "notebook.diff.enablePreview": true,

  // 실험적 Notebook 인라인 diff 편집기를 토글하는 명령을 사용하도록 설정합니다.
  "notebook.diff.experimental.toggleInline": false,

  // 메타데이터 차이 숨기기
  "notebook.diff.ignoreMetadata": false,

  // 출력 차이 숨기기
  "notebook.diff.ignoreOutputs": false,

  // Notebook의 diff 편집기에서 개요 눈금자를 렌더링할지 여부를 지정합니다.
  "notebook.diff.overviewRuler": false,

  // 출력 MIME 형식의 우선순위 목록
  "notebook.displayOrder": [],

  // Notebook 편집기에서 끌어서 놓기를 통해 셀을 이동할 수 있는지 여부를 제어합니다.
  "notebook.dragAndDropEnabled": true,

  // Notebook에서 사용되는 코드 편집기에 대한 설정입니다. 이 항목은 대부분의 editor.* 설정을 사용자 지정하는 데 사용할 수 있습니다.
  "notebook.editorOptionsCustomizations": {},

  // 실험적 생성 작업을 활성화하여 인라인 채팅이 활성화된 코드 셀을 생성합니다.
  "notebook.experimental.generate": true,

  // 프로세스 간 및 원격 연결 간에 Notebook의 바뀐 부분만 저장하도록 설정합니다. 사용하도록 설정할 경우 Notebook의 변경 내용만 확장 호스트로 전송되므로 대용량 Notebook의 성능과 네트워크 속도가 향상됩니다.
  "notebook.experimental.remoteSave": false,

  // 전자 필기장 셀 내에서 검색하기 위한 위젯 찾기 동작을 사용자 지정합니다. 마크업 소스와 마크업 미리 보기가 모두 활성화되면 위젯 찾기는 셀의 현재 상태를 기반으로 소스 코드 또는 미리 보기를 검색합니다.
  "notebook.find.filters": {
    "markupSource": true,
    "markupPreview": true,
    "codeSource": true,
    "codeOutput": true
  },

  // 실행 시 Notebook 셀의 서식을 지정합니다. 포맷터를 사용할 수 있어야 합니다.
  "notebook.formatOnCellExecution": false,

  // 저장 시 Notebook의 형식을 지정합니다. 포맷터를 사용할 수 있어야 하며 편집기를 종료하면 안 됩니다. `files.autoSave`이(가) 'afterDelay'로 설정된 경우 파일은 명시적으로 저장될 때만 형식이 지정됩니다.
  "notebook.formatOnSave.enabled": false,

  // Notebook 편집기 내에서 전역 도구 모음을 렌더링할지 여부를 제어합니다.
  "notebook.globalToolbar": true,

  // Notebook 도구 모음의 작업이 레이블을 렌더링할지 여부를 제어합니다.
  "notebook.globalToolbarShowLabel": "always",

  // 이 옵션을 사용하도록 설정하면 기호로 이동 빠른 선택에서 Notebook의 전체 코드 기호와 Markdown 헤더가 표시됩니다.
  "notebook.gotoSymbols.showAllSymbols": true,

  // 셀 실행 후 Notebook 코드 셀 내에 인라인 값을 표시할지 여부를 제어합니다. [모든 출력 지우기] 도구 모음 단추 또는 'Notebook: 인라인 값 지우기' 명령을 통해 셀을 편집하거나, 다시 실행하거나, 명시적으로 지울 때까지 값이 유지됩니다.
  //  - on: 인라인 값 공급자가 등록되지 않은 경우 regex 대체와 함께 인라인 값을 항상 표시합니다. 참고: 대체를 사용하는 경우 더 큰 셀에서 성능에 영향을 미칠 수 있습니다.
  //  - auto: 인라인 값 공급자가 등록된 경우에만 인라인 값을 표시합니다.
  //  - off: 인라인 값을 표시하지 않습니다.
  "notebook.inlineValues": "off",

  // 사용하도록 설정하면 Notebook을 저장할 때 코드 셀 끝에 마지막 새 줄을 삽입합니다.
  "notebook.insertFinalNewline": false,

  // 셀 삽입 동작이 나타날 위치를 제어합니다.
  //  - betweenCells: 셀 사이에 마우스를 가져가면 표시되는 도구 모음입니다.
  //  - notebookToolbar: 전자 필기장 편집기의 맨 위에 있는 도구 모음입니다.
  //  - both: 두 도구 모음입니다.
  //  - hidden: 삽입 작업은 아무 곳에도 표시되지 않습니다.
  "notebook.insertToolbarLocation": "both",

  // 셀 편집기에서 줄 번호 표시를 제어합니다.
  "notebook.lineNumbers": "off",

  // Notebook에서 Markdown 셀의 선 높이를 픽셀 단위로 제어합니다. `0`(으)로 설정하면 `normal`이(가) 사용됩니다.
  "notebook.markdown.lineHeight": 0,

  // Notebook에서 렌더링된 태그의 글꼴 패밀리를 제어합니다. 비워 두면 기본 워크벤치 글꼴 패밀리로 대체됩니다.
  "notebook.markup.fontFamily": "",

  // 전자 필기장에서 렌더링된 태그의 글꼴 크기(픽셀)를 제어합니다. `0`(으)로 설정하면 `editor.fontSize`의 120%가 사용됩니다.
  "notebook.markup.fontSize": 0,

  // 실험적. Notebook 편집기의 여러 셀에서 제한된 다중 커서 컨트롤 집합을 사용하도록 설정합니다. 현재 지원되는 핵심 편집기 작업(입력/잘라내기/복사/붙여넣기/작성) 및 제한된 편집기 명령의 하위 집합입니다.
  "notebook.multiCursor.enabled": false,

  // 사용하도록 설정한 경우 커서는 셀 편집기의 현재 커서가 첫 번째/마지막 줄에 있을 때 다음/이전 셀로 이동할 수 있습니다.
  "notebook.navigation.allowNavigateToSurroundingCells": true,

  // 사용하도록 설정하면 Notebook 개요에 코드 셀이 표시됩니다.
  "notebook.outline.showCodeCells": false,

  // 사용하도록 설정하면 Notebook 개요에 코드 셀 기호가 표시됩니다. 사용 중인 'notebook.outline.showCodeCells'를 사용합니다.
  "notebook.outline.showCodeCellSymbols": true,

  // 사용하도록 설정하면 전자 필기장 개요에 머리글이 포함된 markdown 셀만 표시됩니다.
  "notebook.outline.showMarkdownHeadersOnly": true,

  // 전자 필기장 셀 내의 출력 텍스트의 글꼴 패밀리입니다. 비워 두면 `editor.fontFamily`이(가) 사용됩니다.
  "notebook.output.fontFamily": "",

  // 전자 필기장 셀 내의 출력 텍스트 글꼴 크기입니다. 0으로 설정하면 `editor.fontSize`이(가) 사용됩니다.
  "notebook.output.fontSize": 0,

  // 전자 필기장 셀 내의 출력 텍스트의 줄 높이입니다.
  //  - 0으로 설정하면 편집기 줄 높이가 사용됩니다.
  //  - 0에서 8 사이의 값은 글꼴 크기의 승수로 사용됩니다.
  //  - 8보다 크거나 같은 값이 유효 값으로 사용됩니다.
  "notebook.output.lineHeight": 0,

  // Notebook 셀의 출력에서 파일 경로 링크를 사용하지 않도록 설정할지 여부를 제어합니다.
  "notebook.output.linkifyFilePaths": true,

  // 최소 스타일로 오류 출력을 렌더링할지 여부를 제어합니다.
  "notebook.output.minimalErrorRendering": false,

  // 제한보다 긴 경우 스크롤 가능한 영역에서 Notebook 출력을 처음 렌더링합니다.
  "notebook.output.scrolling": false,

  // 텍스트 출력에 표시되는 텍스트 줄 수를 제어합니다. `notebook.output.scrolling`이(가) 활성화된 경우 이 설정을 사용하여 출력의 스크롤 높이를 결정합니다.
  "notebook.output.textLineLimit": 30,

  // 출력의 줄 바꿈 여부를 제어합니다.
  "notebook.output.wordWrap": false,

  // notebook.cell.executeAndSelectBelow 실행 시 다음 셀을 표시할 때 스크롤할 거리입니다.
  //  - fullCell: 스크롤하여 다음 셀을 완전히 표시합니다.
  //  - firstLine: 스크롤하여 다음 셀의 첫 번째 줄을 표시합니다.
  //  - none: 스크롤하지 마세요.
  "notebook.scrolling.revealNextCellOnExecute": "fullCell",

  // 셀 상태 표시줄 표시 여부가 표시됩니다.
  //  - hidden: 셀 상태 표시줄은 항상 숨겨져 있습니다.
  //  - visible: 셀 상태 표시줄은 항상 표시됩니다.
  //  - visibleAfterExecute: 셀 상태 표시줄은 셀이 실행될 때까지 숨겨집니다. 그런 다음 표시되어 실행 상태를 나타냅니다.
  "notebook.showCellStatusBar": "visible",

  // Markdown 헤더 접기 화살표가 표시되는 시기를 제어합니다.
  //  - always: 접기 컨트롤은 항상 표시됩니다.
  //  - never: 접기 컨트롤을 표시하지 않고 여백 크기를 줄이세요.
  //  - mouseover: 접기 컨트롤은 마우스를 올릴 시에만 표시됩니다.
  "notebook.showFoldingControls": "mouseover",

  // 실험. Notebook 편집기에서 Notebook 고정 스크롤 헤더를 렌더링할지 여부를 제어합니다.
  "notebook.stickyScroll.enabled": false,

  // 중첩된 고정선이 평평한 스택에 표시되는지 또는 들여쓰기된 상태로 표시되는지 제어합니다.
  //  - flat: 중첩된 고정선은 평평한 모양입니다.
  //  - indented: 중첩된 고정선이 들여쓰기된 것으로 나타납니다.
  "notebook.stickyScroll.mode": "indented",

  // 각 셀에 대해 별도의 실행 취소/다시 실행 스택을 사용할지 여부입니다.
  "notebook.undoRedoPerCell": true,

  // 디버그 패널 내에서 실험적 Notebook 변수 보기를 사용하도록 설정합니다.
  "notebook.variablesView": false,

  // 대화형 창을 자동으로 스크롤하여 실행된 마지막 문의 출력을 표시합니다. 이 값이 false이면 마지막 셀이 이미 스크롤된 셀인 경우에만 창이 스크롤됩니다.
  "interactiveWindow.alwaysScrollOnNewCell": true,

  // Shift+Enter를 사용하여 대화형 창(REPL) 입력 상자를 실행하면 Enter를 사용하여 줄 바꿈을 할 수 있습니다.
  "interactiveWindow.executeWithShiftEnter": false,

  // 대화형 창이 닫혀 있을 때 저장하라는 메시지가 표시됩니다. 새 대화형 창만 이 설정 변경의 영향을 받습니다.
  "interactiveWindow.promptToSaveOnClose": false,

  // 코드를 실행하는 방법을 나타내는 힌트를 REPL(대화형 창) 입력 상자에 표시합니다.
  "interactiveWindow.showExecutionHint": true,

  // 활성화된 경우 느린 렌더러가 자동으로 프로파일링됩니다.
  "application.experimental.rendererProfiling": false,

  // 터미널의 탐색기에서 파일을 열 때 어떤 종류의 터미널을 실행할지를 결정합니다.
  //  - integrated: 통합 터미널 작업을 표시합니다.
  //  - external: 외부 터미널 작업을 표시합니다.
  //  - both: 통합 및 외부 터미널 작업을 모두 표시합니다.
  "terminal.explorerKind": "integrated",

  // Linux에서 실행할 터미널을 사용자 지정합니다.
  "terminal.external.linuxExec": "xterm",

  // macOS에서 실행할 터미널 애플리케이션을 사용자 지정합니다.
  "terminal.external.osxExec": "Terminal.app",

  // Windows에서 실행할 터미널을 사용자 지정합니다.
  "terminal.external.windowsExec": "C:\\WINDOWS\\System32\\cmd.exe",

  // 터미널의 소스 제어 리포지토리 보기에서 리포지토리를 열 때 시작할 터미널 종류를 결정합니다.
  //  - integrated: 통합 터미널 작업을 표시합니다.
  //  - external: 외부 터미널 작업을 표시합니다.
  //  - both: 통합 및 외부 터미널 작업을 모두 표시합니다.
  "terminal.sourceControlRepositoriesKind": "integrated",

  // 편집기에서 AI 통계를 사용할지 여부를 제어합니다. 계기는 24시간 동안 AI가 삽입한 코드 양과 수동 입력의 평균을 나타냅니다.
  "editor.aiStats.enabled": false,

  // 자세한 편집 통계에 대한 원격 분석을 활성화할지 여부를 제어합니다(일반 원격 분석이 활성화된 경우에만 통계 전송).
  "telemetry.editStats.details.enabled": false,

  // 편집 통계에 대한 원격 분석을 활성화할지 여부를 제어합니다(일반 원격 분석이 활성화된 경우에만 통계 전송).
  "telemetry.editStats.enabled": true,

  // 원격 분석 편집을 위한 장식을 표시할지 여부를 제어합니다.
  "telemetry.editStats.showDecorations": false,

  // 원격 분석 편집을 위한 상태 표시줄을 표시할지 여부를 제어합니다.
  "telemetry.editStats.showStatusBar": false,

  // 자동 작업 활성화 - 작업은 신뢰할 수 없는 작업 영역에서 실행되지 않습니다.
  //  - on: 항상
  //  - off: 사용 안 함
  "task.allowAutomaticTasks": "on",

  // 모든 작업 공급자 확장에 `provideTasks`의 사용 여부를 제어합니다. Tasks: Run Task 명령이 느린 경우 작업 공급자에 대한 자동 검색을 사용하지 않도록 설정하면 도움이 될 수 있습니다. 또한 개별 확장은 자동 검색을 사용하지 않도록 하는 설정을 제공합니다.
  "task.autoDetect": "on",

  // 작업을 실행할 때 문제 선택기 프롬프트를 표시할지 여부를 구성합니다. 'true'로 설정하여 프롬프트하지 않거나 작업 유형 사전을 사용하여 특정 작업 유형에 대해서만 프롬프트를 해제합니다.
  "task.problemMatchers.neverPrompt": false,

  // 작업 빠른 선택에 세부 정보가 있는 작업의 작업 세부 정보를 표시할지를 제어합니다(예: 작업 실행).
  "task.quickOpen.detail": true,

  // 작업 Quick Open 대화 상자에서 추적된 최근 항목의 수를 제어합니다.
  "task.quickOpen.history": 30,

  // 작업: 작업 실행 명령에서 공급자별로 작업을 그룹화하는 빠른 두 수준 선택기 대신 느린 "모두 표시" 동작을 사용하게 합니다.
  "task.quickOpen.showAll": false,

  // 선택할 작업이 하나만 있는 경우 작업 빠른 선택을 건너뛰는지 여부를 제어합니다.
  "task.quickOpen.skip": false,

  // 창을 다시 로드할 때 문제 선택기가 있는 작업에 다시 연결합니다.
  "task.reconnection": true,

  // 작업을 실행하기 전에 모든 더티 편집기를 저장합니다.
  //  - always: 실행하기 전에 항상 모든 편집기를 저장합니다.
  //  - never: 실행하기 전에 편집기를 저장하지 않습니다.
  //  - prompt: 실행하기 전에 편집기를 저장할지 여부를 묻는 메시지를 표시합니다.
  "task.saveBeforeRun": "always",

  // 공급자 속도가 느린 경우 경고를 표시할지 여부를 구성합니다.
  "task.slowProviderWarning": true,

  // 작업에 대한 자세한 정보 로깅을 활성화합니다.
  "task.verboseLogging": false,

  // 공급자는 기본적으로 사용하도록 설정되어 있습니다. 공급자의 ID를 'false'로 설정하여 생략합니다.
  "terminal.integrated.suggest.providers": {
    "core:pwsh-shell-integration": false,
    "terminal-suggest": true
  },

  // 대신 `chat.tools.terminal.autoApprove`을(를) 사용하세요.
  //
  "chat.agent.terminal.allowList": null,

  // 대신 `chat.tools.terminal.autoApprove`을(를) 사용하세요.
  //
  "chat.agent.terminal.autoApprove": null,

  // 대신 `chat.tools.terminal.autoApprove`을(를) 사용하세요.
  //
  "chat.agent.terminal.denyList": null,

  // 터미널 도구 명령에서 실행하려면 명시적 승인이 필요한지 여부를 제어하는 명령 또는 정규식 목록입니다. 이 목록은 명령의 시작 부분과 일치합니다. 문자열을 `/` 문자로 래핑하고 `i`와(과) 같은 선택적 플래그를 사용하여(대소문자 구분 없음) 정규식을 제공할 수 있습니다.
  //
  // 명령을 자동으로 승인하려면 `true`(으)로 설정하고, 항상 명시적 승인을 요구하려면 `false`(으)로 설정하거나, 값을 해제하려면 `null`(으)로 설정합니다.
  //
  // 이러한 명령과 정규식은 전체 _command line_ 내의 모든 _sub-command_에 대해 평가되므로, 예를 들어 `foo && bar`은(는) `true` 항목과 일치하려면 `foo` 및 `bar`이(가) 모두 필요하며, 자동 승인되려면 `false` 항목과는 일치하지 않아야 합니다. 인라인 명령도 감지되므로 `echo $(rm file)`은(는) `echo $(rm file)` 및 `rm file` 모두 통과해야 합니다.
  //
  // 개체를 사용하여 하위 명령과 인라인 명령을 일치시키는 대신 전체 명령줄과 일치시킬 수 있습니다. 예: `{ approve: false, matchCommandLine: true }`. 자동으로 승인되려면 하위 명령과 명령줄 _둘 다_명시적으로 거부되지 않아야 하며, 그 후에 모든 하위 명령 _또는_ 명령줄이 승인되어야 합니다.
  //
  // 예:
  // |값|설명|
  // |---|---|
  // | `"mkdir": true` | `mkdir`(으)로 시작하는 모든 명령 허용
  // | `"npm run build": true` | `npm run build`(으)로 시작하는 모든 명령 허용
  // | `"/^git (status\|show\b.*)$/": true` | `git status` 허용 및 `git show`(으)로 시작하는 모든 명령 허용
  // | `"/^Get-ChildItem\b/i": true` | 대/소문자 구분에 관계없이 `Get-ChildItem` 명령 허용
  // | `"/.*/": true` | 모든 명령 허용(거부된 명령은 여전히 승인 필요)
  // | `"rm": false` | `rm`(으)로 시작하는 모든 명령에 대해 명시적 승인 요구
  // | `"/.ps1/i": { approve: false, matchCommandLine: true }` | 대/소문자에 관계없이 `".ps1"`이(가) 포함된 모든 _command line_에 대해 명시적 승인 요구
  // | `"rm": null` | `false`에 대한 기본 `rm` 값 설정 해제
  "chat.tools.terminal.autoApprove": {
    "rm": false,
    "rmdir": false,
    "del": false,
    "kill": false,
    "curl": false,
    "wget": false,
    "eval": false,
    "chmod": false,
    "chown": false,
    "/^Remove-Item\\b/i": false
  },

  // 대신 `chat.tools.terminal.autoApprove`을(를) 사용하세요.
  //
  "github.copilot.chat.agent.terminal.allowList": null,

  // 대신 `chat.tools.terminal.autoApprove`을(를) 사용하세요.
  //
  "github.copilot.chat.agent.terminal.denyList": null,

  // 명령이 실행될 때 터미널 접근성 보기에 포커스를 둡니다.
  "terminal.integrated.accessibleViewFocusOnCommandExecution": false,

  // 버퍼의 맨 아래로 설정하는 대신 터미널의 액세스 가능 보기를 다시 열 때 커서 위치를 유지합니다.
  "terminal.integrated.accessibleViewPreserveCursorPosition": false,

  // 터미널에서 동시 키 바인딩을 허용할지 여부입니다. 이 설정이 true이고 키 입력이 동시에 발생하는 경우 `terminal.integrated.commandsToSkipShell`이(가) 무시되고, 이 설정을 false로 설정하면 <Ctrl+K>를 눌러 셸(VS Code 아님)로 이동하려는 경우에 특히 유용합니다.
  "terminal.integrated.allowChords": true,

  // 터미널에서 링크를 열 수 있는 URI 체계를 포함하는 문자열 배열입니다. 기본적으로 보안상의 이유로 가능한 구성표의 작은 하위 집합만 허용됩니다.
  "terminal.integrated.allowedLinkSchemes": ["file", "http", "https", "mailto", "vscode", "vscode-insiders"],

  // 메뉴 모음 니모닉(예: Alt+F)이 메뉴 모음의 열기를 트리거하도록 허용할지입니다. 이렇게 하면 true일 때 모든 대체 키 입력이 셸을 건너뜁니다. macOS에서는 아무 작업도 수행하지 않습니다.
  "terminal.integrated.allowMnemonics": false,

  // 사용하도록 설정한 경우, `editor.multiCursorModifier`이(가) `'alt'`(기본값)(으)로 설정되어 있으면 Alt/option+클릭할 때 프롬프트 커서가 마우스 아래로 위치가 변경됩니다. 이 옵션은 셸에 따라 안정적으로 작동하지 않을 수 있습니다.
  "terminal.integrated.altClickMovesCursor": true,

  // 작업 및 디버그와 같은 자동화 관련 터미널 사용을 위해 Linux에서 사용할 터미널 프로필입니다.
  "terminal.integrated.automationProfile.linux": null,

  // macOS에서 작업 및 디버그와 같은 자동화 관련 터미널 사용에 사용할 터미널 프로필입니다.
  "terminal.integrated.automationProfile.osx": null,

  // 작업 및 디버그와 같은 자동화 관련 터미널 사용을 위해 사용할 터미널 프로필입니다. 이 설정은 현재 `terminal.integrated.automationShell.windows`(현재 사용되지 않음)이(가) 설정된 경우 무시됩니다.
  "terminal.integrated.automationProfile.windows": null,

  // 터미널에서 발견되면 자동으로 응답되는 메시지 집합입니다. 메시지가 충분히 구체적인 경우 일반적인 응답을 자동화하는 데 도움이 될 수 있습니다.
  //
  // 비고:
  //
  // - `"Terminate batch job (Y/N)": "Y\r"`을(를) 사용하여 Windows에서 일괄 작업 종료 프롬프트에 자동으로 응답합니다.
  // - 메시지에는 이스케이프 시퀀스가 포함되어 있어 스타일이 지정된 텍스트에서는 응답이 발생하지 않을 수 있습니다.
  // - 각 회신은 1초에 한 번만 발생할 수 있습니다.
  // - Enter 키를 의미하려면 회신에 `"\r"`을(를) 사용하세요.
  // - 기본 키를 설정 해제하려면 값을 null로 설정하세요.
  // - 새 항목이 적용되지 않으면 VS Code를 다시 시작합니다.
  "terminal.integrated.autoReplies": {},

  // 트리거될 때 터미널 탭 내에 벨을 표시할 시간(밀리초)입니다.
  "terminal.integrated.bellDuration": 1000,

  // 키 바인딩이 셸에 전송되지 않고 항상 VS Code에서 처리되는 명령 ID 세트입니다. 따라서 보통은 셸에서 사용되어 터미널에 포커스가 없을 때와 동일하게 작동하는 키 바인딩을 사용할 수 있습니다(예: 'Ctrl+P'를 사용하여 Quick Open 시작).
  //
  // &nbsp;
  //
  // 기본적으로 많은 명령을 건너뜁니다. 기본값을 재정의하고 명령의 키 바인딩을 셸로 대신 전달하려면 '-' 문자로 시작하는 명령을 추가합니다. 예를 들어 'Ctrl+P'를 사용하여 셸에 도달하려면 '-workbench.action.quickOpen'을 추가합니다.
  //
  // &nbsp;
  //
  // 설정 편집기에서 볼 때 다음의 기본 건너뛴 명령 목록이 잘립니다. 전체 목록을 보려면 [기본 설정 JSON 열기](command:workbench.action.openRawDefaultSettings '기본 설정 열기(JSON)')하고 아래 목록에서 첫 번째 명령을 검색합니다.
  //
  // &nbsp
  //
  // 기본 건너뛴 명령:
  //
  // - editor.action.accessibilityHelp
  // - editor.action.toggleTabFocusMode
  // - notification.acceptPrimaryAction
  // - notifications.hideList
  // - notifications.hideToasts
  // - runCommands
  // - workbench.action.closeQuickOpen
  // - workbench.action.debug.continue
  // - workbench.action.debug.disconnect
  // - workbench.action.debug.pause
  // - workbench.action.debug.restart
  // - workbench.action.debug.run
  // - workbench.action.debug.start
  // - workbench.action.debug.stepInto
  // - workbench.action.debug.stepOut
  // - workbench.action.debug.stepOver
  // - workbench.action.debug.stop
  // - workbench.action.firstEditorInGroup
  // - workbench.action.focusActiveEditorGroup
  // - workbench.action.focusEighthEditorGroup
  // - workbench.action.focusFifthEditorGroup
  // - workbench.action.focusFirstEditorGroup
  // - workbench.action.focusFourthEditorGroup
  // - workbench.action.focusLastEditorGroup
  // - workbench.action.focusNextPart
  // - workbench.action.focusPreviousPart
  // - workbench.action.focusSecondEditorGroup
  // - workbench.action.focusSeventhEditorGroup
  // - workbench.action.focusSixthEditorGroup
  // - workbench.action.focusThirdEditorGroup
  // - workbench.action.lastEditorInGroup
  // - workbench.action.navigateDown
  // - workbench.action.navigateLeft
  // - workbench.action.navigateRight
  // - workbench.action.navigateUp
  // - workbench.action.nextEditor
  // - workbench.action.nextEditorInGroup
  // - workbench.action.nextPanelView
  // - workbench.action.nextSideBarView
  // - workbench.action.openNextRecentlyUsedEditor
  // - workbench.action.openNextRecentlyUsedEditorInGroup
  // - workbench.action.openPreviousRecentlyUsedEditor
  // - workbench.action.openPreviousRecentlyUsedEditorInGroup
  // - workbench.action.previousEditor
  // - workbench.action.previousEditorInGroup
  // - workbench.action.previousPanelView
  // - workbench.action.previousSideBarView
  // - workbench.action.quickOpen
  // - workbench.action.quickOpenLeastRecentlyUsedEditor
  // - workbench.action.quickOpenLeastRecentlyUsedEditorInGroup
  // - workbench.action.quickOpenPreviousEditor
  // - workbench.action.quickOpenPreviousRecentlyUsedEditor
  // - workbench.action.quickOpenPreviousRecentlyUsedEditorInGroup
  // - workbench.action.quickOpenView
  // - workbench.action.showCommands
  // - workbench.action.tasks.build
  // - workbench.action.tasks.reRunTask
  // - workbench.action.tasks.rerunForActiveTerminal
  // - workbench.action.tasks.restartTask
  // - workbench.action.tasks.runTask
  // - workbench.action.tasks.showLog
  // - workbench.action.tasks.showTasks
  // - workbench.action.tasks.terminate
  // - workbench.action.tasks.test
  // - workbench.action.terminal.acceptSelectedSuggestion
  // - workbench.action.terminal.acceptSelectedSuggestionEnter
  // - workbench.action.terminal.chat.cancel
  // - workbench.action.terminal.chat.close
  // - workbench.action.terminal.chat.discard
  // - workbench.action.terminal.chat.feedbackHelpful
  // - workbench.action.terminal.chat.feedbackReportIssue
  // - workbench.action.terminal.chat.feedbackUnhelpful
  // - workbench.action.terminal.chat.insertCommand
  // - workbench.action.terminal.chat.makeRequest
  // - workbench.action.terminal.chat.runCommand
  // - workbench.action.terminal.chat.start
  // - workbench.action.terminal.chat.viewInChat
  // - workbench.action.terminal.clear
  // - workbench.action.terminal.clearSelection
  // - workbench.action.terminal.copyAndClearSelection
  // - workbench.action.terminal.copyLastCommand
  // - workbench.action.terminal.copyLastCommandAndLastCommandOutput
  // - workbench.action.terminal.copyLastCommandOutput
  // - workbench.action.terminal.copySelection
  // - workbench.action.terminal.copySelectionAsHtml
  // - workbench.action.terminal.deleteToLineStart
  // - workbench.action.terminal.deleteWordLeft
  // - workbench.action.terminal.deleteWordRight
  // - workbench.action.terminal.findNext
  // - workbench.action.terminal.findPrevious
  // - workbench.action.terminal.focus
  // - workbench.action.terminal.focusAccessibleBuffer
  // - workbench.action.terminal.focusAtIndex1
  // - workbench.action.terminal.focusAtIndex2
  // - workbench.action.terminal.focusAtIndex3
  // - workbench.action.terminal.focusAtIndex4
  // - workbench.action.terminal.focusAtIndex5
  // - workbench.action.terminal.focusAtIndex6
  // - workbench.action.terminal.focusAtIndex7
  // - workbench.action.terminal.focusAtIndex8
  // - workbench.action.terminal.focusAtIndex9
  // - workbench.action.terminal.focusFind
  // - workbench.action.terminal.focusHover
  // - workbench.action.terminal.focusNext
  // - workbench.action.terminal.focusNextPane
  // - workbench.action.terminal.focusPrevious
  // - workbench.action.terminal.focusPreviousPane
  // - workbench.action.terminal.goToRecentDirectory
  // - workbench.action.terminal.hideFind
  // - workbench.action.terminal.hideSuggestWidget
  // - workbench.action.terminal.kill
  // - workbench.action.terminal.killEditor
  // - workbench.action.terminal.moveToEditor
  // - workbench.action.terminal.moveToLineEnd
  // - workbench.action.terminal.moveToLineStart
  // - workbench.action.terminal.moveToTerminalPanel
  // - workbench.action.terminal.new
  // - workbench.action.terminal.newInActiveWorkspace
  // - workbench.action.terminal.paste
  // - workbench.action.terminal.pasteSelection
  // - workbench.action.terminal.requestCompletions
  // - workbench.action.terminal.resizePaneDown
  // - workbench.action.terminal.resizePaneLeft
  // - workbench.action.terminal.resizePaneRight
  // - workbench.action.terminal.resizePaneUp
  // - workbench.action.terminal.runActiveFile
  // - workbench.action.terminal.runRecentCommand
  // - workbench.action.terminal.runSelectedText
  // - workbench.action.terminal.scrollDown
  // - workbench.action.terminal.scrollDownPage
  // - workbench.action.terminal.scrollToBottom
  // - workbench.action.terminal.scrollToNextCommand
  // - workbench.action.terminal.scrollToPreviousCommand
  // - workbench.action.terminal.scrollToTop
  // - workbench.action.terminal.scrollUp
  // - workbench.action.terminal.scrollUpPage
  // - workbench.action.terminal.searchWorkspace
  // - workbench.action.terminal.selectAll
  // - workbench.action.terminal.selectNextPageSuggestion
  // - workbench.action.terminal.selectNextSuggestion
  // - workbench.action.terminal.selectPrevPageSuggestion
  // - workbench.action.terminal.selectPrevSuggestion
  // - workbench.action.terminal.selectToNextCommand
  // - workbench.action.terminal.selectToNextLine
  // - workbench.action.terminal.selectToPreviousCommand
  // - workbench.action.terminal.selectToPreviousLine
  // - workbench.action.terminal.sendSequence
  // - workbench.action.terminal.sizeToContentWidth
  // - workbench.action.terminal.split
  // - workbench.action.terminal.splitInActiveWorkspace
  // - workbench.action.terminal.suggestToggleDetails
  // - workbench.action.terminal.suggestToggleDetailsFocus
  // - workbench.action.terminal.toggleFindCaseSensitive
  // - workbench.action.terminal.toggleFindRegex
  // - workbench.action.terminal.toggleFindWholeWord
  // - workbench.action.terminal.toggleTerminal
  // - workbench.action.toggleFullScreen
  // - workbench.action.toggleMaximizedPanel
  // - workbench.action.togglePanel
  "terminal.integrated.commandsToSkipShell": [],

  // 활성 터미널 세션이 있는 경우 창을 닫을 때 확인할지 여부를 제어합니다. 일부 확장에서 시작한 것과 같은 백그라운드 터미널은 확인을 트리거하지 않습니다.
  //  - never: 확인하지 마세요.
  //  - always: 터미널이 있는지 항상 확인합니다.
  //  - hasChildProcesses: 자식 프로세스가 있는 터미널이 있는지 확인합니다.
  "terminal.integrated.confirmOnExit": "never",

  // 자식 프로세스가 있을 때 종료 터미널을 확인할지 여부를 제어합니다. 편집기로 설정하면 편집기 영역의 터미널에 자식 프로세스가 있을 때 변경된 상태로 표시됩니다. 자식 프로세스 감지는 셸의 자식 프로세스로 프로세스를 실행하지 않는 Git Bash와 같은 셸에서는 제대로 작동하지 않을 수 있습니다. 일부 확장 프로그램에서 실행된 것과 같은 백그라운드 터미널은 확인을 트리거하지 않습니다.
  //  - never: 확인하지 마세요.
  //  - editor: 터미널이 편집기에 있는지 확인합니다.
  //  - panel: 터미널이 패널에 있는지 확인합니다.
  //  - always: 터미널이 편집기 또는 패널에 있는지 확인합니다.
  "terminal.integrated.confirmOnKill": "editor",

  // 터미널에서 선택한 텍스트를 클립보드에 복사할지 여부를 제어합니다.
  "terminal.integrated.copyOnSelection": false,

  // 터미널 커서가 깜박이는지 여부를 제어합니다.
  "terminal.integrated.cursorBlinking": false,

  // 터미널에 포커스가 있을 때 터미널 커서의 스타일을 제어합니다.
  "terminal.integrated.cursorStyle": "block",

  // 터미널에 포커스가 없을 때 터미널 커서의 스타일을 제어합니다.
  "terminal.integrated.cursorStyleInactive": "outline",

  // `terminal.integrated.cursorStyle` 설정이 `line`(으)로 설정되어 있을 때 커서의 넓이를 제어합니다.
  "terminal.integrated.cursorWidth": 1,

  // 일반적으로 연속선으로 더 나은 렌더링을 생성하는 글꼴을 사용하는 대신 블록 요소 및 상자 그리기 문자에 사용자 지정 문자 모양을 사용할지를 결정합니다. `terminal.integrated.gpuAcceleration`이(가) 비활성화되어 있는 경우 작동하지 않습니다.
  "terminal.integrated.customGlyphs": true,

  // 터미널이 시작되는 명시적 시작 경로이며, 셸 프로세스의 cwd(현재 작업 디렉터리)로 사용됩니다. 루트 디렉터리가 편리한 cwd가 아닌 경우, 작업 영역 설정에서 특히 유용할 수 있습니다.
  "terminal.integrated.cwd": "",

  // 새로 만든 터미널이 표시되는 위치를 제어합니다.
  //  - editor: 편집기에서 터미널 만들기
  //  - view: 터미널 보기에서 터미널 만들기
  "terminal.integrated.defaultLocation": "view",

  // Linux의 기본 터미널 프로필입니다.
  "terminal.integrated.defaultProfile.linux": null,

  // macOS의 기본 터미널 프로필입니다.
  "terminal.integrated.defaultProfile.osx": null,

  // Windows의 기본 터미널 프로필입니다.
  //  - null: 자동으로 기본값 검색
  //  - PowerShell: $(terminal-powershell) PowerShell
  // - path: C:\WINDOWS\System32\WindowsPowerShell\v1.0\powershell.exe
  //  - Windows PowerShell: $(terminal-powershell) Windows PowerShell
  // - path: C:\WINDOWS\System32\WindowsPowerShell\v1.0\powershell.exe
  //  - Git Bash: $(terminal) Git Bash
  // - path: C:\Program Files\Git\bin\bash.exe
  // - args: ['--login','-i']
  //  - Command Prompt: $(terminal-cmd) Command Prompt
  // - path: C:\WINDOWS\System32\cmd.exe
  // - args: []
  //  - JavaScript 디버그 터미널: $($(debug)) JavaScript 디버그 터미널
  // - extensionIdentifier: ms-vscode.js-debug
  "terminal.integrated.defaultProfile.windows": null,

  // VS Code 터미널은 셸에서 들어오는, UTF-8로 인코딩된 데이터만 지원하므로 '$LANG' 환경 변수를 검색하고 UTF-8 규격 옵션으로 설정할지 여부를 제어합니다.
  //  - auto: 기존 변수가 없거나 `'.UTF-8'`로 끝나지 않는 경우 '$LANG' 환경 변수를 설정합니다.
  //  - off: '$LANG' 환경 변수를 설정하지 않습니다.
  //  - on: 항상 '$LANG' 환경 변수를 설정합니다.
  "terminal.integrated.detectLocale": "auto",

  // 터미널의 굵은 텍스트에 항상 "밝은" ANSI 색 변형을 사용할지 여부를 제어합니다.
  "terminal.integrated.drawBoldTextInBrightColors": true,

  // 이제 더 이상 사용되지 않습니다. 대신 'terminal.integrated.enableVisualBel' 및 'accessibility.signals.terminalBel' 설정을 사용합니다.
  //
  "terminal.integrated.enableBell": false,

  // 터미널에서 파일 링크를 사용할지 여부입니다. 파일 시스템에서 각 파일 링크를 확인하기 때문에 특히 네트워크 드라이브에서 작업하는 경우 링크가 느릴 수 있습니다. 이 설정을 변경하면 새 터미널에서만 적용됩니다.
  //  - off: 항상 꺼져 있습니다.
  //  - on: 항상 켜져 있습니다.
  //  - notRemote: 원격 작업 영역에 없는 경우에만 사용합니다.
  "terminal.integrated.enableFileLinks": "on",

  // 터미널에서 이미지 지원을 사용하도록 설정합니다. 이 기능은 `terminal.integrated.gpuAcceleration#` 사용하도록 설정된 경우에만 작동합니다. Linux 및 macOS에서는 sixel 및 iTerm의 인라인 이미지 프로토콜이 모두 지원됩니다. 이 작업은 Windows 자체와 함께 제공되는 ConPTY >= v2 버전에서만 작동합니다. `#terminal.integrated.windowsUseConptyDll` 참조하세요. 현재 창 다시 로드/다시 연결 간에 이미지가 복원되지 않습니다.
  "terminal.integrated.enableImages": false,

  // 터미널에 여러 줄을 붙여넣을 때 경고 대화 상자를 표시할지 여부를 제어합니다.
  //  - auto: 경고를 사용하도록 설정하지만 다음과 같은 경우 표시하지 않습니다.
  //
  // - 대괄호 붙여넣기 모드가 사용되는 경우(셸은 기본적으로 여러 줄 붙여넣기를 지원함)
  // - 붙여넣기는 셸의 readline에서 처리됩니다(pwsh의 경우).
  //  - always: 텍스트에 새 줄이 포함된 경우 항상 경고를 표시합니다.
  //  - never: 경고를 표시하지 않습니다.
  "terminal.integrated.enableMultiLinePasteWarning": "auto",

  // 창 다시 로드에서 작업 영역에 대한 터미널 세션/기록을 유지합니다.
  "terminal.integrated.enablePersistentSessions": true,

  // 시각적 터미널 벨을 사용할 수 있는지 여부를 제어합니다. 터미널 이름 옆에 표시됩니다.
  "terminal.integrated.enableVisualBell": false,

  // Linux 터미널에서 사용할 VS Code 프로세스에 추가되는 환경 변수를 포함하는 개체입니다. 환경 변수를 삭제하려면 'null'로 설정합니다.
  "terminal.integrated.env.linux": {},

  // macOS 터미널에서 사용할 VS Code 프로세스에 추가되는 환경 변수를 포함하는 개체입니다. 환경 변수를 삭제하려면 'null'로 설정합니다.
  "terminal.integrated.env.osx": {},

  // Windows 터미널에서 사용할 VS Code 프로세스에 추가되는 환경 변수를 포함하는 개체입니다. 환경 변수를 삭제하려면 'null'로 설정합니다.
  "terminal.integrated.env.windows": {},

  // 확장이 터미널 환경을 변경했거나 변경하려고 하는지 여부를 설명하는 환경 변경 표시기를 각 터미널에 표시할지 여부입니다.
  //  - off: 표시기를 사용하지 않도록 설정합니다.
  //  - on: 표시기를 사용하도록 설정합니다.
  //  - warnonly: 터미널 환경이 '부실'한 경우 경고 표시기만 표시하고, 터미널 환경이 확장을 통해 수정되었음을 나타내는 정보 표시기는 표시하지 않습니다.
  "terminal.integrated.environmentChangesIndicator": "warnonly",

  // 확장이 환경에 기여하기를 원하지만, 아직 상호 작용하지 않은 경우 터미널을 자동으로 다시 시작할지 여부입니다.
  "terminal.integrated.environmentChangesRelaunch": true,

  // 'Alt' 키를 누를 때의 스크롤 속도 승수입니다.
  "terminal.integrated.fastScrollSensitivity": 5,

  // '터미널: 활성 터미널에서 선택한 텍스트 실행'이 실행된 후 터미널, 액세스 가능한 버퍼 또는 둘 다 포커스를 지정할지 여부를 제어합니다.
  //  - terminal: 항상 터미널에 포커스를 지정합니다.
  //  - accessible-buffer: 항상 액세스 가능한 버퍼에 집중합니다.
  //  - none: 아무 작업도 하지 않습니다.
  "terminal.integrated.focusAfterRun": "none",

  // 터미널의 글꼴 패밀리를 제어합니다. 기본값은 `editor.fontFamily` 값입니다.
  "terminal.integrated.fontFamily": "",

  // 터미널에서 글꼴 합자를 사용할지 여부를 제어합니다. 합자는 구성된 `terminal.integrated.fontFamily` 구성에서 지원하는 경우에만 작동합니다.
  "terminal.integrated.fontLigatures.enabled": false,

  // `terminal.integrated.gpuAcceleration#` 사용하도록 설정되어 있고 특정 `#terminal.integrated.fontFamily` 구문 분석할 수 없는 경우 항상 함께 그려지는 문자 시퀀스 집합입니다. 글꼴이 지원되지 않는 경우에도 고정된 합자 집합을 사용할 수 있습니다.
  "terminal.integrated.fontLigatures.fallbackLigatures": [
    "<--",
    "<---",
    "<<-",
    "<-",
    "->",
    "->>",
    "-->",
    "--->",
    "<==",
    "<===",
    "<<=",
    "<=",
    "=>",
    "=>>",
    "==>",
    "===>",
    ">=",
    ">>=",
    "<->",
    "<-->",
    "<--->",
    "<---->",
    "<=>",
    "<==>",
    "<===>",
    "<====>",
    "::",
    ":::",
    "<~~",
    "</",
    "</>",
    "/>",
    "~~>",
    "==",
    "!=",
    "/=",
    "~=",
    "<>",
    "===",
    "!==",
    "!===",
    "<:",
    ":=",
    "*=",
    "*+",
    "<*",
    "<*>",
    "*>",
    "<|",
    "<|>",
    "|>",
    "+*",
    "=*",
    "=:",
    ":>",
    "/*",
    "*/",
    "+++",
    "<!--",
    "<!---"
  ],

  // 합자가 활성화될 때 사용되는 글꼴 기능 설정을 'font-feature-settings' CSS 속성 형식으로 제어합니다. 글꼴에 따라 유효한 몇 가지 예는 다음과 같습니다.
  //
  // - `"calt" off, "ss03"`
  // - `"liga" on`
  // - `"calt" off, "dlig" on`
  "terminal.integrated.fontLigatures.featureSettings": "\"calt\" on",

  // 터미널의 글꼴 크기(픽셀)를 제어합니다.
  "terminal.integrated.fontSize": 14,

  // 터미널 내에서 보통 텍스트에 사용할 글꼴 두께입니다. "일반" 및 "굵게" 키워드 또는 1에서 1,000 사이의 숫자를 허용합니다.
  "terminal.integrated.fontWeight": "normal",

  // 터미널 내에서 굵은 텍스트에 사용할 글꼴 두께입니다. "일반" 및 "굵게" 키워드 또는 1에서 1,000 사이의 숫자를 허용합니다.
  "terminal.integrated.fontWeightBold": "bold",

  // 터미널이 렌더링을 수행하기 위해 GPU를 활용하는지를 제어합니다.
  //  - auto: VS Code가 최상의 환경을 제공하는 렌더러를 검색하도록 합니다.
  //  - on: 터미널 내에서 GPU 가속을 사용하도록 설정합니다.
  //  - off: 터미널 내에서 GPU 가속을 비활성화합니다. GPU 가속이 꺼져 있으면 터미널이 훨씬 느리게 렌더링되지만 모든 시스템에서 안정적으로 작동해야 합니다.
  "terminal.integrated.gpuAcceleration": "auto",

  // 마지막 터미널이 닫혀 있을 때 터미널 보기를 숨길지 여부를 지정합니다. 이 문제는 터미널이 보기 컨테이너에 표시되는 유일한 보기인 경우에만 발생합니다.
  "terminal.integrated.hideOnLastClosed": true,

  // 시작 시 터미널 보기를 숨길지 여부를 지정하고 영구 세션이 없을 때 터미널을 만들지 않도록 합니다.
  //  - never: 시작 시 터미널 보기를 숨기지 마세요.
  //  - whenEmpty: 복원된 영구 세션이 없는 경우에만 터미널을 숨깁니다.
  //  - always: 영구 세션이 복원된 경우에도 터미널을 항상 숨깁니다.
  "terminal.integrated.hideOnStartup": "never",

  // 터미널이 모드로 전환된 경우에도 터미널이 대괄호로 묶인 붙여넣기 모드를 무시할지 여부를 제어하고 붙여넣을 때 `\x1b[200~` 및 `\x1b[201~` 시퀀스를 생략합니다. 이는 쉘이 예를 들어 하위 쉘에서 발생할 수 있는 모드를 준수하지 않을 때 유용합니다.
  "terminal.integrated.ignoreBracketedPasteMode": false,

  // `terminal.integrated.confirmOnKill` 설정을 사용할 때 무시할 프로세스 이름 집합입니다.
  "terminal.integrated.ignoreProcessNames": ["starship", "oh-my-posh", "bash", "zsh"],

  // 새 셸에서 $PATH 및 기타 개발 변수가 초기화되도록 로그인 셸을 제공할 수 있는 VS Code에서 환경을 상속해야 하는지 여부입니다. 이는 Windows에는 영향을 주지 않습니다.
  "terminal.integrated.inheritEnv": true,

  // 입력이 없는 첫 번째 터미널에 포커스가 있을 때 사용 가능한 작업에 대한 힌트를 표시할지 여부를 제어합니다.
  "terminal.integrated.initialHint": true,

  // 터미널의 문자 간격을 제어합니다. 문자 사이에 추가할 추가 픽셀 수를 나타내는 정수 값입니다.
  "terminal.integrated.letterSpacing": 0,

  // 터미널의 줄 높이를 제어합니다. 이 숫자와 터미널 글꼴 크기를 곱하여 실제 줄 높이(픽셀)를 구합니다.
  "terminal.integrated.lineHeight": 1,

  // 로컬 에코를 사용하도록 설정해야 하는 경우입니다. 그러면 `terminal.integrated.localEchoLatencyThreshold`이(가) 재정의됩니다.
  //  - on: 항상 사용
  //  - off: 항상 사용 안 함
  //  - auto: 원격 작업 영역에 대해서만 사용
  "terminal.integrated.localEchoEnabled": "off",

  // 터미널 제목에 이러한 프로그램 이름이 있으면 로컬 에코를 사용할 수 없습니다.
  "terminal.integrated.localEchoExcludePrograms": ["vim", "vi", "nano", "tmux"],

  // 서버 확인을 기다리지 않고 터미널에서 로컬 편집 내용이 에코되는 네트워크 지연 시간(밀리초)입니다. '0'이면 로컬 에코가 항상 켜지고, '-1'이면 로컬 에코가 사용하지 않도록 설정됩니다.
  "terminal.integrated.localEchoLatencyThreshold": 30,

  // 로컬로 에코되는 텍스트의 터미널 스타일(글꼴 스타일 또는 RGB 색)입니다.
  "terminal.integrated.localEchoStyle": "dim",

  // macOS에서 <Option+클릭>을 사용할 때 특정 항목을 강제로 선택할지 여부를 제어합니다. 사용하도록 설정하면 일반(줄) 항목이 강제로 선택되며 열 선택 모드를 사용할 수 없습니다. 예를 들어 tmux에서 마우스 모드를 사용하는 경우, 일반 터미널 항목을 선택하여 복사 및 붙여넣기를 수행할 수 있습니다.
  "terminal.integrated.macOptionClickForcesSelection": false,

  // macOS의 터미널에서 옵션 키를 meta 키로 처리할지 여부를 제어합니다.
  "terminal.integrated.macOptionIsMeta": false,

  // 터미널이 가운데 클릭에 반응하는 방식을 제어합니다.
  //  - default: 플랫폼 기본값은 터미널에 집중합니다. Linux에서 선택 항목도 붙여넣습니다.
  //  - paste: 가운데 클릭에 붙여넣습니다.
  "terminal.integrated.middleClickBehavior": "default",

  // 이 옵션을 설정하면 각 셀의 전경색이 지정된 대비 비율에 맞게 변경됩니다. #146406의 `powerline` 문자에는 적용되지 않습니다. 값 예:
  //
  // - 1: 아무 작업도 하지 않고 표준 테마 색상을 사용합니다.
  // - 4.5: [WCAG AA 준수(최소)](https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html)(기본값)
  // - 7: [WCAG AAA 준수(향상됨)](https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast7.html)
  // - 21: 검정 바탕에 흰색 또는 흰색 바탕에 검정
  "terminal.integrated.minimumContrastRatio": 4.5,

  // 마우스 휠 스크롤 이벤트의 'deltaY'에 사용할 승수입니다.
  "terminal.integrated.mouseWheelScrollSensitivity": 1,

  // 마우스 휠을 사용하고 'Ctrl'을 길게 누를 때 터미널의 글꼴을 확대/축소합니다.
  "terminal.integrated.mouseWheelZoom": false,

  // 터미널 프로세스를 종료해야 하는 경우(예: 창 또는 애플리케이션을 닫을 때) 작업 영역이 다음에 열릴 때 이전 터미널 세션 내용/기록을 복원하고 프로세스를 다시 생성해야 하는 시기를 결정합니다.
  //
  // 주의:
  //
  // - 프로세스의 현재 작업 디렉터리 복원은 셸의 지원 여부에 따라 달라집니다.
  // - 종료 중에는 세션을 유지하는 시간이 제한되어 있으므로 대기 시간이 긴 원격 연결을 사용할 때 세션이 중단될 수 있습니다.
  //  - onExit: Windows/Linux에서 마지막 창이 닫힌 후 또는 `workbench.action.quit` 명령이 트리거될 때(명령 팔레트, 키 바인딩, 메뉴) 프로세스를 되살리세요.
  //  - onExitAndWindowClose: Windows/Linux에서 마지막 창이 닫힌 후 또는 `workbench.action.quit` 명령이 트리거될 때(명령 팔레트, 키 바인딩, 메뉴) 또는 창이 닫힐 때 프로세스를 되살리세요.
  //  - never: 터미널 버퍼를 복원하거나 프로세스를 다시 생성하지 마세요.
  "terminal.integrated.persistentSessionReviveProcess": "onExit",

  // 영구 터미널 세션에 다시 연결할 때 복원될 최대 라인 수를 제어합니다. 이 값을 늘리면 더 많은 메모리를 사용하여 더 많은 스크롤백 라인을 복원하고 시작 시 터미널에 연결하는 데 걸리는 시간이 늘어납니다. 이 설정을 적용하려면 다시 시작해야 하며 `terminal.integrated.scrollback`보다 작거나 같은 값으로 설정해야 합니다.
  "terminal.integrated.persistentSessionScrollback": 100,

  // 터미널 시작 방법을 추가, 제거 또는 변경할 수 있도록 하는 Linux의 터미널 프로필 사용자 지정 집합입니다. 프로필은 필수 경로, 선택적 인수 및 기타 프레젠테이션 옵션으로 구성됩니다.
  //
  // 기존 프로필을 재정의하려면 해당 프로필 이름을 키로 사용합니다. 예를 들면 다음과 같습니다.
  //
  // ```json
  // "terminal.integrated.profile.linux": {
  //   "bash": null
  // }
  // ```
  //
  // [프로필 구성에 대해 자세히 알아보세요.](https://code.visualstudio.com/docs/terminal/profiles)
  "terminal.integrated.profiles.linux": {
    "bash": {
      "path": "bash",
      "icon": "terminal-bash"
    },
    "zsh": {
      "path": "zsh"
    },
    "fish": {
      "path": "fish"
    },
    "tmux": {
      "path": "tmux",
      "icon": "terminal-tmux"
    },
    "pwsh": {
      "path": "pwsh",
      "icon": "terminal-powershell"
    }
  },

  // 터미널 시작 방법을 추가, 제거 또는 변경할 수 있도록 하는 Mac의 터미널 프로필 사용자 지정 집합입니다. 프로필은 필수 경로, 선택적 인수 및 기타 프레젠테이션 옵션으로 구성됩니다.
  //
  // 기존 프로필을 재정의하려면 해당 프로필 이름을 키로 사용합니다. 예를 들면 다음과 같습니다.
  //
  // ```json
  // "terminal.integrated.profile.osx": {
  //   "bash": null
  // }
  // ```
  //
  // [프로필 구성에 대해 자세히 알아보세요.](https://code.visualstudio.com/docs/terminal/profiles)
  "terminal.integrated.profiles.osx": {
    "bash": {
      "path": "bash",
      "args": ["-l"],
      "icon": "terminal-bash"
    },
    "zsh": {
      "path": "zsh",
      "args": ["-l"]
    },
    "fish": {
      "path": "fish",
      "args": ["-l"]
    },
    "tmux": {
      "path": "tmux",
      "icon": "terminal-tmux"
    },
    "pwsh": {
      "path": "pwsh",
      "icon": "terminal-powershell"
    }
  },

  // 터미널 시작 방법을 추가, 제거 또는 변경할 수 있도록 하는 Windows의 터미널 프로필 사용자 지정 집합입니다. 프로필은 필수 경로, 선택적 인수 및 기타 프레젠테이션 옵션으로 구성됩니다.
  //
  // 기존 프로필을 재정의하려면 해당 프로필 이름을 키로 사용합니다. 예를 들면 다음과 같습니다.
  //
  // ```json
  // "terminal.integrated.profile.windows": {
  //   "bash": null
  // }
  // ```
  //
  // [프로필 구성에 대해 자세히 알아보세요.](https://code.visualstudio.com/docs/terminal/profiles)
  "terminal.integrated.profiles.windows": {
    "PowerShell": {
      "source": "PowerShell",
      "icon": "terminal-powershell"
    },
    "Command Prompt": {
      "path": ["${env:windir}\\Sysnative\\cmd.exe", "${env:windir}\\System32\\cmd.exe"],
      "args": [],
      "icon": "terminal-cmd"
    },
    "Git Bash": {
      "source": "Git Bash"
    }
  },

  // 단일 셀 너비이지만 다음 셀과 겹치는 문자 모양이 있는 문자 모양을 가로로 다시 조정할지 여부입니다. 이는 일반적으로 모노스페이스 글꼴에 표시되지 않는 모호한 너비 문자(예: 로마 숫자 문자 U+2160+)에 대해 발생합니다. 이모지 문자 모양은 크기가 다시 조정되지 않습니다.
  "terminal.integrated.rescaleOverlappingGlyphs": true,

  // 터미널이 오른쪽 클릭에 반응하는 방식을 제어합니다.
  //  - default: 상황에 맞는 메뉴를 표시합니다.
  //  - copyPaste: 선택 항목이 있으면 복사하고, 없으면 붙여넣습니다.
  //  - paste: 마우스 오른쪽 단추를 클릭하여 붙여넣습니다.
  //  - selectWord: 커서 아래 단어를 선택하고 상황에 맞는 메뉴를 표시합니다.
  //  - nothing: 아무 것도 하지 않고 이벤트를 터미널에 전달합니다.
  "terminal.integrated.rightClickBehavior": "copyPaste",

  // 터미널이 버퍼에 보관하는 최대 라인 수를 제어합니다. 원활한 환경을 보장하기 위해 이 값을 기반으로 메모리를 사전 할당합니다. 따라서 값이 증가하면 메모리 양도 증가합니다.
  "terminal.integrated.scrollback": 1000,

  // 대부분의 키 바인딩을 워크벤치 대신 터미널에 디스패치하여 미세 조정을 위해 대신 사용할 수 있는 `terminal.integrated.commandsToSkipShell`을(를) 재정의합니다.
  "terminal.integrated.sendKeybindingsToShell": false,

  // 쉘 통합이 사용되면 각 명령에 대한 장식을 추가합니다.
  //  - both: 여백에 장식 표시(왼쪽) 및 개요 눈금자(오른쪽)
  //  - gutter: 터미널 왼쪽에 여백 장식 표시
  //  - overviewRuler: 터미널 오른쪽에 개요 눈금자 장식 표시
  //  - never: 장식 표시 안 함
  "terminal.integrated.shellIntegration.decorationsEnabled": "both",

  // 향상된 명령 추적 및 현재 작업 디렉토리 감지와 같은 기능을 지원하기 위해 셸 통합이 자동 삽입되는지 여부를 결정합니다.
  //
  // 셸 통합은 시작 스크립트와 함께 셸을 삽입하여 작동합니다. 이 스크립트는 터미널 내에서 발생하는 일에 대한 VS Code 인사이트를 제공합니다.
  //
  // 지원되는 셸:
  //
  // - Linux/macOS: bash, fish, pwsh, zsh
  //  - Windows: pwsh, git bash
  //
  // 이 설정은 터미널이 생성될 때만 적용되므로 적용하려면 터미널을 다시 시작해야 합니다.
  //
  //  터미널 프로필에 정의된 사용자 지정 인수가 있거나`editor.accessibilitySupport#`을(를) 활성화했거나 [복잡한 bash `PROMPT_COMMAND`](https://code.visualstudio.com/docs/editor/integrated-terminal#_complex-bash-promptcommand) 또는 기타 지원되지 않는 설정이 있는 경우 스크립트 삽입이 작동하지 않을 수 있습니다. 장식을 비활성화하려면 `#terminal.integrated.shellIntegration.decorationsEnabled`을(를) 참조하세요.
  "terminal.integrated.shellIntegration.enabled": true,

  // 셸 환경을 보고할지 여부를 제어하여 `terminal.integrated.suggest.enabled` 같은 기능에서 사용할 수 있도록 합니다. 셸 프롬프트를 인쇄할 때 속도가 느려질 수 있습니다.
  "terminal.integrated.shellIntegration.environmentReporting": false,

  // 터미널 명령 기록에 보관할 최근에 사용한 명령의 수를 제어합니다. 터미널 명령 기록을 사용하지 않도록 설정하려면 0으로 설정합니다.
  "terminal.integrated.shellIntegration.history": 100,

  // 터미널에서 마우스로 명령을 가리킬 때 명령 가이드를 표시할지 여부를 지정합니다.
  "terminal.integrated.shellIntegration.showCommandGuide": true,

  // 종료 코드가 0이 아닌 경우 "터미널 프로세스가 다음 종료 코드로 종료되었습니다"라는 경고를 표시할지 여부를 제어합니다.
  "terminal.integrated.showExitAlert": true,

  // 터미널 출력의 링크에 대한 마우스를 표시할지 여부입니다.
  "terminal.integrated.showLinkHover": true,

  // 터미널이 애니메이션을 사용하여 스크롤할지 여부를 제어합니다.
  "terminal.integrated.smoothScrolling": false,

  // 분할된 터미널이 시작되는 작업 디렉터리를 제어합니다.
  //  - workspaceRoot: 새 분할 터미널은 작업 영역 루트를 작업 디렉터리로 사용합니다. 다중 루트 작업 영역에서는 사용할 루트 폴더의 선택 항목이 제공됩니다.
  //  - initial: 새 분할 터미널은 부모 터미널이 시작된 작업 디렉터리를 사용합니다.
  //  - inherited: macOS 및 Linux에서 새 분할 터미널은 부모 터미널의 작업 디렉터리를 사용합니다. Windows에서는 초기 설정과 동일하게 동작합니다.
  "terminal.integrated.splitCwd": "inherited",

  // 터미널 맨 위에 현재 명령을 표시합니다. 이 기능을 사용하려면 [shell integration](https://code.visualstudio.com/docs/terminal/shell-integration)을 활성화해야 합니다. `terminal.integrated.shellIntegration.enabled` 참조하세요.
  "terminal.integrated.stickyScroll.enabled": false,

  // 표시할 최대 고정 선 수를 정의합니다. 이 설정에 관계없이 고정 스크롤 선은 뷰포트의 40%를 초과하지 않습니다.
  "terminal.integrated.stickyScroll.maxLineCount": 5,

  // 현재 작업 디렉터리에 관계없이 $CDPATH 변수에 있는 폴더의 자식을 노출하는 $CDPATH 지원을 사용할지 여부를 제어합니다. $CDPATH Windows에서는 세미콜론으로 구분되고 다른 플랫폼에서는 콜론으로 구분되어야 합니다.
  //  - off: 기능을 사용하지 않도록 설정합니다.
  //  - relative: 기능을 사용하도록 설정하고 상대 경로를 사용합니다.
  //  - absolute: 기능을 사용하도록 설정하고 절대 경로를 사용합니다. 셸이 기본적으로 '$CDPATH'을 지원하지 않는 경우에 유용합니다.
  "terminal.integrated.suggest.cdPath": "absolute",

  // `terminal.integrated.shellIntegration.enabled`이(가) `true`(으)로 설정된 경우 지원되는 셸(PowerShell v7+, zsh, bash, fish)에 대한 터미널 Intellisense 제안(미리 보기)을 활성화합니다.
  //
  // 셸 통합을 수동으로 설치한 경우 셸 통합 스크립트를 호출하기 전에 `VSCODE_SUGGEST`을(를) `1`(으)로 설정해야 합니다.
  "terminal.integrated.suggest.enabled": false,

  // 셸의 인라인 제안을 검색해야 하는지 여부와 점수 매기기 방법을 제어합니다.
  //  - off: 기능을 사용하지 않도록 설정합니다.
  //  - alwaysOnTopExceptExactMatch: 기능을 사용하도록 설정하고 인라인 제안을 강제로 맨 위에 표시하지 않고 정렬합니다. 즉, 정확한 일치 항목이 인라인 제안 위에 표시됩니다.
  //  - alwaysOnTop: 기능을 사용하도록 설정하고 항상 인라인 제안을 맨 위에 배치합니다.
  "terminal.integrated.suggest.inlineSuggestion": "alwaysOnTop",

  // 입력하는 동안 제안을 자동으로 표시할지 여부를 제어합니다. 또한 제안이 특수 문자에 의해 실행되는지 여부를 제어하는 `terminal.integrated.suggest.suggestOnTriggerCharacters`-설정에 유의하세요.
  "terminal.integrated.suggest.quickSuggestions": {
    "commands": "on",
    "arguments": "on",
    "unknown": "off"
  },

  // `Enter` 키(`Tab` 아님)를 사용하여 결과를 수락할 때 제안이 즉시 실행될지 여부를 제어합니다.
  //  - never: `Enter` 키를 눌러도 실행되지 않습니다.
  //  - exactMatch: 제안이 완전히 입력되면 `Enter` 키에서 실행합니다.
  //  - exactMatchIgnoreExtension: 제안을 모두 입력하거나 확장명 없이 파일을 입력할 때 `Enter` 키를 누르면 실행됩니다.
  //  - always: `Enter` 키를 누르면 항상 실행됩니다.
  "terminal.integrated.suggest.runOnEnter": "never",

  // 통합 터미널에서 제안 선택이 작동하는 방식을 제어합니다.
  //  - partial: IntelliSense를 자동으로 트리거할 때 제안을 부분적으로 선택하세요. 'Tab'은 첫 번째 제안을 수락하는 데 사용할 수 있습니다. 'Enter'는 'Down'을 통해 제안을 탐색한 후에만 활성 제안을 수락합니다.
  //  - always: IntelliSense를 자동으로 트리거할 때 항상 제안을 선택하세요. 'Enter' 또는 'Tab'을 사용하여 첫 번째 제안을 수락할 수 있습니다.
  //  - never: IntelliSense를 자동으로 트리거할 때 제안을 선택하지 마세요. 활성 제안을 수락하려면 먼저 `Down` 키로 목록에서 항목을 선택한 후에야 `Enter` 또는 `Tab` 키를 사용할 수 있습니다.
  "terminal.integrated.suggest.selectionMode": "partial",

  // 터미널 제안 상태 표시줄을 표시할지 여부를 제어합니다.
  "terminal.integrated.suggest.showStatusBar": true,

  // 트리거 문자를 입력할 때 제안을 자동으로 표시할지 여부를 제어합니다.
  "terminal.integrated.suggest.suggestOnTriggerCharacters": true,

  // 포커스가 첫 번째 제안에 있고 탐색이 아직 발생하지 않은 경우 위쪽 화살표 키가 명령 기록을 탐색하는지 여부를 결정합니다. false로 설정하면 위쪽 화살표가 포커스를 대신 마지막 제안으로 이동합니다.
  "terminal.integrated.suggest.upArrowNavigatesHistory": true,

  // 터미널에서 제안 사항으로 포함되는 Windows 명령 실행 파일 확장 집합입니다.
  //
  // 대부분의 실행 파일은 기본적으로 아래에 나열되어 있습니다.
  //
  // - bat
  // - cmd
  // - com
  // - exe
  // - jar
  // - js
  // - msi
  // - pl
  // - ps1
  // - py
  // - rb
  // - sh
  // - vbs.
  //
  // 확장을 제외하려면 'false'로 설정하세요.
  //
  // . 목록에 없는 항목을 포함하려면 추가한 후 'true'로 설정하세요.
  "terminal.integrated.suggest.windowsExecutableExtensions": {},

  // 기본적으로 터미널 아이콘과 연결할 테마 색 ID입니다.
  "terminal.integrated.tabs.defaultColor": null,

  // 기본적으로 터미널 아이콘과 연결할 코디콘 ID입니다.
  //  - add: $(add)
  //  - plus: $(plus)
  //  - gist-new: $(gist-new)
  //  - repo-create: $(repo-create)
  //  - lightbulb: $(lightbulb)
  //  - light-bulb: $(light-bulb)
  //  - repo: $(repo)
  //  - repo-delete: $(repo-delete)
  //  - gist-fork: $(gist-fork)
  //  - repo-forked: $(repo-forked)
  //  - git-pull-request: $(git-pull-request)
  //  - git-pull-request-abandoned: $(git-pull-request-abandoned)
  //  - record-keys: $(record-keys)
  //  - keyboard: $(keyboard)
  //  - tag: $(tag)
  //  - git-pull-request-label: $(git-pull-request-label)
  //  - tag-add: $(tag-add)
  //  - tag-remove: $(tag-remove)
  //  - person: $(person)
  //  - person-follow: $(person-follow)
  //  - person-outline: $(person-outline)
  //  - person-filled: $(person-filled)
  //  - git-branch: $(git-branch)
  //  - git-branch-create: $(git-branch-create)
  //  - git-branch-delete: $(git-branch-delete)
  //  - source-control: $(source-control)
  //  - mirror: $(mirror)
  //  - mirror-public: $(mirror-public)
  //  - star: $(star)
  //  - star-add: $(star-add)
  //  - star-delete: $(star-delete)
  //  - star-empty: $(star-empty)
  //  - comment: $(comment)
  //  - comment-add: $(comment-add)
  //  - alert: $(alert)
  //  - warning: $(warning)
  //  - search: $(search)
  //  - search-save: $(search-save)
  //  - log-out: $(log-out)
  //  - sign-out: $(sign-out)
  //  - log-in: $(log-in)
  //  - sign-in: $(sign-in)
  //  - eye: $(eye)
  //  - eye-unwatch: $(eye-unwatch)
  //  - eye-watch: $(eye-watch)
  //  - circle-filled: $(circle-filled)
  //  - primitive-dot: $(primitive-dot)
  //  - close-dirty: $(close-dirty)
  //  - debug-breakpoint: $(debug-breakpoint)
  //  - debug-breakpoint-disabled: $(debug-breakpoint-disabled)
  //  - debug-hint: $(debug-hint)
  //  - terminal-decoration-success: $(terminal-decoration-success)
  //  - primitive-square: $(primitive-square)
  //  - edit: $(edit)
  //  - pencil: $(pencil)
  //  - info: $(info)
  //  - issue-opened: $(issue-opened)
  //  - gist-private: $(gist-private)
  //  - git-fork-private: $(git-fork-private)
  //  - lock: $(lock)
  //  - mirror-private: $(mirror-private)
  //  - close: $(close)
  //  - remove-close: $(remove-close)
  //  - x: $(x)
  //  - repo-sync: $(repo-sync)
  //  - sync: $(sync)
  //  - clone: $(clone)
  //  - desktop-download: $(desktop-download)
  //  - beaker: $(beaker)
  //  - microscope: $(microscope)
  //  - vm: $(vm)
  //  - device-desktop: $(device-desktop)
  //  - file: $(file)
  //  - file-text: $(file-text)
  //  - more: $(more)
  //  - ellipsis: $(ellipsis)
  //  - kebab-horizontal: $(kebab-horizontal)
  //  - mail-reply: $(mail-reply)
  //  - reply: $(reply)
  //  - organization: $(organization)
  //  - organization-filled: $(organization-filled)
  //  - organization-outline: $(organization-outline)
  //  - new-file: $(new-file)
  //  - file-add: $(file-add)
  //  - new-folder: $(new-folder)
  //  - file-directory-create: $(file-directory-create)
  //  - trash: $(trash)
  //  - trashcan: $(trashcan)
  //  - history: $(history)
  //  - clock: $(clock)
  //  - folder: $(folder)
  //  - file-directory: $(file-directory)
  //  - symbol-folder: $(symbol-folder)
  //  - logo-github: $(logo-github)
  //  - mark-github: $(mark-github)
  //  - github: $(github)
  //  - terminal: $(terminal)
  //  - console: $(console)
  //  - repl: $(repl)
  //  - zap: $(zap)
  //  - symbol-event: $(symbol-event)
  //  - error: $(error)
  //  - stop: $(stop)
  //  - variable: $(variable)
  //  - symbol-variable: $(symbol-variable)
  //  - array: $(array)
  //  - symbol-array: $(symbol-array)
  //  - symbol-module: $(symbol-module)
  //  - symbol-package: $(symbol-package)
  //  - symbol-namespace: $(symbol-namespace)
  //  - symbol-object: $(symbol-object)
  //  - symbol-method: $(symbol-method)
  //  - symbol-function: $(symbol-function)
  //  - symbol-constructor: $(symbol-constructor)
  //  - symbol-boolean: $(symbol-boolean)
  //  - symbol-null: $(symbol-null)
  //  - symbol-numeric: $(symbol-numeric)
  //  - symbol-number: $(symbol-number)
  //  - symbol-structure: $(symbol-structure)
  //  - symbol-struct: $(symbol-struct)
  //  - symbol-parameter: $(symbol-parameter)
  //  - symbol-type-parameter: $(symbol-type-parameter)
  //  - symbol-key: $(symbol-key)
  //  - symbol-text: $(symbol-text)
  //  - symbol-reference: $(symbol-reference)
  //  - go-to-file: $(go-to-file)
  //  - symbol-enum: $(symbol-enum)
  //  - symbol-value: $(symbol-value)
  //  - symbol-ruler: $(symbol-ruler)
  //  - symbol-unit: $(symbol-unit)
  //  - activate-breakpoints: $(activate-breakpoints)
  //  - archive: $(archive)
  //  - arrow-both: $(arrow-both)
  //  - arrow-down: $(arrow-down)
  //  - arrow-left: $(arrow-left)
  //  - arrow-right: $(arrow-right)
  //  - arrow-small-down: $(arrow-small-down)
  //  - arrow-small-left: $(arrow-small-left)
  //  - arrow-small-right: $(arrow-small-right)
  //  - arrow-small-up: $(arrow-small-up)
  //  - arrow-up: $(arrow-up)
  //  - bell: $(bell)
  //  - bold: $(bold)
  //  - book: $(book)
  //  - bookmark: $(bookmark)
  //  - debug-breakpoint-conditional-unverified: $(debug-breakpoint-conditional-unverified)
  //  - debug-breakpoint-conditional: $(debug-breakpoint-conditional)
  //  - debug-breakpoint-conditional-disabled: $(debug-breakpoint-conditional-disabled)
  //  - debug-breakpoint-data-unverified: $(debug-breakpoint-data-unverified)
  //  - debug-breakpoint-data: $(debug-breakpoint-data)
  //  - debug-breakpoint-data-disabled: $(debug-breakpoint-data-disabled)
  //  - debug-breakpoint-log-unverified: $(debug-breakpoint-log-unverified)
  //  - debug-breakpoint-log: $(debug-breakpoint-log)
  //  - debug-breakpoint-log-disabled: $(debug-breakpoint-log-disabled)
  //  - briefcase: $(briefcase)
  //  - broadcast: $(broadcast)
  //  - browser: $(browser)
  //  - bug: $(bug)
  //  - calendar: $(calendar)
  //  - case-sensitive: $(case-sensitive)
  //  - check: $(check)
  //  - checklist: $(checklist)
  //  - chevron-down: $(chevron-down)
  //  - chevron-left: $(chevron-left)
  //  - chevron-right: $(chevron-right)
  //  - chevron-up: $(chevron-up)
  //  - chrome-close: $(chrome-close)
  //  - chrome-maximize: $(chrome-maximize)
  //  - chrome-minimize: $(chrome-minimize)
  //  - chrome-restore: $(chrome-restore)
  //  - circle-outline: $(circle-outline)
  //  - circle: $(circle)
  //  - debug-breakpoint-unverified: $(debug-breakpoint-unverified)
  //  - terminal-decoration-incomplete: $(terminal-decoration-incomplete)
  //  - circle-slash: $(circle-slash)
  //  - circuit-board: $(circuit-board)
  //  - clear-all: $(clear-all)
  //  - clippy: $(clippy)
  //  - close-all: $(close-all)
  //  - cloud-download: $(cloud-download)
  //  - cloud-upload: $(cloud-upload)
  //  - code: $(code)
  //  - collapse-all: $(collapse-all)
  //  - color-mode: $(color-mode)
  //  - comment-discussion: $(comment-discussion)
  //  - credit-card: $(credit-card)
  //  - dash: $(dash)
  //  - dashboard: $(dashboard)
  //  - database: $(database)
  //  - debug-continue: $(debug-continue)
  //  - debug-disconnect: $(debug-disconnect)
  //  - debug-pause: $(debug-pause)
  //  - debug-restart: $(debug-restart)
  //  - debug-start: $(debug-start)
  //  - debug-step-into: $(debug-step-into)
  //  - debug-step-out: $(debug-step-out)
  //  - debug-step-over: $(debug-step-over)
  //  - debug-stop: $(debug-stop)
  //  - debug: $(debug)
  //  - device-camera-video: $(device-camera-video)
  //  - device-camera: $(device-camera)
  //  - device-mobile: $(device-mobile)
  //  - diff-added: $(diff-added)
  //  - diff-ignored: $(diff-ignored)
  //  - diff-modified: $(diff-modified)
  //  - diff-removed: $(diff-removed)
  //  - diff-renamed: $(diff-renamed)
  //  - diff: $(diff)
  //  - diff-sidebyside: $(diff-sidebyside)
  //  - discard: $(discard)
  //  - editor-layout: $(editor-layout)
  //  - empty-window: $(empty-window)
  //  - exclude: $(exclude)
  //  - extensions: $(extensions)
  //  - eye-closed: $(eye-closed)
  //  - file-binary: $(file-binary)
  //  - file-code: $(file-code)
  //  - file-media: $(file-media)
  //  - file-pdf: $(file-pdf)
  //  - file-submodule: $(file-submodule)
  //  - file-symlink-directory: $(file-symlink-directory)
  //  - file-symlink-file: $(file-symlink-file)
  //  - file-zip: $(file-zip)
  //  - files: $(files)
  //  - filter: $(filter)
  //  - flame: $(flame)
  //  - fold-down: $(fold-down)
  //  - fold-up: $(fold-up)
  //  - fold: $(fold)
  //  - folder-active: $(folder-active)
  //  - folder-opened: $(folder-opened)
  //  - gear: $(gear)
  //  - gift: $(gift)
  //  - gist-secret: $(gist-secret)
  //  - gist: $(gist)
  //  - git-commit: $(git-commit)
  //  - git-compare: $(git-compare)
  //  - compare-changes: $(compare-changes)
  //  - git-merge: $(git-merge)
  //  - github-action: $(github-action)
  //  - github-alt: $(github-alt)
  //  - globe: $(globe)
  //  - grabber: $(grabber)
  //  - graph: $(graph)
  //  - gripper: $(gripper)
  //  - heart: $(heart)
  //  - home: $(home)
  //  - horizontal-rule: $(horizontal-rule)
  //  - hubot: $(hubot)
  //  - inbox: $(inbox)
  //  - issue-reopened: $(issue-reopened)
  //  - issues: $(issues)
  //  - italic: $(italic)
  //  - jersey: $(jersey)
  //  - json: $(json)
  //  - kebab-vertical: $(kebab-vertical)
  //  - key: $(key)
  //  - law: $(law)
  //  - lightbulb-autofix: $(lightbulb-autofix)
  //  - link-external: $(link-external)
  //  - link: $(link)
  //  - list-ordered: $(list-ordered)
  //  - list-unordered: $(list-unordered)
  //  - live-share: $(live-share)
  //  - loading: $(loading)
  //  - location: $(location)
  //  - mail-read: $(mail-read)
  //  - mail: $(mail)
  //  - markdown: $(markdown)
  //  - megaphone: $(megaphone)
  //  - mention: $(mention)
  //  - milestone: $(milestone)
  //  - git-pull-request-milestone: $(git-pull-request-milestone)
  //  - mortar-board: $(mortar-board)
  //  - move: $(move)
  //  - multiple-windows: $(multiple-windows)
  //  - mute: $(mute)
  //  - no-newline: $(no-newline)
  //  - note: $(note)
  //  - octoface: $(octoface)
  //  - open-preview: $(open-preview)
  //  - package: $(package)
  //  - paintcan: $(paintcan)
  //  - pin: $(pin)
  //  - play: $(play)
  //  - run: $(run)
  //  - plug: $(plug)
  //  - preserve-case: $(preserve-case)
  //  - preview: $(preview)
  //  - project: $(project)
  //  - pulse: $(pulse)
  //  - question: $(question)
  //  - quote: $(quote)
  //  - radio-tower: $(radio-tower)
  //  - reactions: $(reactions)
  //  - references: $(references)
  //  - refresh: $(refresh)
  //  - regex: $(regex)
  //  - remote-explorer: $(remote-explorer)
  //  - remote: $(remote)
  //  - remove: $(remove)
  //  - replace-all: $(replace-all)
  //  - replace: $(replace)
  //  - repo-clone: $(repo-clone)
  //  - repo-force-push: $(repo-force-push)
  //  - repo-pull: $(repo-pull)
  //  - repo-push: $(repo-push)
  //  - report: $(report)
  //  - request-changes: $(request-changes)
  //  - rocket: $(rocket)
  //  - root-folder-opened: $(root-folder-opened)
  //  - root-folder: $(root-folder)
  //  - rss: $(rss)
  //  - ruby: $(ruby)
  //  - save-all: $(save-all)
  //  - save-as: $(save-as)
  //  - save: $(save)
  //  - screen-full: $(screen-full)
  //  - screen-normal: $(screen-normal)
  //  - search-stop: $(search-stop)
  //  - server: $(server)
  //  - settings-gear: $(settings-gear)
  //  - settings: $(settings)
  //  - shield: $(shield)
  //  - smiley: $(smiley)
  //  - sort-precedence: $(sort-precedence)
  //  - split-horizontal: $(split-horizontal)
  //  - split-vertical: $(split-vertical)
  //  - squirrel: $(squirrel)
  //  - star-full: $(star-full)
  //  - star-half: $(star-half)
  //  - symbol-class: $(symbol-class)
  //  - symbol-color: $(symbol-color)
  //  - symbol-constant: $(symbol-constant)
  //  - symbol-enum-member: $(symbol-enum-member)
  //  - symbol-field: $(symbol-field)
  //  - symbol-file: $(symbol-file)
  //  - symbol-interface: $(symbol-interface)
  //  - symbol-keyword: $(symbol-keyword)
  //  - symbol-misc: $(symbol-misc)
  //  - symbol-operator: $(symbol-operator)
  //  - symbol-property: $(symbol-property)
  //  - wrench: $(wrench)
  //  - wrench-subaction: $(wrench-subaction)
  //  - symbol-snippet: $(symbol-snippet)
  //  - tasklist: $(tasklist)
  //  - telescope: $(telescope)
  //  - text-size: $(text-size)
  //  - three-bars: $(three-bars)
  //  - thumbsdown: $(thumbsdown)
  //  - thumbsup: $(thumbsup)
  //  - tools: $(tools)
  //  - triangle-down: $(triangle-down)
  //  - triangle-left: $(triangle-left)
  //  - triangle-right: $(triangle-right)
  //  - triangle-up: $(triangle-up)
  //  - twitter: $(twitter)
  //  - unfold: $(unfold)
  //  - unlock: $(unlock)
  //  - unmute: $(unmute)
  //  - unverified: $(unverified)
  //  - verified: $(verified)
  //  - versions: $(versions)
  //  - vm-active: $(vm-active)
  //  - vm-outline: $(vm-outline)
  //  - vm-running: $(vm-running)
  //  - watch: $(watch)
  //  - whitespace: $(whitespace)
  //  - whole-word: $(whole-word)
  //  - window: $(window)
  //  - word-wrap: $(word-wrap)
  //  - zoom-in: $(zoom-in)
  //  - zoom-out: $(zoom-out)
  //  - list-filter: $(list-filter)
  //  - list-flat: $(list-flat)
  //  - list-selection: $(list-selection)
  //  - selection: $(selection)
  //  - list-tree: $(list-tree)
  //  - debug-breakpoint-function-unverified: $(debug-breakpoint-function-unverified)
  //  - debug-breakpoint-function: $(debug-breakpoint-function)
  //  - debug-breakpoint-function-disabled: $(debug-breakpoint-function-disabled)
  //  - debug-stackframe-active: $(debug-stackframe-active)
  //  - circle-small-filled: $(circle-small-filled)
  //  - debug-stackframe-dot: $(debug-stackframe-dot)
  //  - terminal-decoration-mark: $(terminal-decoration-mark)
  //  - debug-stackframe: $(debug-stackframe)
  //  - debug-stackframe-focused: $(debug-stackframe-focused)
  //  - debug-breakpoint-unsupported: $(debug-breakpoint-unsupported)
  //  - symbol-string: $(symbol-string)
  //  - debug-reverse-continue: $(debug-reverse-continue)
  //  - debug-step-back: $(debug-step-back)
  //  - debug-restart-frame: $(debug-restart-frame)
  //  - debug-alt: $(debug-alt)
  //  - call-incoming: $(call-incoming)
  //  - call-outgoing: $(call-outgoing)
  //  - menu: $(menu)
  //  - expand-all: $(expand-all)
  //  - feedback: $(feedback)
  //  - git-pull-request-reviewer: $(git-pull-request-reviewer)
  //  - group-by-ref-type: $(group-by-ref-type)
  //  - ungroup-by-ref-type: $(ungroup-by-ref-type)
  //  - account: $(account)
  //  - git-pull-request-assignee: $(git-pull-request-assignee)
  //  - bell-dot: $(bell-dot)
  //  - debug-console: $(debug-console)
  //  - library: $(library)
  //  - output: $(output)
  //  - run-all: $(run-all)
  //  - sync-ignored: $(sync-ignored)
  //  - pinned: $(pinned)
  //  - github-inverted: $(github-inverted)
  //  - server-process: $(server-process)
  //  - server-environment: $(server-environment)
  //  - pass: $(pass)
  //  - issue-closed: $(issue-closed)
  //  - stop-circle: $(stop-circle)
  //  - play-circle: $(play-circle)
  //  - record: $(record)
  //  - debug-alt-small: $(debug-alt-small)
  //  - vm-connect: $(vm-connect)
  //  - cloud: $(cloud)
  //  - merge: $(merge)
  //  - export: $(export)
  //  - graph-left: $(graph-left)
  //  - magnet: $(magnet)
  //  - notebook: $(notebook)
  //  - redo: $(redo)
  //  - check-all: $(check-all)
  //  - pinned-dirty: $(pinned-dirty)
  //  - pass-filled: $(pass-filled)
  //  - circle-large-filled: $(circle-large-filled)
  //  - circle-large: $(circle-large)
  //  - circle-large-outline: $(circle-large-outline)
  //  - combine: $(combine)
  //  - gather: $(gather)
  //  - table: $(table)
  //  - variable-group: $(variable-group)
  //  - type-hierarchy: $(type-hierarchy)
  //  - type-hierarchy-sub: $(type-hierarchy-sub)
  //  - type-hierarchy-super: $(type-hierarchy-super)
  //  - git-pull-request-create: $(git-pull-request-create)
  //  - run-above: $(run-above)
  //  - run-below: $(run-below)
  //  - notebook-template: $(notebook-template)
  //  - debug-rerun: $(debug-rerun)
  //  - workspace-trusted: $(workspace-trusted)
  //  - workspace-untrusted: $(workspace-untrusted)
  //  - workspace-unknown: $(workspace-unknown)
  //  - terminal-cmd: $(terminal-cmd)
  //  - terminal-debian: $(terminal-debian)
  //  - terminal-linux: $(terminal-linux)
  //  - terminal-powershell: $(terminal-powershell)
  //  - terminal-tmux: $(terminal-tmux)
  //  - terminal-ubuntu: $(terminal-ubuntu)
  //  - terminal-bash: $(terminal-bash)
  //  - arrow-swap: $(arrow-swap)
  //  - copy: $(copy)
  //  - person-add: $(person-add)
  //  - filter-filled: $(filter-filled)
  //  - wand: $(wand)
  //  - debug-line-by-line: $(debug-line-by-line)
  //  - inspect: $(inspect)
  //  - layers: $(layers)
  //  - layers-dot: $(layers-dot)
  //  - layers-active: $(layers-active)
  //  - compass: $(compass)
  //  - compass-dot: $(compass-dot)
  //  - compass-active: $(compass-active)
  //  - azure: $(azure)
  //  - issue-draft: $(issue-draft)
  //  - git-pull-request-closed: $(git-pull-request-closed)
  //  - git-pull-request-draft: $(git-pull-request-draft)
  //  - debug-all: $(debug-all)
  //  - debug-coverage: $(debug-coverage)
  //  - run-errors: $(run-errors)
  //  - folder-library: $(folder-library)
  //  - debug-continue-small: $(debug-continue-small)
  //  - beaker-stop: $(beaker-stop)
  //  - graph-line: $(graph-line)
  //  - graph-scatter: $(graph-scatter)
  //  - pie-chart: $(pie-chart)
  //  - bracket: $(bracket)
  //  - bracket-dot: $(bracket-dot)
  //  - bracket-error: $(bracket-error)
  //  - lock-small: $(lock-small)
  //  - azure-devops: $(azure-devops)
  //  - verified-filled: $(verified-filled)
  //  - newline: $(newline)
  //  - layout: $(layout)
  //  - layout-activitybar-left: $(layout-activitybar-left)
  //  - layout-activitybar-right: $(layout-activitybar-right)
  //  - layout-panel-left: $(layout-panel-left)
  //  - layout-panel-center: $(layout-panel-center)
  //  - layout-panel-justify: $(layout-panel-justify)
  //  - layout-panel-right: $(layout-panel-right)
  //  - layout-panel: $(layout-panel)
  //  - layout-sidebar-left: $(layout-sidebar-left)
  //  - layout-sidebar-right: $(layout-sidebar-right)
  //  - layout-statusbar: $(layout-statusbar)
  //  - layout-menubar: $(layout-menubar)
  //  - layout-centered: $(layout-centered)
  //  - target: $(target)
  //  - indent: $(indent)
  //  - record-small: $(record-small)
  //  - error-small: $(error-small)
  //  - terminal-decoration-error: $(terminal-decoration-error)
  //  - arrow-circle-down: $(arrow-circle-down)
  //  - arrow-circle-left: $(arrow-circle-left)
  //  - arrow-circle-right: $(arrow-circle-right)
  //  - arrow-circle-up: $(arrow-circle-up)
  //  - layout-sidebar-right-off: $(layout-sidebar-right-off)
  //  - layout-panel-off: $(layout-panel-off)
  //  - layout-sidebar-left-off: $(layout-sidebar-left-off)
  //  - blank: $(blank)
  //  - heart-filled: $(heart-filled)
  //  - map: $(map)
  //  - map-horizontal: $(map-horizontal)
  //  - fold-horizontal: $(fold-horizontal)
  //  - map-filled: $(map-filled)
  //  - map-horizontal-filled: $(map-horizontal-filled)
  //  - fold-horizontal-filled: $(fold-horizontal-filled)
  //  - circle-small: $(circle-small)
  //  - bell-slash: $(bell-slash)
  //  - bell-slash-dot: $(bell-slash-dot)
  //  - comment-unresolved: $(comment-unresolved)
  //  - git-pull-request-go-to-changes: $(git-pull-request-go-to-changes)
  //  - git-pull-request-new-changes: $(git-pull-request-new-changes)
  //  - search-fuzzy: $(search-fuzzy)
  //  - comment-draft: $(comment-draft)
  //  - send: $(send)
  //  - sparkle: $(sparkle)
  //  - insert: $(insert)
  //  - mic: $(mic)
  //  - thumbsdown-filled: $(thumbsdown-filled)
  //  - thumbsup-filled: $(thumbsup-filled)
  //  - coffee: $(coffee)
  //  - snake: $(snake)
  //  - game: $(game)
  //  - vr: $(vr)
  //  - chip: $(chip)
  //  - piano: $(piano)
  //  - music: $(music)
  //  - mic-filled: $(mic-filled)
  //  - repo-fetch: $(repo-fetch)
  //  - copilot: $(copilot)
  //  - lightbulb-sparkle: $(lightbulb-sparkle)
  //  - robot: $(robot)
  //  - sparkle-filled: $(sparkle-filled)
  //  - diff-single: $(diff-single)
  //  - diff-multiple: $(diff-multiple)
  //  - surround-with: $(surround-with)
  //  - share: $(share)
  //  - git-stash: $(git-stash)
  //  - git-stash-apply: $(git-stash-apply)
  //  - git-stash-pop: $(git-stash-pop)
  //  - vscode: $(vscode)
  //  - vscode-insiders: $(vscode-insiders)
  //  - code-oss: $(code-oss)
  //  - run-coverage: $(run-coverage)
  //  - run-all-coverage: $(run-all-coverage)
  //  - coverage: $(coverage)
  //  - github-project: $(github-project)
  //  - map-vertical: $(map-vertical)
  //  - fold-vertical: $(fold-vertical)
  //  - map-vertical-filled: $(map-vertical-filled)
  //  - fold-vertical-filled: $(fold-vertical-filled)
  //  - go-to-search: $(go-to-search)
  //  - percentage: $(percentage)
  //  - sort-percentage: $(sort-percentage)
  //  - attach: $(attach)
  //  - go-to-editing-session: $(go-to-editing-session)
  //  - edit-session: $(edit-session)
  //  - code-review: $(code-review)
  //  - copilot-warning: $(copilot-warning)
  //  - python: $(python)
  //  - copilot-large: $(copilot-large)
  //  - copilot-warning-large: $(copilot-warning-large)
  //  - keyboard-tab: $(keyboard-tab)
  //  - copilot-blocked: $(copilot-blocked)
  //  - copilot-not-connected: $(copilot-not-connected)
  //  - flag: $(flag)
  //  - lightbulb-empty: $(lightbulb-empty)
  //  - symbol-method-arrow: $(symbol-method-arrow)
  //  - copilot-unavailable: $(copilot-unavailable)
  //  - repo-pinned: $(repo-pinned)
  //  - keyboard-tab-above: $(keyboard-tab-above)
  //  - keyboard-tab-below: $(keyboard-tab-below)
  //  - git-pull-request-done: $(git-pull-request-done)
  //  - mcp: $(mcp)
  //  - extensions-large: $(extensions-large)
  //  - layout-panel-dock: $(layout-panel-dock)
  //  - layout-sidebar-left-dock: $(layout-sidebar-left-dock)
  //  - layout-sidebar-right-dock: $(layout-sidebar-right-dock)
  //  - copilot-in-progress: $(copilot-in-progress)
  //  - copilot-error: $(copilot-error)
  //  - copilot-success: $(copilot-success)
  //  - chat-sparkle: $(chat-sparkle)
  //  - search-sparkle: $(search-sparkle)
  //  - edit-sparkle: $(edit-sparkle)
  //  - copilot-snooze: $(copilot-snooze)
  //  - send-to-remote-agent: $(send-to-remote-agent)
  //  - dialog-error: $(dialog-error)
  //  - dialog-warning: $(dialog-warning)
  //  - dialog-info: $(dialog-info)
  //  - dialog-close: $(dialog-close)
  //  - tree-item-expanded: $(tree-item-expanded)
  //  - tree-filter-on-type-on: $(tree-filter-on-type-on)
  //  - tree-filter-on-type-off: $(tree-filter-on-type-off)
  //  - tree-filter-clear: $(tree-filter-clear)
  //  - tree-item-loading: $(tree-item-loading)
  //  - menu-selection: $(menu-selection)
  //  - menu-submenu: $(menu-submenu)
  //  - menubar-more: $(menubar-more)
  //  - scrollbar-button-left: $(scrollbar-button-left)
  //  - scrollbar-button-right: $(scrollbar-button-right)
  //  - scrollbar-button-up: $(scrollbar-button-up)
  //  - scrollbar-button-down: $(scrollbar-button-down)
  //  - toolbar-more: $(toolbar-more)
  //  - quick-input-back: $(quick-input-back)
  //  - drop-down-button: $(drop-down-button)
  //  - symbol-customcolor: $(symbol-customcolor)
  //  - export: $(export)
  //  - workspace-unspecified: $(workspace-unspecified)
  //  - newline: $(newline)
  //  - thumbsdown-filled: $(thumbsdown-filled)
  //  - thumbsup-filled: $(thumbsup-filled)
  //  - git-fetch: $(git-fetch)
  //  - lightbulb-sparkle-autofix: $(lightbulb-sparkle-autofix)
  //  - debug-breakpoint-pending: $(debug-breakpoint-pending)
  "terminal.integrated.tabs.defaultIcon": "terminal",

  // 제목 오른쪽에 표시되는 터미널 설명을 제어합니다. 변수는 컨텍스트에 따라 대체됩니다.
  // - `${cwd}`: 터미널의 현재 작업 디렉터리입니다.
  // - `${cwdFolder}`: 값이 초기 작업 디렉터리와 다른 경우 다중 루트 작업 영역 또는 단일 루트 작업 영역에 표시되는 터미널의 현재 작업 디렉터리입니다. Windows에서는 셸 통합이 사용하도록 설정된 경우에만 표시됩니다.
  // - `${workspaceFolder}`: 터미널이 시작된 작업 영역입니다.
  // - `${workspaceFolderName}`: 터미널이 시작된 작업 영역의 'name'입니다.
  // - `${local}`: 원격 작업 영역의 로컬 터미널을 나타냅니다.
  // - `${process}`: 터미널 프로세스의 이름입니다.
  // - `${progress}`: 'OSC 9;4' 시퀀스에 의해 보고된 진행 상태입니다.
  // - `${separator}`: 값 또는 정적 텍스트가 있는 변수로 둘러싸인 경우에만 표시되는 조건부 구분 기호 (` - `)입니다.
  // - `${sequence}`: 프로세스에 의해 터미널에 제공된 이름입니다.
  // - `${task}`: 이 터미널이 작업과 연결되어 있음을 나타냅니다.
  // - `${shellType}`: 검색된 셸 유형입니다.
  // - `${shellCommand}`: 셸 통합에 따라 실행되고 있는 명령입니다. 이를 위해서는 검색된 명령줄에 대한 높은 신뢰도가 필요한데, 이는 일부 프롬프트 프레임워크에서는 작동하지 않을 수 있습니다.
  // - `${shellPromptInput}`: 셸 통합에 따른 셸의 전체 프롬프트 입력입니다.
  "terminal.integrated.tabs.description": "${task}${separator}${local}${separator}${cwdFolder}",

  // 터미널 탭 상태가 애니메이션을 지원하는지 여부를 제어합니다(예: 진행 중인 작업).
  "terminal.integrated.tabs.enableAnimation": true,

  // 터미널 탭이 터미널 측면에 목록으로 표시되는지 여부를 제어합니다. 이 기능을 사용하지 않도록 설정하면 드롭다운이 대신 표시됩니다.
  "terminal.integrated.tabs.enabled": true,

  // 탭의 터미널 포커스를 두 번 클릭하거나 한 번 클릭할 때 맞출지 여부를 제어합니다.
  //  - singleClick: 터미널 탭을 클릭할 때 터미널 포커스 설정
  //  - doubleClick: 터미널 탭을 두 번 클릭할 때 터미널 포커스 설정
  "terminal.integrated.tabs.focusMode": "doubleClick",

  // 터미널 탭 보기가 특정 조건에서 숨겨지는지 여부를 제어합니다.
  //  - never: 터미널 탭 보기를 숨기지 않음
  //  - singleTerminal: 터미널이 하나만 열린 경우 터미널 탭 보기 숨기기
  //  - singleGroup: 단일 터미널 그룹만 열려 있는 경우 터미널 탭 보기 숨기기
  "terminal.integrated.tabs.hideCondition": "singleTerminal",

  // 실제 터미널의 왼쪽 또는 오른쪽에 있는 터미널 탭의 위치를 제어합니다.
  //  - left: 터미널 왼쪽에 터미널 탭 보기 표시
  //  - right: 터미널 오른쪽에 터미널 탭 보기 표시
  "terminal.integrated.tabs.location": "right",

  // `terminal.integrated.tabs.title#` 및 `#terminal.integrated.tabs.description`이(가) 사용하는 구분 기호입니다.
  "terminal.integrated.tabs.separator": " - ",

  // 터미널 분할 및 종료 단추가 새 터미널 단추 옆에 표시되는지 여부를 제어합니다.
  //  - always: 항상 작업 표시
  //  - singleTerminal: 작업이 열려 있는 유일한 터미널인 경우 표시
  //  - singleTerminalOrNarrow: 작업이 열려 있는 유일한 터미널이거나 탭 보기가 텍스트가 없는 좁은 상태일 때 표시
  //  - never: 작업 표시 안 함
  "terminal.integrated.tabs.showActions": "singleTerminalOrNarrow",

  // 보기에 활성 터미널 정보를 표시합니다. 탭 내의 제목이 표시되지 않는 경우 특히 유용합니다.
  //  - always: 항상 활성 터미널 표시
  //  - singleTerminal: 활성 터미널이 열려 있는 유일한 터미널인 경우 표시
  //  - singleTerminalOrNarrow: 활성 터미널이 열려 있는 유일한 터미널이거나 탭 보기가 텍스트가 없는 좁은 상태일 때 표시
  //  - never: 활성 터미널 표시 안 함
  "terminal.integrated.tabs.showActiveTerminal": "singleTerminalOrNarrow",

  // 터미널 제목을 제어합니다. 변수는 컨텍스트에 따라 대체됩니다.
  // - `${cwd}`: 터미널의 현재 작업 디렉터리입니다.
  // - `${cwdFolder}`: 값이 초기 작업 디렉터리와 다른 경우 다중 루트 작업 영역 또는 단일 루트 작업 영역에 표시되는 터미널의 현재 작업 디렉터리입니다. Windows에서는 셸 통합이 사용하도록 설정된 경우에만 표시됩니다.
  // - `${workspaceFolder}`: 터미널이 시작된 작업 영역입니다.
  // - `${workspaceFolderName}`: 터미널이 시작된 작업 영역의 'name'입니다.
  // - `${local}`: 원격 작업 영역의 로컬 터미널을 나타냅니다.
  // - `${process}`: 터미널 프로세스의 이름입니다.
  // - `${progress}`: 'OSC 9;4' 시퀀스에 의해 보고된 진행 상태입니다.
  // - `${separator}`: 값 또는 정적 텍스트가 있는 변수로 둘러싸인 경우에만 표시되는 조건부 구분 기호 (` - `)입니다.
  // - `${sequence}`: 프로세스에 의해 터미널에 제공된 이름입니다.
  // - `${task}`: 이 터미널이 작업과 연결되어 있음을 나타냅니다.
  // - `${shellType}`: 검색된 셸 유형입니다.
  // - `${shellCommand}`: 셸 통합에 따라 실행되고 있는 명령입니다. 이를 위해서는 검색된 명령줄에 대한 높은 신뢰도가 필요한데, 이는 일부 프롬프트 프레임워크에서는 작동하지 않을 수 있습니다.
  // - `${shellPromptInput}`: 셸 통합에 따른 셸의 전체 프롬프트 입력입니다.
  "terminal.integrated.tabs.title": "${process}",

  // 탭 정지의 셀 수입니다.
  "terminal.integrated.tabStopWidth": 8,

  // 터미널에서 문자 너비를 계산할 때 사용할 유니코드 버전을 제어합니다. 이모지 또는 다른 와이드 문자가 너무 많거나 적게 삭제하여 적절한 공백이나 백스페이스를 사용하지 않는 경우, 이 설정을 조정하는 것이 좋습니다.
  //  - 6: 유니코드 버전 6. 이전 시스템에서 더 잘 작동하는 이전 버전입니다.
  //  - 11: 유니코드 버전 11. 이 버전은 최신 버전의 유니코드를 사용하는 최신 시스템에서 더 나은 지원을 제공합니다.
  "terminal.integrated.unicodeVersion": "11",

  // 터미널 드롭다운에 WSL 배포판이 표시되는지를 제어합니다.
  "terminal.integrated.useWslProfiles": true,

  // Windows 터미널 프로세스 통신에 ConPTY를 사용할지 여부입니다(Windows 10 빌드 번호 18309 이상 필요). 이 설정이 false이면 Winpty가 사용됩니다.
  "terminal.integrated.windowsEnableConpty": true,

  // Windows와 함께 제공되는 것이 아니라 VS Code 함께 제공되는 실험적 conpty.dll(v1.22.250204002)을 사용할지 여부입니다.
  "terminal.integrated.windowsUseConptyDll": false,

  // 두 번 클릭하여 단어를 선택할 때와 대체 '단어' 링크 감지에서 단어 구분 기호로 간주할 모든 문자를 포함하는 문자열입니다. 링크를 감지할 때 사용되므로 링크 감지 시 사용되는 `:`와 같은 문자를 포함하면 'file:10:5'와 같은 링크의 행과 열 부분이 무시됩니다.
  "terminal.integrated.wordSeparators": " ()[]{}',\"`─‘’“”|",

  // 문제 보기를 열 때 문제 보기에 자동으로 파일을 표시할지 여부를 제어합니다.
  "problems.autoReveal": true,

  // 파일 및 폴더에 오류와 경고를 표시합니다. 꺼져 있을 때 `problems.visibility`이(가) 덮어씁니다.
  "problems.decorations.enabled": true,

  // 문제 보기의 기본 보기 모드를 제어합니다.
  "problems.defaultViewMode": "tree",

  // 활성화하면 상태 표시줄에 현재 문제가 표시됩니다.
  "problems.showCurrentInStatus": false,

  // 문제를 탐색하는 순서를 제어합니다.
  //  - severity: 심각도에 따라 정렬된 문제 탐색
  //  - position: 위치별로 정렬된 문제 탐색
  "problems.sortOrder": "severity",

  // 편집기 및 워크벤치 전체에서 문제를 표시할지 여부를 제어합니다.
  "problems.visibility": true,

  // 탐색 이동 경로를 사용하도록/사용하지 않도록 설정합니다.
  "breadcrumbs.enabled": true,

  // 이동 경로 보기에서 파일 경로를 표시할지 여부와 표시 방법을 제어합니다.
  //  - on: 이동 경로 뷰에서 파일 경로를 표시합니다.
  //  - off: 이동 경로 뷰에서 파일 경로를 표시하지 않습니다.
  //  - last: 이동 경로 뷰에서 파일 경로의 마지막 요소만 표시합니다.
  "breadcrumbs.filePath": "on",

  // 아이콘으로 이동 경로 항목을 렌더링합니다.
  "breadcrumbs.icons": true,

  // 사용하도록 설정되면 이동 경로에 '배열' 기호가 표시됩니다.
  "breadcrumbs.showArrays": true,

  // 사용하도록 설정된 경우 이동 경로에 '부울' 기호가 표시됩니다.
  "breadcrumbs.showBooleans": true,

  // 사용하도록 설정되면 이동 경로에 '클래스' 기호가 표시됩니다.
  "breadcrumbs.showClasses": true,

  // 사용하도록 설정되면 이동 경로에 '상수' 기호가 표시됩니다.
  "breadcrumbs.showConstants": true,

  // 사용하도록 설정되면 이동 경로에 '생성자' 기호가 표시됩니다.
  "breadcrumbs.showConstructors": true,

  // 사용하도록 설정되면 이동 경로에 'enumMember' 기호가 표시됩니다.
  "breadcrumbs.showEnumMembers": true,

  // 사용하도록 설정되면 이동 경로에 '열거형' 기호가 표시됩니다.
  "breadcrumbs.showEnums": true,

  // 사용하도록 설정되면 이동 경로에 '이벤트' 기호가 표시됩니다.
  "breadcrumbs.showEvents": true,

  // 사용하도록 설정되면 이동 경로에 '필드' 기호가 표시됩니다.
  "breadcrumbs.showFields": true,

  // 사용하도록 설정되면 이동 경로에 '파일' 기호가 표시됩니다.
  "breadcrumbs.showFiles": true,

  // 사용하도록 설정된 경우 이동 경로에 '함수' 기호가 표시됩니다.
  "breadcrumbs.showFunctions": true,

  // 사용하도록 설정되면 이동 경로에 '인터페이스' 기호가 표시됩니다.
  "breadcrumbs.showInterfaces": true,

  // 사용하도록 설정되면 이동 경로에 '키' 기호가 표시됩니다.
  "breadcrumbs.showKeys": true,

  // 사용하도록 설정되면 이동 경로에 '메서드' 기호가 표시됩니다.
  "breadcrumbs.showMethods": true,

  // 사용하도록 설정되면 이동 경로에 '모듈' 기호가 표시됩니다.
  "breadcrumbs.showModules": true,

  // 사용하도록 설정되면 이동 경로에 '네임스페이스' 기호가 표시됩니다.
  "breadcrumbs.showNamespaces": true,

  // 사용하도록 설정된 경우 이동 경로에 'null' 기호가 표시됩니다.
  "breadcrumbs.showNull": true,

  // 사용하도록 설정되면 이동 경로에 '숫자' 기호가 표시됩니다.
  "breadcrumbs.showNumbers": true,

  // 사용하도록 설정된 경우 이동 경로에 '개체' 기호가 표시됩니다.
  "breadcrumbs.showObjects": true,

  // 사용하도록 설정되면 이동 경로에 '연산자' 기호가 표시됩니다.
  "breadcrumbs.showOperators": true,

  // 사용하도록 설정되면 이동 경로에 '패키지' 기호가 표시됩니다.
  "breadcrumbs.showPackages": true,

  // 사용하도록 설정되면 이동 경로에 '속성' 기호가 표시됩니다.
  "breadcrumbs.showProperties": true,

  // 사용하도록 설정되면 이동 경로에 '문자열' 기호가 표시됩니다.
  "breadcrumbs.showStrings": true,

  // 사용하도록 설정되면 이동 경로에 '구조' 기호가 표시됩니다.
  "breadcrumbs.showStructs": true,

  // 사용하도록 설정되면 이동 경로에 'typeParameter' 기호가 표시됩니다.
  "breadcrumbs.showTypeParameters": true,

  // 사용하도록 설정되면 이동 경로에 '변수' 기호가 표시됩니다.
  "breadcrumbs.showVariables": true,

  // 이동 경로 보기에서 기호를 표시할지 여부와 표시 방법을 제어합니다.
  //  - on: 이동 경로 뷰에서 모든 기호를 표시합니다.
  //  - off: 이동 경로 뷰에서 기호를 표시하지 않습니다.
  //  - last: 이동 경로 뷰에서 현재 기호만 표시합니다.
  "breadcrumbs.symbolPath": "on",

  // 이동 경로 개요 보기에서 기호를 정렬하는 방법을 제어합니다.
  //  - position: 파일 위치 순서로 기호 개요를 표시합니다.
  //  - name: 사전순으로 기호 개요를 표시합니다.
  //  - type: 기호 형식 순서로 기호 개요를 표시합니다.
  "breadcrumbs.symbolSortOrder": "position",

  // 개요 항목의 축소 또는 확장 여부를 제어합니다.
  //  - alwaysCollapse: 모든 항목 축소
  //  - alwaysExpand: 모든 항목 확장
  "outline.collapseItems": "alwaysExpand",

  // 아이콘으로 윤곽 요소를 렌더링합니다.
  "outline.icons": true,

  // 개요 요소에서 오류 및 경고에 배지를 사용합니다. 꺼져 있을 때 `problems.visibility`이(가) 덮어씁니다.
  "outline.problems.badges": true,

  // 개요 요소에서 오류 및 경고에 색을 사용합니다. 꺼져 있을 때 `problems.visibility`이(가) 덮어씁니다.
  "outline.problems.colors": true,

  // 개요 요소에 오류 및 경고를 표시합니다. 꺼져 있을 때 `problems.visibility`이(가) 덮어씁니다.
  "outline.problems.enabled": true,

  // 사용하도록 설정하면 개요에 '배열' 기호를 표시합니다.
  "outline.showArrays": true,

  // 사용하도록 설정하면 개요에 '부울' 기호를 표시합니다.
  "outline.showBooleans": true,

  // 사용하도록 설정하면 개요에 '클래스' 기호를 표시합니다.
  "outline.showClasses": true,

  // 사용하도록 설정하면 개요에 '상수' 기호를 표시합니다.
  "outline.showConstants": true,

  // 사용하도록 설정하면 개요에 '생성자' 기호를 표시합니다.
  "outline.showConstructors": true,

  // 사용하도록 설정하면 개요에 'enumMember' 기호를 표시합니다.
  "outline.showEnumMembers": true,

  // 사용하도록 설정하면 개요에 '열거형' 기호를 표시합니다.
  "outline.showEnums": true,

  // 사용하도록 설정하면 개요에 '이벤트' 기호를 표시합니다.
  "outline.showEvents": true,

  // 사용하도록 설정하면 개요에 '필드' 기호를 표시합니다.
  "outline.showFields": true,

  // 사용하도록 설정하면 개요에 '파일' 기호를 표시합니다.
  "outline.showFiles": true,

  // 사용하도록 설정하면 개요에 '기능' 기호를 표시합니다.
  "outline.showFunctions": true,

  // 사용하도록 설정하면 개요에 '인터페이스' 기호를 표시합니다.
  "outline.showInterfaces": true,

  // 사용하도록 설정하면 개요에 '키' 기호를 표시합니다.
  "outline.showKeys": true,

  // 사용하도록 설정하면 개요에 '메서드' 기호를 표시합니다.
  "outline.showMethods": true,

  // 사용하도록 설정하면 개요에 '모듈' 기호를 표시합니다.
  "outline.showModules": true,

  // 사용하도록 설정하면 개요에 '네임스페이스' 기호를 표시합니다.
  "outline.showNamespaces": true,

  // 사용하도록 설정하면 개요에 'null' 기호를 표시합니다.
  "outline.showNull": true,

  // 사용하도록 설정하면 개요에 '숫자' 기호를 표시합니다.
  "outline.showNumbers": true,

  // 사용하도록 설정하면 개요에 '개체' 기호를 표시합니다.
  "outline.showObjects": true,

  // 사용하도록 설정하면 개요에 '연산자' 기호를 표시합니다.
  "outline.showOperators": true,

  // 사용하도록 설정하면 개요에 '패키지' 기호를 표시합니다.
  "outline.showPackages": true,

  // 사용하도록 설정하면 개요에 '속성' 기호를 표시합니다.
  "outline.showProperties": true,

  // 사용하도록 설정하면 개요에 '문자열' 기호를 표시합니다.
  "outline.showStrings": true,

  // 사용하도록 설정하면 개요에 '구조' 기호를 표시합니다.
  "outline.showStructs": true,

  // 사용하도록 설정하면 개요에 'typeParameter' 기호를 표시합니다.
  "outline.showTypeParameters": true,

  // 사용하도록 설정하면 개요에 '변수' 기호를 표시합니다.
  "outline.showVariables": true,

  // 타임라인 보기에서 목록 끝까지 스크롤한 경우 다음 항목 페이지를 로드할지 여부를 제어합니다.
  "timeline.pageOnScroll": true,

  // 기본 보기에서와 추가 항목 로드 시 타임라인 보기에 표시할 항목 수입니다. `null`로 설정하면 타임라인 보기의 표시 영역에 따라 페이지 크기가 자동으로 선택됩니다.
  "timeline.pageSize": 50,

  // chatmode에 대해 재정의할 설정을 구성합니다.
  "[chatmode]": {
    "editor.unicodeHighlight.ambiguousCharacters": false,
    "editor.unicodeHighlight.invisibleCharacters": false,
    "diffEditor.ignoreTrimWhitespace": false,
    "editor.wordWrap": "on",
    "editor.quickSuggestions": {
      "comments": "off",
      "strings": "off",
      "other": "off"
    }
  },

  // clojure에 대해 재정의할 설정을 구성합니다.
  "[clojure]": {
    "diffEditor.ignoreTrimWhitespace": false
  },

  // coffeescript에 대해 재정의할 설정을 구성합니다.
  "[coffeescript]": {
    "diffEditor.ignoreTrimWhitespace": false,
    "editor.defaultColorDecorators": "never"
  },

  // csharp에 대해 재정의할 설정을 구성합니다.
  "[csharp]": {
    "editor.maxTokenizationLineLength": 2500
  },

  // css에 대해 재정의할 설정을 구성합니다.
  "[css]": {
    "editor.suggest.insertMode": "replace"
  },

  // dockercompose에 대해 재정의할 설정을 구성합니다.
  "[dockercompose]": {
    "editor.insertSpaces": true,
    "editor.tabSize": 2,
    "editor.autoIndent": "advanced"
  },

  // dockerfile에 대해 재정의할 설정을 구성합니다.
  "[dockerfile]": {
    "editor.quickSuggestions": {
      "strings": true
    }
  },

  // fsharp에 대해 재정의할 설정을 구성합니다.
  "[fsharp]": {
    "diffEditor.ignoreTrimWhitespace": false
  },

  // git-commit에 대해 재정의할 설정을 구성합니다.
  "[git-commit]": {
    "editor.rulers": [50, 72],
    "editor.wordWrap": "off",
    "workbench.editor.restoreViewState": false
  },

  // git-rebase에 대해 재정의할 설정을 구성합니다.
  "[git-rebase]": {
    "workbench.editor.restoreViewState": false
  },

  // go에 대해 재정의할 설정을 구성합니다.
  "[go]": {
    "editor.insertSpaces": false
  },

  // handlebars에 대해 재정의할 설정을 구성합니다.
  "[handlebars]": {
    "editor.suggest.insertMode": "replace"
  },

  // html에 대해 재정의할 설정을 구성합니다.
  "[html]": {
    "editor.suggest.insertMode": "replace"
  },

  // instructions에 대해 재정의할 설정을 구성합니다.
  "[instructions]": {
    "editor.unicodeHighlight.ambiguousCharacters": false,
    "editor.unicodeHighlight.invisibleCharacters": false,
    "diffEditor.ignoreTrimWhitespace": false,
    "editor.wordWrap": "on",
    "editor.quickSuggestions": {
      "comments": "off",
      "strings": "off",
      "other": "off"
    }
  },

  // jade에 대해 재정의할 설정을 구성합니다.
  "[jade]": {
    "diffEditor.ignoreTrimWhitespace": false
  },

  // javascript에 대해 재정의할 설정을 구성합니다.
  "[javascript]": {
    "editor.maxTokenizationLineLength": 2500
  },

  // json에 대해 재정의할 설정을 구성합니다.
  "[json]": {
    "editor.quickSuggestions": {
      "strings": true
    },
    "editor.suggest.insertMode": "replace"
  },

  // jsonc에 대해 재정의할 설정을 구성합니다.
  "[jsonc]": {
    "editor.quickSuggestions": {
      "strings": true
    },
    "editor.suggest.insertMode": "replace"
  },

  // julia에 대해 재정의할 설정을 구성합니다.
  "[julia]": {
    "editor.defaultColorDecorators": "never"
  },

  // less에 대해 재정의할 설정을 구성합니다.
  "[less]": {
    "editor.suggest.insertMode": "replace"
  },

  // makefile에 대해 재정의할 설정을 구성합니다.
  "[makefile]": {
    "editor.insertSpaces": false
  },

  // markdown에 대해 재정의할 설정을 구성합니다.
  "[markdown]": {
    "editor.unicodeHighlight.ambiguousCharacters": false,
    "editor.unicodeHighlight.invisibleCharacters": false,
    "diffEditor.ignoreTrimWhitespace": false,
    "editor.wordWrap": "on",
    "editor.quickSuggestions": {
      "comments": "off",
      "strings": "off",
      "other": "off"
    }
  },

  // plaintext에 대해 재정의할 설정을 구성합니다.
  "[plaintext]": {
    "editor.unicodeHighlight.ambiguousCharacters": false,
    "editor.unicodeHighlight.invisibleCharacters": false
  },

  // prompt에 대해 재정의할 설정을 구성합니다.
  "[prompt]": {
    "editor.unicodeHighlight.ambiguousCharacters": false,
    "editor.unicodeHighlight.invisibleCharacters": false,
    "diffEditor.ignoreTrimWhitespace": false,
    "editor.wordWrap": "on",
    "editor.quickSuggestions": {
      "comments": "off",
      "strings": "off",
      "other": "off"
    }
  },

  // python에 대해 재정의할 설정을 구성합니다.
  "[python]": {
    "diffEditor.ignoreTrimWhitespace": false,
    "editor.defaultColorDecorators": "never"
  },

  // ruby에 대해 재정의할 설정을 구성합니다.
  "[ruby]": {
    "editor.defaultColorDecorators": "never"
  },

  // scss에 대해 재정의할 설정을 구성합니다.
  "[scss]": {
    "editor.suggest.insertMode": "replace"
  },

  // search-result에 대해 재정의할 설정을 구성합니다.
  "[search-result]": {
    "editor.lineNumbers": "off"
  },

  // shellscript에 대해 재정의할 설정을 구성합니다.
  "[shellscript]": {
    "files.eol": "\n",
    "editor.defaultColorDecorators": "never"
  },

  // snippets에 대해 재정의할 설정을 구성합니다.
  "[snippets]": {
    "editor.quickSuggestions": {
      "strings": true
    },
    "editor.suggest.insertMode": "replace"
  },

  // yaml에 대해 재정의할 설정을 구성합니다.
  "[yaml]": {
    "editor.insertSpaces": true,
    "editor.tabSize": 2,
    "editor.autoIndent": "advanced",
    "diffEditor.ignoreTrimWhitespace": false,
    "editor.defaultColorDecorators": "never",
    "editor.quickSuggestions": {
      "strings": "on"
    }
  },

  // Copilot Chat에 에이전트 모드를 사용하도록 설정합니다. 이 기능을 사용하도록 설정하면 보기의 드롭다운을 통해 에이전트 모드를 활성화할 수 있습니다.
  "chat.agent.enabled": true,

  // 에이전트 모드에서 Copilot이 제출 당 사용할 수 있는 최대 요청 수입니다. 제한에 도달하면 Copilot은 사용자에게 계속할지 확인하도록 요청합니다.
  "chat.agent.maxRequests": 25,

  // 에이전트 세션 메뉴를 표시할 위치를 제어합니다.
  "chat.agentSessionsViewLocation": "disabled",

  // 채팅에서 검사점을 사용하도록 설정합니다. 검사점을 사용하면 채팅을 이전 상태로 복원할 수 있습니다.
  "chat.checkpoints.enabled": true,

  // 채팅 검사점 파일 변경 내용을 표시할지 여부를 제어합니다.
  "chat.checkpoints.showFileChanges": false,

  // 명령 센터에 Copilot를 제어하기 위한 작업 메뉴를 표시할지 여부를 제어합니다(`window.commandCenter` 필요).
  "chat.commandCenter.enabled": true,

  // 패널 채팅에서 채팅 참가자 자동 감지를 사용합니다.
  "chat.detectParticipant.enabled": true,

  // 채팅에서 변경한 내용이 자동으로 수락되는 지연입니다. 값은 초 단위로, '0'은 사용 안 됨을 의미하고 '100'초는 최대값입니다.
  "chat.editing.autoAcceptDelay": 0,

  // 요청 및 관련 편집을 제거하기 전에 확인을 표시할지 여부입니다.
  "chat.editing.confirmEditRequestRemoval": true,

  // 요청 및 관련 편집을 다시 시도하기 전에 확인을 표시할지 여부입니다.
  "chat.editing.confirmEditRequestRetry": true,

  // 채팅 코드 블록에서 글꼴 모음을 제어합니다.
  "chat.editor.fontFamily": "default",

  // 채팅 코드 블록의 글꼴 크기를 픽셀 단위로 제어합니다.
  "chat.editor.fontSize": 14,

  // 채팅 코드 블록의 글꼴 두께를 제어합니다.
  "chat.editor.fontWeight": "default",

  // 채팅 코드 블록의 줄 높이를 픽셀 단위로 제어합니다. 0을 사용하여 글꼴 크기에서 선 높이를 계산합니다.
  "chat.editor.lineHeight": 0,

  // 라인이 채팅 코드 블록에서 래핑되어야 하는지 여부를 제어합니다.
  "chat.editor.wordWrap": "off",

  // 채팅에서 요청을 편집할 수 있습니다. 이를 통해 요청 내용을 변경하고 모델에 다시 제출할 수 있습니다.
  "chat.editRequests": "inline",

  // 도구 호출을 기반으로 하는 새 편집 모드를 사용하도록 설정합니다. 이 기능을 사용하도록 설정하면 도구 호출을 지원하지 않는 모델은 편집 모드에서 사용할 수 없습니다.
  "chat.edits2.enabled": true,

  // 입력 자리 표시자 텍스트에 힌트가 있는 수정된 빈 채팅 상태를 표시합니다.
  "chat.emptyChatState.enabled": true,

  // 이 설정은 사용되지 않습니다. Please use `chat.detectParticipant.enabled` instead.
  // 패널 채팅에서 채팅 참가자 자동 감지를 사용합니다.
  "chat.experimental.detectParticipant.enabled": null,

  // 타사 확장에서 제공하는 도구를 사용하여 사용하도록 설정합니다.
  "chat.extensionTools.enabled": true,

  // 지정된 채팅 위치에 대해 활성 편집기를 채팅 컨텍스트로 자동으로 사용하도록 설정합니다.
  "chat.implicitContext.enabled": {
    "panel": "always"
  },

  // 새 암시적 컨텍스트 흐름이 표시되는지 여부를 제어합니다. 질문 및 편집 모드에서는 컨텍스트가 자동으로 포함됩니다. 에이전트 모드에서 컨텍스트는 첨부 파일로 제안됩니다. 선택 항목은 항상 컨텍스트로 포함됩니다.
  "chat.implicitContext.suggestedContext": true,

  // 채팅 세션에서 첨부할 수 있는 명령 파일('*.instructions.md')의 위치를 지정합니다. [자세히 알아보세요](https://aka.ms/vscode-ghcp-custom-instructions).
  //
  // 상대 경로는 작업 영역의 루트 폴더에서 확인됩니다.
  "chat.instructionsFilesLocations": {
    ".github/instructions": true
  },

  // Katex를 사용하여 채팅 응답에서 수학 렌더링을 사용하도록 설정합니다.
  "chat.math.enabled": false,

  // AI 지원 MCP 서버 설치를 위해 NuGet 패키지를 사용하도록 설정합니다. .NET 패키지(NuGet.org)의 중앙 레지스트리에서 이름으로 MCP 서버를 설치하는 데 사용됩니다.
  "chat.mcp.assisted.nuget.enabled": false,

  // 채팅 메시지를 제출할 때 MCP 서버를 자동으로 시작할지 여부를 제어합니다.
  //  - never: MCP 서버를 자동으로 시작하지 마세요.
  //  - onlyNew: 실행된 적이 없는 새 MCP 서버만 자동으로 시작합니다.
  //  - newAndOutdated: 아직 실행되지 않은 만료된 새 MCP 서버를 자동으로 시작합니다.
  "chat.mcp.autostart": "never",

  // 컴퓨터에서 모델 컨텍스트 프로토콜 서버의 검색을 구성합니다. 모든 원본과 사용하려는 매핑 원본을 사용하지 않도록 설정하거나 사용하도록 설정하려면 'true' 또는 'false'로 설정할 수 있습니다.
  "chat.mcp.discovery.enabled": true,

  // 추가 도구와 기능을 제공하기 위해 모델 컨텍스트 프로토콜 서버와의 통합을 가능하게 합니다.
  "chat.mcp.enabled": true,

  // 샘플링을 위해 MCP 서버에 노출할 모델을 구성합니다(백그라운드에서 모델 요청을 만들기). 이 설정은 'MCP: 서버 나열' 명령 하에 그래픽으로 편집할 수 있습니다.
  "chat.mcp.serverSampling": {},

  // 사용자 지정 채팅 모드 파일의 위치를 지정합니다('*.chatmode.md'). [자세히 알아보세요](https://aka.ms/vscode-ghcp-custom-chat-modes).
  //
  // 상대 경로는 작업 영역의 루트 폴더에서 확인됩니다.
  "chat.modeFilesLocations": {
    ".github/chatmodes": true
  },

  // 창에 포커스가 없는 동안 확인이 필요할 때 Copilot 창에서 사용자에게 알릴지 여부를 제어합니다. 여기에는 알림 배너뿐만 아니라 창 배지도 포함됩니다.
  "chat.notifyWindowOnConfirmation": true,

  // 채팅 세션에서 재사용 가능한 프롬프트('*.prompt.md') 및 명령 파일('*.instructions.md')을 사용하도록 설정합니다. [자세히 알아보세요](https://aka.ms/vscode-ghcp-prompt-snippets).
  "chat.promptFiles": true,

  // 채팅 세션에서 실행할 수 있는 재사용 가능한 프롬프트 파일('*.prompt.md')의 위치를 지정합니다. [자세히 알아보세요](https://aka.ms/vscode-ghcp-prompt-snippets).
  //
  // 상대 경로는 작업 영역의 루트 폴더에서 확인됩니다.
  "chat.promptFilesLocations": {
    ".github/prompts": true
  },

  // 채팅 입력에서 관련 파일을 렌더링할지 여부를 제어합니다.
  "chat.renderRelatedFiles": false,

  // 선택한 요소의 CSS를 채팅에 추가할지 여부를 제어합니다. `chat.sendElementsToChat.enabled`을(를) 사용하도록 설정해야 합니다.
  "chat.sendElementsToChat.attachCSS": true,

  // 선택한 요소의 스크린샷을 채팅에 추가할지 여부를 제어합니다. `chat.sendElementsToChat.enabled`을(를) 사용하도록 설정해야 합니다.
  "chat.sendElementsToChat.attachImages": true,

  // 단순 브라우저에서 요소를 채팅으로 보낼 수 있는지 여부를 제어합니다.
  "chat.sendElementsToChat.enabled": true,

  // 로그인 대화 상자의 변형을 제어합니다.
  "chat.setup.signInDialogVariant": "default",

  // 채팅에서 할 일 목록을 사용하도록 설정합니다. 이 도구를 사용하면 채팅에서 할 일 목록을 사용할 수 있습니다.
  "chat.todoListTool.enabled": true,

  // 도구 사용을 자동으로 승인할지 여부를 제어합니다.
  //
  // _all_ 도구가 사용자 확인 없이 자동으로 실행되도록 허용하여 터미널 자동 승인과 같은 도구별 설정을 재정의합니다.
  //
  // 주의해서 사용: 선택한 도구를 신중하게 검토하고 프롬프트 삽입의 가능한 원인에 대해 각별히 주의하세요!
  "chat.tools.autoApprove": false,

  // 단순 목록 대신 새 Quick Tree 기반 도구 선택기를 사용하세요. 이 인터페이스는 축소 가능한 섹션, 향상된 시각적 계층 구조, 그리고 네이티브 트리 상호 작용을 통해 도구와 도구 집합의 계층 구조를 더 잘 조직합니다.
  "chat.tools.useTreePicker": true,

  // 실행 취소 요청이 있을 때 채팅 입력을 복원할지 여부를 제어합니다. 복원된 요청의 텍스트로 입력이 채워집니다.
  "chat.undoRequests.restoreInput": true,

  // 저장소 서비스 대신 디스크에 채팅 세션을 저장할 수 있습니다. 이 기능을 사용하면 기존 세션이 작업 영역당 한 번 새 형식으로 마이그레이션됩니다.
  "chat.useFileStorage": true,

  //
  //  - legacy: 레거시 비교 알고리즘을 사용합니다.
  //  - advanced: 고급 비교 알고리즘을 사용합니다.
  "mergeEditor.diffAlgorithm": "advanced",

  // Controls if deletions in base or one of the inputs should be indicated by a vertical bar.
  "mergeEditor.showDeletionMarkers": true,

  // Enable experimental multi diff editor.
  "multiDiffEditor.experimental.enabled": true,

  // 사용하도록 설정하면 새 실행 중인 프로세스가 감지되고 수신하는 포트가 자동으로 전달됩니다. 이 설정을 사용하지 않도록 설정해도 모든 포트가 전달되는 것을 방지할 수 없습니다. 사용하지 않도록 설정하더라도 확장은 여전히 포트를 전달하도록 할 수 있으며 일부 URL을 열면 포트가 계속 전달됩니다. 또한 다음 참조: `remote.autoForwardPortsSource`
  "remote.autoForwardPorts": true,

  // 포트를 자동으로 전달할 때 'process'에서 'hybrid'로의 전환을 트리거하는 자동 전달 포트의 수와 'remote.autoForwardPortsSource'는 기본적으로 'process'로 설정됩니다. 대체를 사용하지 않도록 설정하려면 '0'으로 설정합니다. 'remote.autoForwardPortsFallback'이 구성되지 않았지만 'remote.autoForwardPortsSource'가 구성된 경우 'remote.autoForwardPortsFallback'은 '0'으로 설정된 것처럼 처리됩니다.
  "remote.autoForwardPortsFallback": 20,

  // `remote.autoForwardPorts#`(이)가 true이면 포트가 자동으로 전달되는 원본을 설정합니다. `#remote.autoForwardPorts#`이(가) false이면 `#remote.autoForwardPortsSource`은(는) 이미 전달된 포트에 대한 정보를 찾는 데 사용됩니다. Windows 및 macOS 원격에서 `process` 및 `hybrid` 옵션은 아무런 영향을 주지 않으며 `output`이 사용됩니다.
  //  - process: 포트는 시작되고 포트가 포함된 프로세스를 확인하여 검색되면 자동으로 전달됩니다.
  //  - output: 포트는 터미널 및 디버그 출력을 읽어 검색되면 자동으로 전달됩니다. 포트를 사용하는 프로세스 중 일부는 통합 터미널 또는 디버그 콘솔로 인쇄되지 않으므로 일부 포트가 누락됩니다. 출력을 기반으로 전달되는 포트는 포트 보기에서 사용자에 의해 다시 로드되거나 포트가 닫힐 때까지 "전달 취소"되지 않습니다.
  //  - hybrid: 터미널 및 디버그 출력을 읽어 검색되면 포트가 자동으로 전달됩니다. 포트를 사용하는 모든 프로세스가 통합 터미널 또는 디버그 콘솔에 인쇄되는 것은 아니므로 일부 포트가 누락됩니다. 포트는 해당 포트에서 수신 대기하는 프로세스가 종료될 때까지 기다려 "전달되지 않음" 상태가 됩니다.
  "remote.autoForwardPortsSource": "process",

  // 이미 로컬에 설치된 경우 원격에 연결할 때 설치할 확장 목록입니다.
  "remote.defaultExtensionsIfInstalledLocally": ["GitHub.copilot", "GitHub.copilot-chat", "GitHub.vscode-pull-request-github"],

  // 활성화된 확장이 로컬로 다운로드되고 원격으로 설치됩니다.
  "remote.downloadExtensionsLocally": false,

  // 확장 종류를 재정의합니다. 'ui' 확장은 로컬 머신에 설치되고 실행되며, 'workspace' 확장은 원격 머신에서 실행됩니다. 이 설정을 사용하여 확장의 기본 종류를 재정의함으로써 해당 확장이 로컬 머신에 설치되고 활성화되는지 원격 머신에 설치되고 활성화되는지 여부를 지정합니다.
  "remote.extensionKind": {
    "pub.name": ["ui"]
  },

  // 터미널 및 디버그 콘솔에서 열 때 포트가 있는 로컬 URL을 전달할지 여부를 제어합니다.
  "remote.forwardOnOpen": true,

  // 포트 전달에 사용할 로컬 호스트 이름을 지정합니다.
  "remote.localPortHost": "localhost",

  // 설정 `remote.portsAttributes`에서 속성을 가져오지 않는 모든 포트에 적용되는 기본 속성을 설정합니다. 예:
  //
  // ```
  // {
  //   "onAutoForward": "ignore"
  // }
  // ```
  "remote.otherPortsAttributes": {},

  // 특정 포트 번호가 전달될 때 적용되는 속성을 설정합니다. 예:
  //
  // ```
  // "3000": {
  //   "label": "Application"
  // },
  // "40000-55000": {
  //   "onAutoForward": "ignore"
  // },
  // ".+\\/server.js": {
  //  "onAutoForward": "openPreview"
  // }
  // ```
  "remote.portsAttributes": {
    "443": {
      "protocol": "https"
    },
    "8443": {
      "protocol": "https"
    }
  },

  // 작업 영역에서 전달한 포트를 복원합니다.
  "remote.restoreForwardedPorts": true,

  // 키를 누르면 접근성 보기를 닫고 호출된 요소에 포커스를 둡니다.
  "accessibility.accessibleView.closeOnKeyPress": true,

  // 디버그 조사식 보기에서 변수 변경 내용을 발표해야 하는지 여부를 제어합니다.
  "accessibility.debugWatchVariableAnnouncements": true,

  // 채팅 에이전트가 편집 내용을 적용했을 때 파일을 열어야 하는지 여부를 제어합니다.
  "accessibility.openChatEditedFiles": true,

  // 코드가 실행될 때 포커스를 REPL로 자동으로 보낼지 여부를 제어합니다.
  "accessibility.replEditor.autoFocusReplExecution": "input",

  // 네이티브 REPL에서 실행의 출력을 발표할지 여부를 제어합니다.
  "accessibility.replEditor.readLastExecutionOutput": true,

  // 위치 변경 내용을 디바운스할지 여부
  "accessibility.signalOptions.debouncePositionChanges": false,

  //
  "accessibility.signalOptions.experimental.delays.errorAtPosition": {},

  // Delays for all signals besides error and warning at position
  "accessibility.signalOptions.experimental.delays.general": {},

  //
  "accessibility.signalOptions.experimental.delays.warningAtPosition": {},

  // 소리의 볼륨(백분율)(0-100)입니다.
  "accessibility.signalOptions.volume": 70,

  // 채팅 편집 내용의 변경 내용이 포함된 파일을 공개할 때 소리/오디오 신호를 재생합니다.
  "accessibility.signals.chatEditModifiedFile": {
    "sound": "auto"
  },

  // 채팅 요청이 이루어지면 소리(오디오 신호) 및 알림과 같은 신호를 재생합니다.
  "accessibility.signals.chatRequestSent": {
    "sound": "auto",
    "announcement": "auto"
  },

  // 응답을 받으면 소리/오디오 신호를 재생합니다.
  "accessibility.signals.chatResponseReceived": {
    "sound": "auto"
  },

  // 채팅에서 사용자 작업이 필요할 때 신호음(오디오 신호) 및/또는 알림(경고)을 재생합니다.
  "accessibility.signals.chatUserActionRequired": {
    "sound": "auto",
    "announcement": "auto"
  },

  // 기능이 화면에서 사라지면(예: 터미널, 디버그 콘솔 또는 출력 채널) 소리(오디오 신호) 및 알림과 같은 신호를 재생합니다.
  "accessibility.signals.clear": {
    "sound": "auto",
    "announcement": "auto"
  },

  // 코드 동작이 적용되었을 때 소리 신호를 재생합니다.
  "accessibility.signals.codeActionApplied": {
    "sound": "auto"
  },

  // 코드 동작이 트리거될 때 소리 신호를 재생합니다.
  "accessibility.signals.codeActionTriggered": {
    "sound": "auto"
  },

  // 접근성 Diff 뷰어 모드에서 삭제된 줄 또는 다음/이전 변경으로 포커스가 이동할 때 소리/오디오 신호를 재생합니다.
  "accessibility.signals.diffLineDeleted": {
    "sound": "auto"
  },

  // 접근성 Diff 뷰어 모드에서 삽입된 줄 또는 다음/이전 변경으로 포커스가 이동할 때 소리/오디오 신호를 재생합니다.
  "accessibility.signals.diffLineInserted": {
    "sound": "auto"
  },

  // 접근성 Diff 뷰어 모드에서 수정된 줄 또는 다음/이전 변경으로 포커스가 이동할 때 소리/오디오 신호를 재생합니다.
  "accessibility.signals.diffLineModified": {
    "sound": "auto"
  },

  // 편집이 유지될 때 소리(오디오 신호) 및 알림과 같은 신호를 재생합니다.
  "accessibility.signals.editsKept": {
    "sound": "auto",
    "announcement": "auto"
  },

  // 편집이 취소될 때 소리(오디오 신호) 및 알림과 같은 신호를 재생합니다.
  "accessibility.signals.editsUndone": {
    "sound": "auto",
    "announcement": "auto"
  },

  // 파일 또는 Notebook의 서식이 지정되면 소리(오디오 신호) 및 알림과 같은 신호를 재생합니다.
  "accessibility.signals.format": {
    "sound": "never",
    "announcement": "never"
  },

  // 활성 줄에 중단점이 있는 경우 소리(오디오 신호) 및 알림과 같은 신호를 재생합니다.
  "accessibility.signals.lineHasBreakpoint": {
    "sound": "auto",
    "announcement": "auto"
  },

  // 활성 줄에 오류가 있는 경우 소리(오디오 신호) 및 알림과 같은 신호를 재생합니다.
  "accessibility.signals.lineHasError": {
    "sound": "auto",
    "announcement": "auto"
  },

  // 활성 줄에 펼칠 수 있는 접힌 영역이 있을 때 소리(오디오 신호) 및 알림과 같은 신호를 재생합니다.
  "accessibility.signals.lineHasFoldedArea": {
    "sound": "auto",
    "announcement": "auto"
  },

  // 활성 줄에 인라인 제안이 있을 때 소리/오디오 신호를 재생합니다.
  "accessibility.signals.lineHasInlineSuggestion": {
    "sound": "auto"
  },

  // 활성 줄에 경고가 있는 경우 소리(오디오 신호) 및 알림과 같은 신호를 재생합니다.
  "accessibility.signals.lineHasWarning": {
    "sound": "auto",
    "announcement": "auto"
  },

  // 다음 편집 제안이 있을 때 소리/오디오 신호 및/또는 알림(경고)을 재생합니다.
  "accessibility.signals.nextEditSuggestion": {
    "sound": "auto",
    "announcement": "auto"
  },

  // 인레이 힌트가 없는 인레이 힌트가 있는 줄을 읽으려고 할 때 소리(오디오 신호) 및 알림과 같은 신호를 재생합니다.
  "accessibility.signals.noInlayHints": {
    "sound": "auto",
    "announcement": "auto"
  },

  // Notebook 셀 실행이 성공적으로 완료되면 소리(오디오 신호) 및 알림과 같은 신호를 재생합니다.
  "accessibility.signals.notebookCellCompleted": {
    "sound": "auto",
    "announcement": "auto"
  },

  // Notebook 셀 실행이 실패하면 소리(오디오 신호) 및 알림과 같은 신호를 재생합니다.
  "accessibility.signals.notebookCellFailed": {
    "sound": "auto",
    "announcement": "auto"
  },

  // 디버거가 중단점에서 중지된 경우 소리(오디오 신호) 및 알림과 같은 신호를 재생합니다.
  "accessibility.signals.onDebugBreak": {
    "sound": "auto",
    "announcement": "auto"
  },

  // 활성 줄에 경고가 있는 경우 소리(오디오 신호) 및 알림과 같은 신호를 재생합니다.
  "accessibility.signals.positionHasError": {
    "sound": "auto",
    "announcement": "auto"
  },

  // 활성 줄에 경고가 있는 경우 소리(오디오 신호) 및 알림과 같은 신호를 재생합니다.
  "accessibility.signals.positionHasWarning": {
    "sound": "auto",
    "announcement": "auto"
  },

  // 진행되고 있는 중에 루프에서 소리(오디오 신호) 및 알림과 같은 신호를 재생합니다.
  "accessibility.signals.progress": {
    "sound": "auto",
    "announcement": "auto"
  },

  // 파일이 저장되면 소리(오디오 신호) 및 알림과 같은 신호를 재생합니다.
  "accessibility.signals.save": {
    "sound": "never",
    "announcement": "never"
  },

  // 작업이 완료되면 소리(오디오 신호) 및 알림과 같은 신호를 재생합니다.
  "accessibility.signals.taskCompleted": {
    "sound": "auto",
    "announcement": "auto"
  },

  // 작업이 실패할 때 (0이 아닌 종료 코드) 소리(오디오 신호) 및 알림과 같은 신호를 재생합니다.
  "accessibility.signals.taskFailed": {
    "sound": "auto",
    "announcement": "auto"
  },

  // 터미널 벨이 울릴 때 소리(오디오 신호) 및 알림과 같은 신호를 재생합니다.
  "accessibility.signals.terminalBell": {
    "sound": "auto",
    "announcement": "auto"
  },

  // 터미널 명령이 실패하거나(0이 아닌 종료 코드) 접근성 보기에서 해당 종료 ​​코드가 있는 명령이 탐색될 때 소리(오디오 신호) 및 알림과 같은 신호를 재생합니다.
  "accessibility.signals.terminalCommandFailed": {
    "sound": "auto",
    "announcement": "auto"
  },

  // 터미널 명령이 성공하거나(종료 코드 0) 접근성 보기에서 해당 종료 ​​코드가 있는 명령이 탐색될 때 소리(오디오 신호) 및 알림과 같은 신호를 재생합니다.
  "accessibility.signals.terminalCommandSucceeded": {
    "sound": "auto",
    "announcement": "auto"
  },

  // 터미널 빠른 수정을 사용할 수 있을 때 소리(오디오 신호) 및 알림과 같은 신호를 재생합니다.
  "accessibility.signals.terminalQuickFix": {
    "sound": "auto",
    "announcement": "auto"
  },

  // 음성 녹음이 시작되면 소리/오디오 신호를 재생합니다.
  "accessibility.signals.voiceRecordingStarted": {
    "sound": "on"
  },

  // 음성 녹음이 중지되면 소리/오디오 신호를 재생합니다.
  "accessibility.signals.voiceRecordingStopped": {
    "sound": "auto"
  },

  // 워크벤치에서 링크에 밑줄을 표시할지 여부를 제어합니다.
  "accessibility.underlineLinks": false,

  // 주석 위젯 또는 주석이 포함된 파일에서 수행할 수 있는 작업에 대한 정보를 제공합니다.
  "accessibility.verbosity.comments": true,

  // 디버그 콘솔 또는 실행 및 디버그 뷰렛에 포커스가 있을 때 디버그 콘솔 접근성 도움말 대화 상자에 액세스하는 방법에 대한 정보를 제공합니다. 이 작업을 적용하려면 창을 다시 로드해야 합니다.
  "accessibility.verbosity.debug": true,

  // 포커스 상태일 때 diff 편집기에서 변경 내용을 탐색하는 방법에 대한 정보를 제공합니다.
  "accessibility.verbosity.diffEditor": true,

  // diff 편집기가 활성 편집기가 되는 시기를 나타냅니다.
  "accessibility.verbosity.diffEditorActive": true,

  // 빈 텍스트 편집기에서 관련 작업에 대한 정보를 제공합니다.
  "accessibility.verbosity.emptyEditorHint": true,

  // 접근성 보기에서 호버를 여는 방법에 대한 정보를 제공합니다.
  "accessibility.verbosity.hover": true,

  // 인라인 편집기 채팅 접근성 도움말 메뉴에 액세스하는 방법에 관한 정보를 제공하고, 입력에 포커스할 경우 기능을 사용하는 방법을 설명하는 힌트를 제공합니다.
  "accessibility.verbosity.inlineChat": true,

  // 인라인 완성 가리키기 및 액세스 가능 보기에 액세스하는 방법에 대한 정보를 제공합니다.
  "accessibility.verbosity.inlineCompletions": true,

  // 행에 포커스가 있을 때 키 바인딩 편집기에서 키 바인딩을 변경하는 방법에 대한 정보를 제공합니다.
  "accessibility.verbosity.keybindingsEditor": true,

  // Notebook 셀에 포커스가 있을 때 셀 컨테이너 또는 내부 편집기에 포커스를 두는 방법에 대한 정보를 제공합니다.
  "accessibility.verbosity.notebook": true,

  // 접근성 보기에서 알림을 여는 방법에 대한 정보를 제공합니다.
  "accessibility.verbosity.notification": true,

  // 채팅 입력에 포커스가 있을 때 채팅 도움말 메뉴에 액세스하는 방법에 대한 정보를 제공합니다.
  "accessibility.verbosity.panelChat": true,

  // REPL 편집기에 포커스가 있을 때 REPL 편집기 접근성 도움말 메뉴에 액세스하는 방법에 대한 정보를 제공합니다.
  "accessibility.verbosity.replEditor": true,

  // 입력에 초점이 맞춰져 있을 때 소스 컨트롤 접근성 도움말 메뉴에 액세스하는 방법에 대한 정보를 제공합니다.
  "accessibility.verbosity.sourceControl": true,

  // 터미널이 포커스 상태일 때 터미널 접근성 도움말 메뉴에 액세스하는 방법에 대한 정보를 제공합니다.
  "accessibility.verbosity.terminal": true,

  // 접근 가능한 보기에서 연습을 여는 방법에 대한 정보를 제공합니다.
  "accessibility.verbosity.walkthrough": true,

  // 화면 읽기 프로그램 모드에서 `window.title`(을)를 화면 읽기 프로그램에 최적화해야 하는지 여부를 제어합니다. 사용하도록 설정하면 창 제목의 끝에 `activeEditorState`이(가) 추가됩니다.
  "accessibility.windowTitleOptimized": true,

  // 네이티브 대화 상자, 메뉴 및 제목 표시줄과 같은 네이티브 UI 요소의 색 모드를 설정합니다. OS가 밝은 색 모드로 구성된 경우에도 창에 어두운 시스템 색 테마를 사용하도록 선택할 수 있습니다. `workbench.colorTheme` 설정에 따라 자동으로 조정되도록 구성할 수도 있습니다.
  //
  // 참고: `window.autoDetectColorScheme`이(가) 활성화된 경우 이 설정은 무시됩니다.
  //  - default: 네이티브 위젯 색은 시스템 색과 일치합니다.
  //  - auto: 밝은 색 테마에는 밝은 네이티브 위젯 색을 사용하고 어두운 색 테마에는 어두운 색을 사용합니다.
  //  - light: 밝은 네이티브 위젯 색을 사용합니다.
  //  - dark: 어두운 네이티브 위젯 색을 사용합니다.
  "window.systemColorTheme": "default",

  // 원격 터널 액세스가 등록되는 이름입니다. 설정하지 않으면 호스트 이름이 사용됩니다.
  "remote.tunnels.access.hostNameOverride": "",

  // 원격 터널 액세스가 켜져 있을 때 이 컴퓨터가 절전 모드로 전환되지 않도록 합니다.
  "remote.tunnels.access.preventSleep": false,

  // Emmet 약어는 확장하면 안 되는 언어의 배열입니다.
  "emmet.excludeLanguages": ["markdown"],

  // 각 경로에 Emmet 구문Profiles 및/또는 코드 조각 파일이 포함될 수 있는 경로 배열입니다.
  // 충돌하는 경우 이후 경로의 프로필/코드 조각이 이전 경로의 프로필/코드 조각을 재정의합니다.
  // 자세한 내용과 예제 코드 조각 파일은 https://code.visualstudio.com/docs/editor/emmet을 참조하세요.
  "emmet.extensionsPath": [],

  // 기본적으로 지원되지 않는 언어에서 Emmet 약어를 사용하도록 설정합니다. 언어와 Emmet 지원 언어 간에 매핑을 여기에 추가합니다.
  // 예: '{"vue-html": "html", "javascript": "javascriptreact"}'
  "emmet.includeLanguages": {},

  // 'false'로 설정할 경우 전체 파일이 구문 분석되어 현재 위치가 Emmet 약어 확장에 유효한지 확인합니다. 'true'로 설정할 경우 CSS/SCSS/Less 파일에서 현재 위치 주변의 콘텐츠만 구문 분석합니다.
  "emmet.optimizeStylesheetParsing": true,

  // Emmet의 일부 작업 및 해결 프로그램의 동작을 수정하는 데 사용되는 기본 설정입니다.
  "emmet.preferences": {},

  // 가능한 Emmet 약어를 제안으로 표시합니다. 스타일시트에는 적용되지 않고 emmet.showExpandedAbbreviation이 "never"로 설정되어 있을 때도 적용되지 않습니다.
  "emmet.showAbbreviationSuggestions": true,

  // 확장된 Emmet 약어를 제안 사항으로 표시합니다.
  // `"inMarkupAndStylesheetFilesOnly"` 옵션은 html, haml, jade, slim, xml, xsl, css, scss, sass, less 및 stylus에 적용됩니다.
  // `"always"` 옵션은 태그/css에 관계없이 파일의 모든 부분에 적용됩니다.
  "emmet.showExpandedAbbreviation": "always",

  // 'True'이면 Emmet 제안이 코드 조각으로 표시되며 `editor.snippetSuggestions` 설정에 따라 코드 조각을 정렬할 수 있습니다.
  "emmet.showSuggestionsAsSnippets": false,

  // 지정된 구문에 대한 프로필을 정의하거나 특정 규칙이 포함된 고유한 프로필을 사용하세요.
  "emmet.syntaxProfiles": {},

  // 사용하도록 설정하면 완성된 내용이 표시되지 않는 경우에도 Tab 키를 누르면 Emmet 약어가 확장됩니다. 사용하지 않도록 설정하더라도 완성된 내용이 표시되는 경우에 Tab 키를 눌러 확장할 수 있습니다.
  "emmet.triggerExpansionOnTab": false,

  // 'true'인 경우 Emmet은 인라인 완성을 사용하여 확장을 제안합니다. 이 설정이 'true'인 동안 인라인이 아닌 완료 항목 공급자가 자주 표시되지 않도록 하려면 '다른' 항목에 대해 '#editor.quickSuggestions#'를 'inline' 또는 'off'로 전환합니다.
  "emmet.useInlineCompletions": false,

  // emmet 조각에 사용되는 변수입니다.
  "emmet.variables": {},

  // 강제 푸시(임대 사용 또는 사용 안 함)가 가능한지 여부를 제어합니다.
  "git.allowForcePush": false,

  // pre-commit 및 commit-msg 후크를 실행하지 않는 커밋이 허용되는지를 제어합니다.
  "git.allowNoVerifyCommit": false,

  // 스테이징된 변경 내용 리소스 그룹을 항상 표시합니다.
  "git.alwaysShowStagedChangesResourceGroup": false,

  // 모든 커밋에 대한 확인 플래그를 제어합니다.
  "git.alwaysSignOff": false,

  // true로 설정하면 커밋이 현재 Git 리포지토리의 기본 원격에서 자동으로 페치됩니다. 'all'로 설정하면 모든 원격에서 페치됩니다.
  "git.autofetch": false,

  // #git.autofetch#가 사용되는 경우 각 자동 git fetch 사이의 시간(초)입니다.
  "git.autofetchPeriod": 180,

  // 자동 새로 고침을 사용할지 여부입니다.
  "git.autorefresh": true,

  // 리포지토리가 자동으로 감지되어야 하는 경우를 구성합니다.
  //  - true: 현재 열려 있는 폴더의 하위 폴더와 열려 있는 파일의 부모 폴더를 모두 검사합니다.
  //  - false: 자동 리포지토리 검사를 사용하지 않습니다.
  //  - subFolders: 현재 열려 있는 폴더의 하위 폴더를 검사합니다.
  //  - openEditors: 열려 있는 파일의 부모 폴더를 검사합니다.
  "git.autoRepositoryDetection": true,

  // 풀하기 전에 변경 내용을 스태시하고 풀하는 데 성공한 후 변경 내용을 복원합니다.
  "git.autoStash": false,

  // 편집기 장식을 사용하여 편집기에서 git 블레임 정보를 표시할지 여부를 제어합니다.
  "git.blame.editorDecoration.enabled": false,

  // 블레임 정보 편집기 장식의 템플릿입니다. 지원되는 변수:
  //
  // * `hash`: 커밋 해시
  //
  // * 'hashShort': '#git.commitShortHashLength#'에 따라 커밋 해시의 첫 번째 N 문자
  //
  // * 'subject': 커밋 메시지의 첫 줄
  //
  // * 'authorName': 작성자 이름
  //
  // * 'authorEmail': 작성자 이메일
  //
  // * 'authorDate': 작성자 날짜
  //
  // * 'authorDateAgo': 현재 날짜와 작성자 날짜 간의 시간 차이
  //
  //
  "git.blame.editorDecoration.template": "${subject}, ${authorName} (${authorDateAgo})",

  // 상태 표시줄에 블레임 정보를 표시할지 여부를 제어합니다.
  "git.blame.statusBarItem.enabled": true,

  // 블레임 정보 상태 표시줄 항목에 대한 템플릿입니다. 지원되는 변수:
  //
  // * `hash`: 커밋 해시
  //
  // * 'hashShort': '#git.commitShortHashLength#'에 따라 커밋 해시의 첫 번째 N 문자
  //
  // * 'subject': 커밋 메시지의 첫 줄
  //
  // * 'authorName': 작성자 이름
  //
  // * 'authorEmail': 작성자 이메일
  //
  // * 'authorDate': 작성자 날짜
  //
  // * 'authorDateAgo': 현재 날짜와 작성자 날짜 간의 시간 차이
  //
  //
  "git.blame.statusBarItem.template": "${authorName} (${authorDateAgo})",

  // 새 브랜치를 만들 때 사용되는 접두사입니다.
  "git.branchPrefix": "",

  // 보호된 브랜치 목록입니다. 기본적으로 변경 내용이 보호된 브랜치에 커밋되기 전에 프롬프트가 표시됩니다. 프롬프트는 '#git.branchProtectionPrompt#' 설정을 사용하여 제어할 수 있습니다.
  "git.branchProtection": [],

  // 변경 내용이 보호된 분기에 커밋되기 전에 프롬프트가 표시되는지 여부를 제어합니다.
  //  - alwaysCommit: 항상 보호된 브랜치에 변경 내용을 커밋합니다.
  //  - alwaysCommitToNewBranch: 변경 사항을 항상 새 브랜치에 커밋
  //  - alwaysPrompt: 변경 내용이 보호된 분기에 커밋되기 전에 항상 프롬프트를 표시합니다.
  "git.branchProtectionPrompt": "alwaysPrompt",

  // 무작위로 생성된 분기 이름에 사용되는 사전 목록입니다. 각 값은 분기 이름의 세그먼트를 생성하는 데 사용되는 사전을 나타냅니다. 지원되는 사전: '형용사', '동물', '색상', '숫자'.
  //  - adjectives: 무작위 형용사
  //  - animals: 임의의 동물 이름
  //  - colors: 임의의 색상 이름
  //  - numbers: 100에서 999 사이의 난수
  "git.branchRandomName.dictionary": ["adjectives", "animals"],

  // 새 브랜치를 만들 때 임의 이름이 생성되는지 여부를 제어합니다.
  "git.branchRandomName.enable": false,

  // 분기의 정렬 순서를 제어합니다.
  "git.branchSortOrder": "committerdate",

  // 새 분기 이름의 유효성을 검사하는 정규식입니다.
  "git.branchValidationRegex": "",

  // 새 브랜치 이름의 공백을 바꾸고 임의로 생성된 브랜치 이름의 세그먼트를 구분할 문자입니다.
  "git.branchWhitespaceChar": "-",

  // '다음으로 체크 아웃...'을 실행할 때 나열되는 Git 참조의 형식을 제어합니다.
  //  - local: 로컬 분기
  //  - tags: 태그
  //  - remote: 원격 분기
  "git.checkoutType": ["local", "remote", "tags"],

  // 변경 내용을 스태시, 커밋, 삭제, 스테이징 또는 스테이징 해제할 때 diff 편집기를 자동으로 닫을지 여부를 제어합니다.
  "git.closeDiffOnOperation": false,

  // `stdout`를 [git output](command:git.showOutput)에 기록하는 git 명령(예: 커밋, 푸시) 목록입니다. git 명령에 클라이언트 측 후크가 구성된 경우 클라이언트 측 후크의 `stdout`도 [git output](command:git.showOutput)에 기록됩니다.
  "git.commandsToLog": [],

  // 커밋 짧은 해시의 길이를 제어합니다.
  "git.commitShortHashLength": 7,

  // 'Git: Commit Empty' 명령에 대한 빈 항목 생성 커밋을 항상 확인합니다.
  "git.confirmEmptyCommits": true,

  // 강제 푸시하기 전에 확인을 요청할지 여부를 제어합니다.
  "git.confirmForcePush": true,

  // 확인하지 않고 커밋하기 전에 확인을 요청할지를 제어합니다.
  "git.confirmNoVerifyCommit": true,

  // Git 리포지토리를 동기화하기 전에 확인합니다.
  "git.confirmSync": true,

  // Git 개수 배지를 제어합니다.
  //  - all: 모든 변경 내용을 계산합니다.
  //  - tracked: 추적된 변경 내용만 계산합니다.
  //  - off: 카운터를 끕니다.
  "git.countBadge": "all",

  // Git에서 색과 배지를 탐색기와 열려 있는 편집기 뷰에 적용하는지 여부를 제어합니다.
  "git.decorations.enabled": true,

  // 새 Git 리포지토리를 초기화할 때 기본 분기(예: main, trunk, development)의 이름입니다. 빈 값으로 설정하면 Git에 구성된 기본 분기 이름이 사용됩니다. **참고:** Git 버전 `2.28.0` 이상이 필요합니다.
  "git.defaultBranchName": "main",

  // Git 리포지토리를 복제할 기본 위치입니다.
  "git.defaultCloneDirectory": null,

  // Git 하위 모듈을 자동으로 검색할지 여부를 제어합니다.
  "git.detectSubmodules": true,

  // Git submodules 검출 개수의 제한을 제어합니다.
  "git.detectSubmodulesLimit": 10,

  // Git 작업 트리를 자동으로 검색할지 여부를 제어합니다.
  "git.detectWorktrees": true,

  // 검색된 Git 작업 트리의 제한을 제어합니다.
  "git.detectWorktreesLimit": 10,

  // 커밋하기 전에 해결되지 않은 진단을 확인할지 여부를 제어합니다.
  "git.diagnosticsCommitHook.enabled": false,

  // 커밋하기 전에 고려할 원본 목록(**항목**) 및 최소 심각도(**값**)를 제어합니다. **참고:** 특정 원본의 진단을 무시하려면 원본을 목록에 추가하고 최소 심각도를 '없음'으로 설정합니다.
  "git.diagnosticsCommitHook.sources": {
    "*": "error"
  },

  // 추적되지 않은 변경 내용을 삭제할 때 파일을 영구적으로 삭제하는 대신 휴지통(Windows), 휴지통(macOS, Linux)으로 이동할지 여부를 제어합니다. **참고:** 이 설정은 원격에 연결되거나 Linux에서 스냅 패키지로 실행할 경우에는 영향을 주지 않습니다.
  "git.discardUntrackedChangesToTrash": true,

  // GPG, X.509 또는 SSH로 서명 커밋을 사용합니다.
  "git.enableCommitSigning": false,

  // Git을 사용하도록 설정했는지 여부입니다.
  "git.enabled": true,

  // 단계적 변경 사항이 없는 경우 모든 변경 사항을 저장합니다.
  "git.enableSmartCommit": false,

  // Git Sync 명령이 상태 표시줄에 표시되는지 여부를 제어합니다.
  "git.enableStatusBarSync": true,

  // 사용하도록 설정하면 풀할 때 모든 분기를 페치합니다. 그렇지 않으면 현재 분기만 페치합니다.
  "git.fetchOnPull": false,

  // 동기화 명령을 실행할 때 주석이 추가된 모든 태그를 푸시합니다.
  "git.followTagsWhenSync": false,

  // This setting is now deprecated, please use `github.gitAuthentication` instead.
  //
  "git.githubAuthentication": null,

  // 무시할 Git 리포지토리의 목록입니다.
  "git.ignoredRepositories": [],

  // 레거시 Git 경고를 무시합니다.
  "git.ignoreLegacyWarning": false,

  // 리포지토리에 변경 내용이 너무 많으면 경고를 무시합니다.
  "git.ignoreLimitWarning": false,

  // Git이 없으면 경고를 무시합니다.
  "git.ignoreMissingGitWarning": false,

  // 풀할 때 분기가 다시 지정된 것 같은 경우 경고를 무시합니다.
  "git.ignoreRebaseWarning": false,

  // 파일 트리의 하위 모듈 수정 내용을 무시합니다.
  "git.ignoreSubmodules": false,

  // Windows에 Git 2.25~2.26이 설치되어 있는 경우 경고를 무시합니다.
  "git.ignoreWindowsGit27Warning": false,

  // 커밋 메시지 입력 유효성 검사 진단을 표시할지 여부를 제어합니다.
  "git.inputValidation": false,

  // 경고 표시를 위한 커밋 메시지 길이 임계값을 제어합니다.
  "git.inputValidationLength": 72,

  // 경고 표시를 위한 커밋 메시지 제목 길이 임계값을 제어합니다. `git.inputValidationLength` 값을 상속하려면 이 임계값 설정을 해제하세요.
  "git.inputValidationSubjectLength": 50,

  // 현재 충돌 된 파일의 병합 편집기를 엽니다.
  "git.mergeEditor": false,

  // 복제 후에 자동으로 리포지토리를 열지 여부를 제어합니다.
  //  - always: 항상 현재 창에서 엽니다.
  //  - alwaysNewWindow: 항상 새 창에서 엽니다.
  //  - whenNoFolderOpen: 열려 있는 폴더가 없는 경우에만 현재 창에서 엽니다.
  //  - prompt: 항상 동작을 확인합니다.
  "git.openAfterClone": "prompt",

  // 변경을 클릭할 때 Diff 편집기가 열릴지 여부를 제어합니다. 그렇지 않으면 일반 편집기가 열립니다.
  "git.openDiffOnClick": true,

  // 작업 영역 또는 열린 파일의 부모 폴더에 있는 리포지토리를 열지 여부를 제어합니다.
  //  - always: 항상 작업 영역의 부모 폴더에서 리포지토리를 열거나 파일을 엽니다.
  //  - never: 작업 영역의 부모 폴더에서 리포지토리를 열거나 파일을 열지 마세요.
  //  - prompt: 작업 영역의 부모 폴더에서 리포지토리를 열거나 파일을 열기 전에 프롬프트를 표시합니다.
  "git.openRepositoryInParentFolders": "prompt",

  // Git 명령을 실행한 후 소스 제어 뷰의 상태를 낙관적으로 업데이트할지 여부를 제어합니다.
  "git.optimisticUpdate": true,

  // git 실행 파일의 경로 및 파일 이름입니다(예: `C:\Program Files\Git\bin\git.exe`(Windows)). 조회할 여러 경로를 포함하는 문자열 값의 배열일 수도 있습니다.
  "git.path": null,

  // 커밋이 성공한 후 git 명령을 실행합니다.
  //  - none: 커밋 후 명령을 실행하지 않습니다.
  //  - push: 커밋이 성공한 후 'git push'를 실행합니다.
  //  - sync: 커밋이 성공한 후 'git pull' 및 'git push'를 실행합니다.
  "git.postCommitCommand": "none",

  // Git가 제출(commit)하기 전에 저장되지 않은 파일을 검사할지를 제어합니다.
  //  - always: 저장되지 않은 파일이 있는지 확인합니다.
  //  - staged: 저장되지 않은 스테이징된 파일만 확인합니다.
  //  - never: 이 검사를 사용하지 않도록 설정합니다.
  "git.promptToSaveFilesBeforeCommit": "always",

  // Git이 변경 사항을 스태시하기 전에 저장되지 않은 파일을 검사할지를 제어합니다.
  //  - always: 저장되지 않은 파일이 있는지 확인합니다.
  //  - staged: 저장되지 않은 스테이징된 파일만 확인합니다.
  //  - never: 이 검사를 사용하지 않도록 설정합니다.
  "git.promptToSaveFilesBeforeStash": "always",

  // 페치할 때 정리합니다.
  "git.pruneOnFetch": false,

  // 나가는 커밋이 없는 분기를 체크아웃하기 전에 빨리 감기할지 여부를 제어합니다.
  "git.pullBeforeCheckout": false,

  // 풀할 때 모든 태그를 페치합니다.
  "git.pullTags": true,

  // 동기화 명령을 실행할 때 Git에서 다시 지정을 사용하게 합니다.
  "git.rebaseWhenSync": false,

  // 커밋 후 실행된 마지막 git 명령을 기억하세요.
  "git.rememberPostCommitCommand": false,

  // 풀 명령을 실행할 때 충돌이 발생할 경우 로컬 태그를 원격 태그로 자동으로 교체합니다.
  "git.replaceTagsWhenPull": false,

  // `git.autoRepositoryDetection`이 `true` 또는 `subFolders`로 설정된 경우 Git 리포지토리를 검색하는 동안 무시되는 폴더 목록입니다.
  "git.repositoryScanIgnoredFolders": ["node_modules"],

  // `git.autoRepositoryDetection`이 `true` 또는 `subFolders`로 설정된 경우 Git 리포지토리에 대한 작업 영역 간 폴더를 스캔할 때 사용되는 깊이를 제어합니다. 제한 없이 '-1'로 설정할 수 있습니다.
  "git.repositoryScanMaxDepth": 1,

  // 명시적 Git 사용자 구성을 요구할지 또는 누락된 경우 Git에서 추측하도록 허용할지를 제어합니다.
  "git.requireGitUserConfig": true,

  // Git 리포지토리를 검색할 경로의 목록입니다.
  "git.scanRepositories": [],

  // 작업 단추가 원본 제어 뷰에 표시되는지 여부를 제어합니다.
  "git.showActionButton": {
    "commit": true,
    "publish": true,
    "sync": true
  },

  // Git 소스 제어판에 커밋 입력을 표시할지 여부를 제어합니다.
  "git.showCommitInput": true,

  // Git 변경점 보기에서 파일 열기 동작 줄을 표시할지의 여부를 제어합니다.
  "git.showInlineOpenFileAction": true,

  // Git 작업에서 진행률을 표시할지 여부를 제어합니다.
  "git.showProgress": true,

  // 푸시가 성공했을 때 알림을 표시할지 여부를 제어합니다.
  "git.showPushSuccessNotification": false,

  // Git 참조에 대한 마지막 커밋의 세부 정보를 checkout, branch 및 tag 선택기에 표시할지 여부를 제어합니다.
  "git.showReferenceDetails": true,

  // 추가/삭제된 파일 쌍의 변경 사항을 이름 변경으로 간주하기 위한 유사성 색인의 임계값(파일 크기와 비교한 추가/삭제 양)을 제어합니다. **참고:** Git 버전 `2.18.0` 이상이 필요합니다.
  "git.similarityThreshold": 50,

  // 스마트 커밋에서 자동으로 스테이징되는 변경 사항을 제어합니다.
  //  - all: 모든 변경 사항을 자동으로 스테이징합니다.
  //  - tracked: 추적된 변경 사항만 자동으로 스테이징했습니다.
  "git.smartCommitChanges": "all",

  // Git 상태 명령에서 구문 분석할 수 있는 변경 내용의 수를 제한하는 방법을 제어합니다. 제한이 없는 경우 0으로 설정할 수 있습니다.
  "git.statusLimit": 10000,

  // 스마트 커밋을 사용하도록 제안합니다(스테이징된 변경 사항이 없는 경우 모든 변경 사항 커밋).
  "git.suggestSmartCommit": true,

  // 동기화 작업을 실행할 때 사용자가 작업을 취소할 수 있도록 알림이 표시되는지 여부를 제어합니다.
  "git.supportCancellation": false,

  // 통합 터미널에서 생성된 Git 프로세스의 인증 처리기로 VS Code를 사용할지를 제어합니다. 참고: 이 설정의 변경 내용을 적용하려면 터미널을 다시 시작해야 합니다.
  "git.terminalAuthentication": true,

  // 통합 터미널에서 생성된 Git 프로세스에 대해 Git 편집기로 VS Code를 사용할지 여부를 제어합니다. 참고: 이 설정에서 변경 사항을 선택하려면 터미널을 다시 시작해야 합니다.
  "git.terminalGitEditor": false,

  // 타임라인 보기에서 항목에 사용할 날짜를 제어합니다.
  //  - committed: 커밋된 날짜 사용
  //  - authored: 작성 날짜 사용
  "git.timeline.date": "committed",

  // 타임라인 보기에 커밋 작성자를 표시할지를 제어합니다.
  "git.timeline.showAuthor": true,

  // 타임라인 보기에서 커밋되지 않은 변경 내용을 표시할지 여부를 제어합니다.
  "git.timeline.showUncommitted": false,

  // 추적되지 않은 변경 내용의 작동 방식을 제어합니다.
  //  - mixed: 추적 및 추적되지 않은 모든 변경 내용이 함께 표시되고 동일한 작업이 수행됩니다.
  //  - separate: 추적되지 않은 변경 내용은 소스 제어 보기에 별도로 표시됩니다. 또한 여러 작업에서 제외됩니다.
  //  - hidden: 추적되지 않은 변경 내용이 숨겨지고 여러 작업에서 제외됩니다.
  "git.untrackedChanges": "mixed",

  // 커밋 입력 상자의 메시지를 기본 스태시 메시지로 사용할지 여부를 제어합니다.
  "git.useCommitInputAsStashMessage": false,

  // 커밋 입력 상자에 메시지가 제공되지 않을 때마다 커밋 메시지를 작성하는 데 전체 텍스트 편집기를 사용할지 여부를 제어합니다.
  "git.useEditorAsCommitInput": true,

  // 강제 푸시가 더 안전한 force-if-includes 변형을 사용하는지 여부를 제어합니다. 참고: 이 설정을 사용하려면 '#git.useForcePushWithLease#' 설정 및 Git 버전 '2.30.0' 이상이 필요합니다.
  "git.useForcePushIfIncludes": true,

  // 강제 푸시가 좀 더 안전한 force-with-lease 변형을 사용하는지 여부를 제어합니다.
  "git.useForcePushWithLease": true,

  // 통합 버전을 사용하기 위해 GIT_ASKPASS를 덮어써야 하는지 여부를 제어합니다.
  "git.useIntegratedAskPass": true,

  // '#git.useEditorAsCommitInput#'이 사용하도록 설정된 경우 자세한 정보 표시 출력을 사용하도록 설정합니다.
  "git.verboseCommit": false,

  // GitHub 리포지토리에 대한 리포지토리 규칙을 쿼리할지 여부를 제어합니다.
  "github.branchProtection": true,

  // VS Code 내에서 Git 명령에 대해 자동 GitHub 인증을 사용하도록 설정할지 여부를 제어합니다.
  "github.gitAuthentication": true,

  // GitHub 리포지토리를 복제하는 데 사용되는 프로토콜 제어
  "github.gitProtocol": "https",

  // 다양한 호버에 커밋 작성자 GitHub 아바타를 표시할지 여부를 제어합니다(예: Git 블레임, Timeline, Source Control Graph 등).
  "github.showAvatar": true,

  // GHE.com 또는 GitHub Enterprise Server instance URI입니다.
  //
  // 예제:
  // * GHE.com: 'https://octocat.ghe.com`
  // * GitHub Enterprise Server: 'https://github.octocat.com`
  //
  // > **참고:** 이 값은 _not_이(가) GitHub.com URI로 설정되어야 합니다. 계정이 GitHub.com 있거나 GitHub Enterprise 관리되는 사용자인 경우 추가 구성이 필요하지 않으며 GitHub에 로그인할 수 있습니다.
  "github-enterprise.uri": "",

  // Grunt 작업 검색의 활성화를 제어합니다. Grunt 작업 검색으로 인해 열려 있는 작업 영역의 파일이 실행될 수 있습니다.
  "grunt.autoDetect": "off",

  // Gulp 작업 검색의 활성화를 제어합니다. Gulp 작업 검색으로 인해 열려 있는 작업 영역의 파일이 실행될 수 있습니다.
  "gulp.autoDetect": "off",

  // 작업자 스레드에서 Jupyter Notebook을 직렬화하는 실험적 기능입니다.
  "ipynb.experimental.serialization": true,

  // ipynb 노트북 파일의 Markdown 셀에 이미지 붙여넣기를 활성화/비활성화합니다. 붙여넣은 이미지는 셀에 첨부 파일로 삽입됩니다.
  "ipynb.pasteImagesAsAttachments.enabled": true,

  // Jake 작업 검색의 사용 여부를 제어합니다. Jake 작업 검색으로 인해 열려 있는 작업 영역의 파일이 실행될 수 있습니다.
  "jake.autoDetect": "off",

  // 기본 제공 Markdown 미리 보기에서 렌더링 수학을 사용하거나 사용하지 않도록 설정합니다.
  "markdown.math.enabled": true,

  // 사용자 지정 매크로의 컬렉션입니다. 각 매크로는 키-값 쌍으로, 키는 새 명령 이름이고 값은 매크로의 확장입니다.
  "markdown.math.macros": {},

  // 자동으로 음소거 시 비디오 재생을 시작합니다.
  "mediaPreview.video.autoPlay": false,

  // 비디오를 자동으로 반복합니다.
  "mediaPreview.video.loop": false,

  // 병합 충돌을 해결한 후 다음 병합 충돌로 자동으로 이동할지 여부입니다.
  "merge-conflict.autoNavigateNextConflict.enabled": false,

  // 편집기 내에서 병합 충돌 블록에 대한 Code Lens를 만듭니다.
  "merge-conflict.codeLens.enabled": true,

  // 편집기 내에서 병합 충돌 블록에 대한 decorator를 만듭니다.
  "merge-conflict.decorators.enabled": true,

  // 병합 충돌에서 변경 내용을 비교할 때 diff 뷰가 열리는 위치를 제어합니다.
  //  - Current: 현재 편집기 그룹에서 diff 뷰를 엽니다.
  //  - Beside: 현재 편집기 그룹 옆에 있는 diff 뷰를 엽니다.
  //  - Below: 현재 편집기 그룹 아래에 diff 뷰를 엽니다.
  "merge-conflict.diffViewPosition": "Current",

  // Microsoft 소버린 클라우드 인증 공급자와 함께 사용할 소버린 클라우드에 대한 사용자 지정 구성입니다. 이 기능을 사용하려면 `microsoft-sovereign-cloud.environment`을 'custom'으로 설정해야 합니다.
  "microsoft-sovereign-cloud.customEnvironment": {},

  // 인증에 사용할 소버린 클라우드입니다. 'custom'을 선택하는 경우 `microsoft-sovereign-cloud.customEnvironment` 설정도 설정해야 합니다.
  //  - ChinaCloud: Azure 중국
  //  - USGovernment: Azure 미국 정부
  //  - custom: 사용자 지정 Microsoft 소버린 클라우드
  "microsoft-sovereign-cloud.environment": "",

  // Microsoft 계정 사용하여 로그인하는 데 사용할 인증 구현입니다.
  //
  // *참고: 'classic' 구현은 사용되지 않으며 이후 릴리스에서 이 설정과 함께 제거됩니다. 'classic' 구현만 작동하는 경우 [open an issue](command:workbench.action.openIssueReporter)하고 로그인하려는 항목을 설명하세요.*
  //  - msal: MSAL(Microsoft 인증 라이브러리)을 사용하여 Microsoft 계정에 로그인합니다.
  //  - classic: (사용되지 않음) 클래식 인증 흐름을 사용하여 Microsoft 계정 로그인합니다.
  "microsoft-authentication.implementation": "msal",

  // `debug.node.autoAttach`이 설정되어 있는 경우 자동으로 연결 및 디버그할 프로세스를 구성합니다. 이 설정과 관계없이 `--inspect` 플래그로 시작한 노드 프로세스가 항상 연결됩니다.
  //  - always: 터미널에서 시작되는 모든 Node.js 프로세스에 자동으로 연결합니다.
  //  - smart: node_modules 폴더에 있지 않은 스크립트를 실행할 때 자동으로 연결합니다.
  //  - onlyWithFlag: '--inspect'가 지정된 경우에만 자동으로 연결합니다.
  //  - disabled: 자동 연결이 사용하지 않도록 설정되어 있고 상태 표시줄에 표시되지 않습니다.
  "debug.javascript.autoAttachFilter": "disabled",

  // "smart" `debug.javascript.autoAttachFilter` 모드로 연결할 시간을 결정하는 GLOB 패턴을 구성합니다. `$KNOWN_TOOLS$`이(가) 공용 테스트 및 코드 실행기의 이름 목록으로 바뀝니다. [VS Code 문서에서 자세히 읽기](https://code.visualstudio.com/docs/nodejs/nodejs-debugging#_auto-attach-smart-patterns).
  "debug.javascript.autoAttachSmartPattern": ["${workspaceFolder}/**", "!**/node_modules/**", "**/$KNOWN_TOOLS$/**"],

  // 원격 웹 앱을 디버깅할 때 원격 서버를 로컬 컴퓨터에 자동으로 터널링할지 여부를 구성합니다.
  "debug.javascript.automaticallyTunnelRemoteServer": true,

  // 조건부 중단점에서 오류가 발생하면 중지할지 여부입니다.
  "debug.javascript.breakOnConditionalError": false,

  // npm 스크립트에 "실행" 및 "디버그" 코드 렌즈가 표시되어야 하는 위치입니다. "all", 스크립트, 스크립트 섹션의 "top" 또는 "never"일 수 있습니다.
  "debug.javascript.codelens.npmScripts": "top",

  // 디버그 터미널 내부에서 클릭한 열린 링크를 디버깅할 때 사용되는 옵션입니다. 이 동작을 사용하지 않도록 설정하려면 "false"로 설정할 수 있습니다.
  "debug.javascript.debugByLinkOptions": "on",

  // 지정되지 않은 경우 시작 구성에 사용되는 기본 `runtimeExecutable`입니다. 이 설정을 사용하여 Node.js 또는 브라우저 설치의 사용자 지정 경로를 구성할 수 있습니다.
  "debug.javascript.defaultRuntimeExecutable": {
    "pwa-node": "node"
  },

  // 실험적 네트워크 보기를 지원하는 대상에 대해 실험적 네트워크 보기를 활성화합니다.
  "debug.javascript.enableNetworkView": true,

  // '디버그: Node.js 프로세스에 연결' 명령을 통해 프로세스를 디버그할 때 사용되는 기본 옵션입니다.
  "debug.javascript.pickAndAttachOptions": {},

  // 디버거에서 소스 맵과 같은 리소스를 로드할 때 사용할 요청 옵션입니다. 예를 들어 sourcemap에서 인증을 요구하거나 자체 서명된 인증서를 사용하는 경우 이 옵션을 구성해야 할 수 있습니다. 옵션은 [`got`](https://github.com/sindresorhus/got) 라이브러리를 사용하여 요청을 만드는 데 사용됩니다.
  //
  // 일반적으로 `{ "https": { "rejectUnauthorized": false } }`를 전달하여 인증서 확인을 사용하지 않도록 설정할 수 있습니다.
  "debug.javascript.resourceRequestOptions": {},

  // JavaScript 디버그 터미널 및 npm 스크립트에 대한 기본 시작 옵션입니다.
  "debug.javascript.terminalOptions": {},

  // 원본 파일을 읽을 수 없는 sourcemap된 파일을 자동으로 매핑 해제하는지를 구성합니다. false(기본값)인 경우 프롬프트가 표시됩니다.
  "debug.javascript.unmapMissingSources": false,

  // npm 스크립트가 자동으로 감지되어야 하는지 여부를 제어합니다.
  "npm.autoDetect": "on",

  // 탐색기 컨텍스트 메뉴의 폴더에 포함된 NPM 스크립트 실행을 사용하도록 설정합니다.
  "npm.enableRunFromFolder": false,

  // The NPM Script Explorer is now available in 'Views' menu in the Explorer in all folders.
  // 최상위 'package.json' 파일이 없는 경우 npm 스크립트의 탐색기 보기를 사용하도록 설정합니다.
  "npm.enableScriptExplorer": false,

  // 자동 스크립트 검색에서 제외할 폴더에 대한 Glob 패턴을 구성합니다.
  "npm.exclude": "",

  // https://registry.npmjs.org 및 https://registry.bower.io에서 데이터를 가져와 npm 종속성의 가리키기 기능에 대한 정보 및 자동 완성을 제공합니다.
  "npm.fetchOnlinePackageInfo": true,

  // 종속성을 설치하는 데 사용되는 패키지 관리자입니다.
  //  - auto: 잠금 파일 및 설치된 패키지 관리자를 기반으로 사용할 패키지 관리자를 자동 감지합니다.
  //  - npm: npm을 패키지 관리자로 사용합니다.
  //  - yarn: yarn을 패키지 관리자로 사용합니다.
  //  - pnpm: pnpm을 패키지 관리자로 사용합니다.
  //  - bun: bun을 패키지 관리자로 사용합니다.
  "npm.packageManager": "auto",

  // `--silent` 옵션으로 npm 명령 실행.
  "npm.runSilent": false,

  // NPM 스크립트 탐색기에서 사용되는 기본 클릭 작업: 'open' 또는 'run', 기본값은 'open'입니다.
  "npm.scriptExplorerAction": "open",

  // NPM 스크립트 뷰에서 제외해야 하는 스크립트를 나타내는 정규식 배열입니다.
  "npm.scriptExplorerExclude": [],

  // 스크립트에 대한 '실행' 및 '디버그' 명령으로 가리킵니다.
  "npm.scriptHover": true,

  // 스크립트를 실행하는 데 사용되는 스크립트 실행기입니다.
  //  - auto: 잠금 파일 및 설치된 패키지 관리자를 기반으로 사용할 스크립트 실행기를 자동 감지합니다.
  //  - npm: npm을 스크립트 실행기로 사용합니다.
  //  - yarn: Yarn을 스크립트 실행기로 사용합니다.
  //  - pnpm: pnpm을 스크립트 실행기로 사용합니다.
  //  - bun: 스크립트 실행기로 번을 사용합니다.
  //  - node: Node.js 스크립트 실행기로 사용합니다.
  "npm.scriptRunner": "auto",

  // CodeLens 참조를 선택할 때 '참조 피킹' 또는 '참조 찾기'를 호출할지 여부를 제어합니다.
  //  - peek: Peek 편집기에서 참조를 표시합니다.
  //  - view: 참조를 별도의 보기로 표시합니다.
  "references.preferredLocation": "peek",

  // 간단한 브라우저에 포커스가 있을 때를 보여 주는 부동 표시기를 사용하도록 설정/사용하지 않도록 설정합니다.
  "simpleBrowser.focusLockIndicator.enabled": true,

  // CSS for the active scope. Use {color} to match the bracket color. The string types listed at https://code.visualstudio.com/docs/extensionAPI/vscode-api#DecorationRenderOptions can be used
  "bracket-pair-colorizer-2.activeScopeCSS": ["borderStyle : solid", "borderWidth : 1px", "borderColor : {color}", "opacity: 0.5"],

  // Should different brackets share a color group (Consecutive), or use their own color group (Independent)
  "bracket-pair-colorizer-2.colorMode": "Consecutive",

  // Scope colors
  "bracket-pair-colorizer-2.colors": ["Gold", "Orchid", "LightSkyBlue"],

  // Show notice extension is deprecated
  "bracket-pair-colorizer-2.depreciation-notice": true,

  // Don't colorize files of these languages
  "bracket-pair-colorizer-2.excludedLanguages": [],

  // Should opening brackets iterate the color cycle even if they are not nested
  "bracket-pair-colorizer-2.forceIterationColorCycle": false,

  // Ensure that an opening brackets color does not match a previous brackets color
  "bracket-pair-colorizer-2.forceUniqueOpeningColor": false,

  // Should the active scope brackets always be highlighted? Recommended to disable editor.matchBrackets if using this feature.
  "bracket-pair-colorizer-2.highlightActiveScope": false,

  // Show active bracket scope in ruler?
  "bracket-pair-colorizer-2.rulerPosition": "Center",

  // CSS for the scope line. Use {color} to match the bracket color. The string types listed at https://code.visualstudio.com/docs/extensionAPI/vscode-api#DecorationRenderOptions can be used
  "bracket-pair-colorizer-2.scopeLineCSS": ["borderStyle : solid", "borderWidth : 1px", "borderColor : {color}", "opacity: 0.5"],

  // True: Scope Line will start from the ending bracket position. False: Scope Line will always be at column 0
  "bracket-pair-colorizer-2.scopeLineRelativePosition": true,

  // Show active bracket scope in gutter?
  "bracket-pair-colorizer-2.showBracketsInGutter": false,

  // Show active bracket scope in ruler?
  "bracket-pair-colorizer-2.showBracketsInRuler": false,

  // Show a horizontal line to create a block around the active bracket scope?
  "bracket-pair-colorizer-2.showHorizontalScopeLine": true,

  // Show a vertical line on the left side of the editor representing the active bracket scope?
  "bracket-pair-colorizer-2.showVerticalScopeLine": true,

  // Unmatched Scope Color
  "bracket-pair-colorizer-2.unmatchedScopeColor": "Red",

  // The setting is deprecated. Use editor.codeActionsOnSave instead with a source.fixAll.eslint member.
  // Turns auto fix on save on or off.
  "eslint.autoFixOnSave": false,

  // Show disable lint rule in the quick fix menu.
  "eslint.codeAction.disableRuleComment": {
    "enable": true,
    "location": "separateLine",
    "commentStyle": "line"
  },

  // Show open lint rule documentation web page in the quick fix menu.
  "eslint.codeAction.showDocumentation": {
    "enable": true
  },

  // Specifies the code action mode. Possible values are 'all' and 'problems'.
  //  - all: Fixes all possible problems in the file. This option might take some time.
  //  - problems: Fixes only reported problems that have non-overlapping textual edits. This option runs a lot faster.
  "eslint.codeActionsOnSave.mode": "all",

  // The ESLint options object to use on save (see https://eslint.org/docs/developer-guide/nodejs-api#eslint-class). `eslint.codeActionsOnSave.rules`, if specified, will take priority over any rule options here.
  "eslint.codeActionsOnSave.options": {},

  // The rules that should be executed when computing the code actions on save or formatting a file. Defaults to the rules configured via the ESLint configuration
  "eslint.codeActionsOnSave.rules": null,

  // Enables ESLint debug mode (same as `--debug` on the command line)
  "eslint.debug": false,

  // Controls whether eslint is enabled or not.
  "eslint.enable": true,

  // Additional exec argv argument passed to the runtime. This can for example be used to control the maximum heap space using --max_old_space_size
  "eslint.execArgv": null,

  // Use ESLint version 8.57 or later and `eslint.useFlatConfig` instead.
  // Enables support of experimental Flat Config (aka eslint.config.js). Requires ESLint version >= 8.21 < 8.57.0).
  "eslint.experimental.useFlatConfig": false,

  // Enables ESLint as a formatter.
  "eslint.format.enable": false,

  // If true, untitled files won't be validated by ESLint.
  "eslint.ignoreUntitled": false,

  // Controls whether a task for linting the whole workspace will be available.
  "eslint.lintTask.enable": false,

  // Command line options applied when running the task for linting the whole workspace (see https://eslint.org/docs/user-guide/command-line-interface).
  "eslint.lintTask.options": ".",

  // Whether ESlint should migrate auto fix on save settings.
  "eslint.migration.2_x": "on",

  // The value of `NODE_ENV` to use when running eslint tasks.
  "eslint.nodeEnv": null,

  // A path added to `NODE_PATH` when resolving the eslint module.
  "eslint.nodePath": null,

  // A special rules customization section for text cells in notebook documents.
  "eslint.notebooks.rules.customizations": [],

  // Whether ESLint should issue a warning on ignored files.
  "eslint.onIgnoredFiles": "off",

  // The eslint options object to provide args normally passed to eslint when executed from a command line (see https://eslint.org/docs/developer-guide/nodejs-api#eslint-class).
  "eslint.options": {},

  // The setting is deprecated. The Package Manager is automatically detected now.
  // The package manager you use to install node modules.
  "eslint.packageManager": "npm",

  // An array of language ids for which the extension should probe if support is installed.
  "eslint.probe": [
    "astro",
    "civet",
    "javascript",
    "javascriptreact",
    "typescript",
    "typescriptreact",
    "html",
    "mdx",
    "vue",
    "markdown",
    "json",
    "jsonc"
  ],

  // Shortens the text spans of underlined problems to their first related line.
  "eslint.problems.shortenToSingleLine": false,

  // This option is deprecated. Use eslint.lintTask.enable instead.
  // Controls whether a task for linting the whole workspace will be available.
  "eslint.provideLintTask": false,

  // Turns on quiet mode, which ignores warnings.
  "eslint.quiet": false,

  // Override the severity of one or more rules reported by this extension, regardless of the project's ESLint config. Use globs to apply default severities for multiple rules.
  "eslint.rules.customizations": [],

  // Run the linter on save (onSave) or on type (onType)
  "eslint.run": "onType",

  // The location of the node binary to run ESLint under.
  "eslint.runtime": null,

  // The time budget in milliseconds to spend on computing fixes before showing a warning or error.
  "eslint.timeBudget.onFixes": {
    "warn": 3000,
    "error": 6000
  },

  // The time budget in milliseconds to spend on validation before showing a warning or error.
  "eslint.timeBudget.onValidation": {
    "warn": 4000,
    "error": 8000
  },

  // Traces the communication between VSCode and the eslint linter service.
  "eslint.trace.server": "off",

  // Since version 7 ESLint offers a new API call ESLint. Use it even if the old CLIEngine is available. From version 8 on forward on ESLint class is available.
  "eslint.useESLintClass": false,

  // Controls whether flat config should be used or not. This setting requires ESLint version 8.57 or later and is interpreted according to the [ESLint Flat Config rollout plan](https://eslint.org/blog/2023/10/flat-config-rollout-plans/). This means:
  //
  //  - *8.57.0 <= ESLint version < 9.x*: setting is honored and defaults to false
  // - *9.0.0 <= ESLint version < 10.x*: settings is honored and defaults to true
  // - *10.0.0 <= ESLint version*: setting is ignored. Flat configs are the default and can't be turned off.
  "eslint.useFlatConfig": null,

  // An array of language ids which should be validated by ESLint. If not installed ESLint will show an error.
  "eslint.validate": null,

  // Specifies how the working directories ESLint is using are computed. ESLint resolves configuration files (e.g. `eslintrc`, `.eslintignore`) relative to a working directory so it is important to configure this correctly.
  "eslint.workingDirectories": [],

  // Always prompt with repository picker when running Git History
  "gitHistory.alwaysPromptRepositoryPicker": false,

  // Avatar image cache expiration (0 = cache disabled)
  "gitHistory.avatarCacheExpiration": 60,

  // Prefer to open repository (instead of file) when pressing the editor title button
  "gitHistory.editorTitleButtonOpenRepo": false,

  // Whether to display the commit explorer view
  "gitHistory.hideCommitViewExplorer": false,

  // Include remote branches when opening Git History
  "gitHistory.includeRemoteBranches": false,

  // Output log information
  "gitHistory.logLevel": "Info",

  // Default number of items to be displayed in Git History Viewer
  "gitHistory.pageSize": 100,

  // Whether to display a button in the editor title menu bar
  "gitHistory.showEditorTitleMenuBarIcons": true,

  // Split show file history when file is active.
  "gitHistory.showFileHistorySplit": true,

  // Show commit details in side-by-side view
  "gitHistory.sideBySide": false,

  // Specifies where the 'Git: View History' action appears on the title of SCM Providers.
  //  - Inline: Show the 'Git: View History' action on the title of SCM Providers
  //  - More Actions: Show the 'Git: View History' action in the 'More Actions...' menu on the title of SCM Providers
  "gitHistory.sourceCodeProviderIntegrationLocation": "Inline",

  // Include parentheses around a sole arrow function parameter.
  "prettier.arrowParens": "always",

  // Puts the `>` of a multi-line HTML (HTML, JSX, Vue, Angular) element at the end of the last line instead of being alone on the next line (does not apply to self closing elements).
  "prettier.bracketSameLine": false,

  // Controls the printing of spaces inside object literals.
  "prettier.bracketSpacing": true,

  // Path to the prettier configuration file.
  "prettier.configPath": "",

  // This feature is no longer supported. Instead, configure VS Code [default formatters](https://github.com/prettier/prettier-vscode#default-formatter) or use .prettierignore.
  // A list of languages IDs to disable this extension on.
  "prettier.disableLanguages": [],

  // A list of [glob patterns](https://code.visualstudio.com/api/references/vscode-api#GlobPattern) to register Prettier formatter.
  "prettier.documentSelectors": [],

  // Control whether Prettier formats quoted code embedded in the file.
  "prettier.embeddedLanguageFormatting": "auto",

  // Controls whether Prettier is enabled or not. Reload required.
  "prettier.enable": true,

  // Enable debug logs for troubleshooting.
  "prettier.enableDebugLogs": false,

  // Specify the end of line used by prettier.
  "prettier.endOfLine": "lf",

  // Try prettier's [new ternary formatting](https://github.com/prettier/prettier/pull/13183) before it becomes the default behavior.
  "prettier.experimentalTernaries": false,

  // Specify the global [whitespace sensitivity](https://prettier.io/blog/2018/11/07/1.15.0.html#whitespace-sensitive-formatting) for HTML files.
  // Valid options:
  // - `css` - Respect the default value of CSS `display` property.
  // - `strict` - Whitespaces are considered sensitive.
  // - `ignore` - Whitespaces are considered insensitive.
  "prettier.htmlWhitespaceSensitivity": "css",

  // Path to a `.prettierignore` file.
  "prettier.ignorePath": ".prettierignore",

  // Prettier can insert a special `@format` marker at the top of files specifying that the file has been formatted with prettier. This works well when used in tandem with the `--require-pragma` option. If there is already a docblock at the top of the file then this option will add a newline to it with the `@format` marker.
  "prettier.insertPragma": false,

  // This option has been deprecated in v2.4.0, use `bracketSameLine` instead.
  // Puts the `>` of a multi-line jsx element at the end of the last line instead of being alone on the next line (does not apply to self closing elements).
  "prettier.jsxBracketSameLine": false,

  // Use single quotes instead of double quotes in JSX.
  "prettier.jsxSingleQuote": false,

  // Package manager is now automatically detected by VS Code. This setting is no longer used.
  // The package manager you use to install node modules.
  "prettier.packageManager": "npm",

  // Path to the `prettier` module, eg: `./node_modules/prettier`.
  "prettier.prettierPath": "",

  // Fit code within this line limit.
  "prettier.printWidth": 80,

  // (Markdown) wrap prose over multiple lines.
  "prettier.proseWrap": "preserve",

  // Change when properties in objects are quoted.
  // Valid options:
  // - `"as-needed"` - Only add quotes around object properties where required.
  // - `"consistent"` - If at least one property in an object requires quotes, quote all properties.
  // - `"preserve"` - Respect the input use of quotes in object properties.
  "prettier.quoteProps": "as-needed",

  // Require a prettier configuration file to format. See [documentation for valid configuration files](https://prettier.io/docs/en/configuration.html).
  //
  // > _Note, untitled files will still be formatted using the VS Code prettier settings even when this setting is set._
  "prettier.requireConfig": false,

  // Prettier can restrict itself to only format files that contain a special comment, called a pragma, at the top of the file. This is very useful when gradually transitioning large, unformatted codebases to prettier.
  "prettier.requirePragma": false,

  // When enabled, this extension will attempt to use global npm or yarn modules if local modules cannot be resolved.
  // > _This setting can have a negative performance impact, particularly on Windows when you have attached network drives. Only enable this if you must use global modules._
  "prettier.resolveGlobalModules": false,

  // Whether to add a semicolon at the end of every line.
  "prettier.semi": true,

  // Enforces single attribute per line in HTML, JSX, Vue and Angular.
  "prettier.singleAttributePerLine": false,

  // Use single instead of double quotes.
  "prettier.singleQuote": false,

  // Number of spaces it should use per tab.
  "prettier.tabWidth": 2,

  // Controls the printing of trailing commas wherever possible.
  // Valid options:
  // - `none` - No trailing commas
  // - `es5` - Trailing commas where valid in ES5 (objects, arrays, etc)
  // - `all` - Trailing commas wherever possible (function arguments)
  "prettier.trailingComma": "es5",

  // Whether or not to take `.editorconfig` into account when parsing configuration. See the [`prettier.resolveConfig`](https://prettier.io/docs/en/api.html) docs for details.
  "prettier.useEditorConfig": true,

  // Indent lines with tabs.
  "prettier.useTabs": false,

  // Whether or not to indent the code inside `<script>` and `<style>` tags in Vue SFC files.
  "prettier.vueIndentScriptAndStyle": false,

  // This extension will process files in `node_modules`.
  "prettier.withNodeModules": false,

  // Whether to clear previous output before each run.
  "code-runner.clearPreviousOutput": false,

  // Set the custom command to run.
  "code-runner.customCommand": "echo Hello",

  // Set the working directory.
  "code-runner.cwd": "",

  // Set the default language to run.
  "code-runner.defaultLanguage": "",

  // Whether to enable AppInsights to track user telemetry data.
  "code-runner.enableAppInsights": true,

  // Set the executor of each language.
  "code-runner.executorMap": {
    "javascript": "node",
    "java": "cd $dir && javac $fileName && java $fileNameWithoutExt",
    "c": "cd $dir && gcc $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt",
    "zig": "zig run",
    "cpp": "cd $dir && g++ $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt",
    "objective-c": "cd $dir && gcc -framework Cocoa $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt",
    "php": "php",
    "python": "python -u",
    "perl": "perl",
    "perl6": "perl6",
    "ruby": "ruby",
    "go": "go run",
    "lua": "lua",
    "groovy": "groovy",
    "powershell": "powershell -ExecutionPolicy ByPass -File",
    "bat": "cmd /c",
    "shellscript": "bash",
    "fsharp": "fsi",
    "csharp": "scriptcs",
    "vbscript": "cscript //Nologo",
    "typescript": "ts-node",
    "coffeescript": "coffee",
    "scala": "scala",
    "swift": "swift",
    "julia": "julia",
    "crystal": "crystal",
    "ocaml": "ocaml",
    "r": "Rscript",
    "applescript": "osascript",
    "clojure": "lein exec",
    "haxe": "haxe --cwd $dirWithoutTrailingSlash --run $fileNameWithoutExt",
    "rust": "cd $dir && rustc $fileName && $dir$fileNameWithoutExt",
    "racket": "racket",
    "scheme": "csi -script",
    "ahk": "autohotkey",
    "autoit": "autoit3",
    "dart": "dart",
    "pascal": "cd $dir && fpc $fileName && $dir$fileNameWithoutExt",
    "d": "cd $dir && dmd $fileName && $dir$fileNameWithoutExt",
    "haskell": "runghc",
    "nim": "nim compile --verbosity:0 --hints:off --run",
    "lisp": "sbcl --script",
    "kit": "kitc --run",
    "v": "v run",
    "sass": "sass --style expanded",
    "scss": "scss --style expanded",
    "less": "cd $dir && lessc $fileName $fileNameWithoutExt.css",
    "FortranFreeForm": "cd $dir && gfortran $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt",
    "fortran-modern": "cd $dir && gfortran $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt",
    "fortran_fixed-form": "cd $dir && gfortran $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt",
    "fortran": "cd $dir && gfortran $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt",
    "sml": "cd $dir && sml $fileName",
    "mojo": "mojo run",
    "erlang": "escript",
    "spwn": "spwn build",
    "pkl": "cd $dir && pkl eval -f yaml $fileName -o $fileNameWithoutExt.yaml",
    "gleam": "gleam run -m $fileNameWithoutExt"
  },

  // Set the executor of each file extension.
  "code-runner.executorMapByFileExtension": {
    ".vb": "cd $dir && vbc /nologo $fileName && $dir$fileNameWithoutExt",
    ".vbs": "cscript //Nologo",
    ".scala": "scala",
    ".jl": "julia",
    ".cr": "crystal",
    ".ml": "ocaml",
    ".zig": "zig run",
    ".exs": "elixir",
    ".hx": "haxe --cwd $dirWithoutTrailingSlash --run $fileNameWithoutExt",
    ".rkt": "racket",
    ".scm": "csi -script",
    ".ahk": "autohotkey",
    ".au3": "autoit3",
    ".kt": "cd $dir && kotlinc $fileName -include-runtime -d $fileNameWithoutExt.jar && java -jar $fileNameWithoutExt.jar",
    ".kts": "kotlinc -script",
    ".dart": "dart",
    ".pas": "cd $dir && fpc $fileName && $dir$fileNameWithoutExt",
    ".pp": "cd $dir && fpc $fileName && $dir$fileNameWithoutExt",
    ".d": "cd $dir && dmd $fileName && $dir$fileNameWithoutExt",
    ".hs": "runhaskell",
    ".nim": "nim compile --verbosity:0 --hints:off --run",
    ".csproj": "dotnet run --project",
    ".fsproj": "dotnet run --project",
    ".lisp": "sbcl --script",
    ".kit": "kitc --run",
    ".v": "v run",
    ".vsh": "v run",
    ".sass": "sass --style expanded",
    ".cu": "cd $dir && nvcc $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt",
    ".ring": "ring",
    ".sml": "cd $dir && sml $fileName",
    ".mojo": "mojo run",
    ".erl": "escript",
    ".spwn": "spwn build",
    ".pkl": "cd $dir && pkl eval -f yaml $fileName -o $fileNameWithoutExt.yaml",
    ".gleam": "gleam run -m $fileNameWithoutExt"
  },

  // Set the executor by glob.
  "code-runner.executorMapByGlob": {
    "pom.xml": "cd $dir && mvn clean package"
  },

  // Whether to use the directory of the file to be executed as the working directory.
  "code-runner.fileDirectoryAsCwd": false,

  // Whether to ignore selection to always run entire file.
  "code-runner.ignoreSelection": false,

  // Set the mapping of languageId to file extension.
  "code-runner.languageIdToFileExtensionMap": {
    "bat": ".bat",
    "powershell": ".ps1",
    "typescript": ".ts"
  },

  // Whether to preserve focus on code editor after code run is triggered.
  "code-runner.preserveFocus": true,

  // Whether to respect Shebang to run code.
  "code-runner.respectShebang": true,

  // Whether to run code in Integrated Terminal.
  "code-runner.runInTerminal": false,

  // Whether to save all files before running.
  "code-runner.saveAllFilesBeforeRun": false,

  // Whether to save the current file before running.
  "code-runner.saveFileBeforeRun": false,

  // Whether to show extra execution message like [Running] ... and [Done] ...
  "code-runner.showExecutionMessage": true,

  // Whether to show 'Run Code' command in editor context menu.
  "code-runner.showRunCommandInEditorContextMenu": true,

  // Whether to show 'Run Code' command in explorer context menu.
  "code-runner.showRunCommandInExplorerContextMenu": true,

  // Whether to show 'Run Code' icon in editor title menu.
  "code-runner.showRunIconInEditorTitleMenu": true,

  // Whether to show 'Stop code run' icon in the editor title menu when code is running.
  "code-runner.showStopIconInEditorTitleMenu": true,

  // Temporary file name used in running selected code snippet. When it is set as empty, the file name will be random.
  "code-runner.temporaryFileName": "tempCodeRunnerFile",

  // For Windows system, replaces the Windows style drive letter in the command with a Unix style root when using a custom shell as the terminal, like Bash or Cgywin. Example: Setting this to '/mnt/' will replace 'C:\path' with '/mnt/c/path'
  "code-runner.terminalRoot": "",

  // Automatically add vendor prefixes to unsupported CSS properties (e. g. transform -> -ms-transform). Specify what browsers to target with an array of strings (uses [Browserslist](https://github.com/ai/browserslist)). Pass `false` to turn off.
  "liveSassCompile.settings.autoprefix": "defaults",

  // Set this to `false` if you don't want all Sass files to be compiled when Live Sass Compiler starts watching.
  "liveSassCompile.settings.compileOnWatch": true,

  // All Sass/Scss files inside the folders will be excluded.
  //
  // Examples:
  // '/**/node_modules/**',
  // '/.vscode/**',
  // '/.history/**'
  //
  // Glob Patterns are accepted.
  "liveSassCompile.settings.excludeList": ["/**/node_modules/**", "/.vscode/**"],

  // Defines a subdirectory to search from (no directory outside of this will be search)
  "liveSassCompile.settings.forceBaseDirectory": null,

  // Set your exported CSS Styles, Formats & save location.
  "liveSassCompile.settings.formats": [
    {
      "format": "expanded",
      "extensionName": ".css",
      "savePath": null,
      "savePathReplacementPairs": null
    }
  ],

  // Set to `false` if you don't want a `.map` file for each compiled CSS.
  // Default is `true`
  "liveSassCompile.settings.generateMap": true,

  // This setting is useful when you only deal with a few sass files. Only these Sass files will be included.
  // NOTE: There is no need to include partial sass files.
  "liveSassCompile.settings.includeItems": null,

  // Specific glob patterns to identify partial files/folders
  "liveSassCompile.settings.partialsList": ["/**/_*.s[ac]ss"],

  // A leading slash is relative to the workspace, not the drive (e.g C://)
  "liveSassCompile.settings.rootIsWorkspace": false,

  // Show the announcement whenever a new version is installed
  "liveSassCompile.settings.showAnnouncements": true,

  // Please use showOutputWindowOn instead
  // Backwards compatible setting for those migrating from the original extension
  "liveSassCompile.settings.showOutputWindow": null,

  // Set the level of logging that is recorded and shown to you.
  // Default is `Information`
  "liveSassCompile.settings.showOutputWindowOn": "Information",

  // Set to `true` to use new SASS's new `compile` function. It's more performant!
  "liveSassCompile.settings.useNewCompiler": false,

  // Set this to `true` if you want Live Sass Compiler to automatically start watching your .sass or .scss file when you open an applicable workspace
  // Default is `false`
  "liveSassCompile.settings.watchOnLaunch": false,

  // Note: If it is not Null, It will override CustomBrowser and ChromeDebuggingAttachment settings.
  //
  //  Examples :
  // chrome --incognito --headless --remote-debugging-port=9222
  //  C:\\Program Files\\Firefox Developer Edition\\firefox.exe --private-window
  "liveServer.settings.AdvanceCustomBrowserCmdLine": null,

  // Enable Chrome Debugging Attachment to Live Server at Debuging Port 9222.
  //  NOTE: You have to install 'Debugger for Chrome'
  // If the value is true, Select 'Attach to Chrome' from Debug Window to start debugging.
  //
  //  CAUTION: If it is true, 'Launch Chrome against localhost' may not work.
  "liveServer.settings.ChromeDebuggingAttachment": false,

  // Specify custom browser settings for Live Server.
  // By Default it will open your default favorite browser.
  "liveServer.settings.CustomBrowser": null,

  // To disable information pop up messages.
  "liveServer.settings.donotShowInfoMsg": false,

  // To turn off prompt warning message if body or head or other supporting tag is missing in your HTML.
  "liveServer.settings.donotVerifyTags": false,

  // When set, serve this file (server root relative) for every 404 (useful for single-page applications)
  "liveServer.settings.file": "",

  // By Default Live Server inject CSS changes without full reloading of browser. You can change this behavior by making this setting as `true`
  "liveServer.settings.fullReload": false,

  // To switch between localhost or 127.0.0.1 or anything else. Default is 127.0.0.1
  "liveServer.settings.host": "127.0.0.1",

  // Setup https configuration
  "liveServer.settings.https": {
    "enable": false,
    "cert": "",
    "key": "",
    "passphrase": ""
  },

  // To ignore specific file changes
  "liveServer.settings.ignoreFiles": [".vscode/**", "**/*.scss", "**/*.sass", "**/*.ts"],

  // Mount a directory to a route. Such as [['/components', './node_modules']]
  "liveServer.settings.mount": [],

  // This the entry point of server when you're in multiroot workspace
  "liveServer.settings.multiRootWorkspaceName": null,

  // If it is true live server will start without browser opened.
  "liveServer.settings.NoBrowser": false,

  // Set Custom Port Number of Live Server. Set 0 if you want random port.
  "liveServer.settings.port": 3009,
  "liveServer.settings.host": "localhost",

  // To Setup Proxy
  "liveServer.settings.proxy": {
    "enable": false,
    "baseUri": "/",
    "proxyUri": "http://127.0.0.1:80"
  },

  // Set Custom root of Live Server.
  // To change root the the server to sub folder of workspace, use '/' and relative path from workspace.
  // Example: /subfolder1/subfolder2
  "liveServer.settings.root": "/",

  // Change this to false if you don't want the button to show in the statusbar
  "liveServer.settings.showOnStatusbar": true,

  // Use local IP as host
  "liveServer.settings.useLocalIp": false,

  // You have to install a browser extension. That will be works for your dynamic pages (like PHP).
  "liveServer.settings.useWebExt": false,

  // Delay before live reloading. Value in milliseconds. Default is 100
  "liveServer.settings.wait": 100,

  // items in this array will be at the top of the completion list (only for items that show after the & sign)
  "sass.andStared": ["active", "focus", "hover", "nth-child"],

  // Stop the extension from automatically indenting when pressing Enter
  "sass.disableAutoIndent": false,

  // adds magic comments to the intellisense completions if false.
  "sass.disableCommentCompletion": false,

  // adds units to the intellisense completions if false.
  "sass.disableUnitCompletion": true,

  // Convert scss/css to sass.
  "sass.format.convert": true,

  // enables debug mode.
  "sass.format.debug": false,

  // removes empty rows.
  "sass.format.deleteEmptyRows": true,

  // removes trailing whitespace.
  "sass.format.deleteWhitespace": true,

  // enables the sass formatter.
  "sass.format.enabled": true,

  // If true space between the property: value, is always set to 1.
  "sass.format.setPropertySpace": true,

  // Root path used to look for Sass import files, used when comiling Sass with --load-path
  "sass.importRoot": "",

  // Set default browser
  "open-in-browser.default": ""
}
